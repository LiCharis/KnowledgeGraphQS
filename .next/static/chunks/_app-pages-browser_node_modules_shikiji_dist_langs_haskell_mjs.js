"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_shikiji_dist_langs_haskell_mjs"],{

/***/ "(app-pages-browser)/./node_modules/shikiji/dist/langs/haskell.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/shikiji/dist/langs/haskell.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ haskell; }\n/* harmony export */ });\nconst lang = Object.freeze({ \"fileTypes\": [\"hs\", \"hs-boot\", \"hsig\"], \"keyEquivalent\": \"^~H\", \"name\": \"haskell\", \"patterns\": [{ \"include\": \"#liquid_haskell\" }, { \"include\": \"#comment_like\" }, { \"include\": \"#numeric_literals\" }, { \"include\": \"#string_literal\" }, { \"include\": \"#char_literal\" }, { \"match\": \"(?<!@|#)-\\\\}\", \"name\": \"invalid\" }, { \"match\": \"(\\\\()\\\\s*(\\\\))\", \"name\": \"constant.language.unit.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(\\\\()(#)\\\\s*(#)(\\\\))\", \"name\": \"constant.language.unit.unboxed.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" }, \"3\": { \"name\": \"keyword.operator.hash.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(\\\\()\\\\s*,[\\\\s,]*(\\\\))\", \"name\": \"support.constant.tuple.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(\\\\()(#)\\\\s*,[\\\\s,]*(#)(\\\\))\", \"name\": \"support.constant.tuple.unboxed.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" }, \"3\": { \"name\": \"keyword.operator.hash.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(\\\\[)\\\\s*(\\\\])\", \"name\": \"constant.language.empty-list.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.bracket.haskell\" }, \"2\": { \"name\": \"punctuation.bracket.haskell\" } } }, { \"begin\": \"(\\\\b(?<!')(module)|^(signature))(\\\\b(?!'))\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.module.haskell\" }, \"3\": { \"name\": \"keyword.other.signature.haskell\" } }, \"end\": \"(?=\\\\b(?<!')where\\\\b(?!'))\", \"name\": \"meta.declaration.module.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#module_name\" }, { \"include\": \"#module_exports\" }, { \"match\": \"[a-z]+\", \"name\": \"invalid\" }] }, { \"include\": \"#ffi\" }, { \"begin\": \"^(\\\\s*)(class)(\\\\b(?!'))\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.class.haskell\" } }, \"end\": \"(?x) # Detect end of class declaration:\\n         # 'where' keyword\\n   (?=(?<!')\\\\bwhere\\\\b(?!'))  \\n         # Decreasing indentation\\n   |(?=\\\\}|;)      # Explicit indentation\\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n       \\\\1\\\\s+\\\\S    # - more indented, or\\n     | \\\\s*        # - starts with whitespace, followed by:\\n       (?: $      #   - the end of the line (i.e. empty line), or\\n       |\\\\{-[^@]   #   - the start of a block comment, or\\n       |--+       #   - the start of a single-line comment.\\n          (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                  # The double dash may not be followed by other operator characters\\n                  # (then it would be an operator, not a comment)\\n     )\", \"name\": \"meta.declaration.class.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#where\" }, { \"include\": \"#type_signature\" }] }, { \"begin\": `(?x)\n  ^(\\\\s*)(data|newtype)(?:\\\\s+(instance))?\\\\s+\n  # Keep consuming characters until:\n  ((?:(?!\n  # the equals symbol or the start of a single-line comment, or\n    (?: \n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']]) # non-symbol\n      (?:=|--+)\n      (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']])  # non-symbol\n    )\n  # the \"where\" or \"deriving\" keywords, or\n  | (?:\\\\b(?<!')(?:where|deriving)\\\\b(?!'))\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)\n  (?=\\\\b(?<!'')where\\\\b(?!''))`, \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.$2.haskell\" }, \"3\": { \"name\": \"keyword.other.instance.haskell\" }, \"4\": { \"patterns\": [{ \"include\": \"#type_signature\" }] } }, \"name\": \"meta.declaration.$2.generalized.haskell\", \"end\": \"(?x) # Detect end of data declaration:\\n         # Deriving clause\\n   (?=(?<!')\\\\bderiving\\\\b(?!'))  \\n         # Decreasing indentation\\n   |(?=\\\\}|;)      # Explicit indentation\\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n       \\\\1\\\\s+\\\\S    # - more indented, or\\n     | \\\\s*        # - starts with whitespace, followed by:\\n       (?: $      #   - the end of the line (i.e. empty line), or\\n       |\\\\{-[^@]   #   - the start of a block comment, or\\n       |--+       #   - the start of a single-line comment.\\n          (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                  # The double dash may not be followed by other operator characters\\n                  # (then it would be an operator, not a comment)\\n     )\\n\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"begin\": \"(?x)\\n  (?<!')\\\\b(where)\\n  \\\\s*(\\\\{)(?!-)\", \"end\": \"(\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.where.haskell\" }, \"2\": { \"name\": \"punctuation.brace.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#gadt_constructor\" }, { \"match\": \";\", \"name\": \"punctuation.semicolon.haskell\" }] }, { \"match\": \"\\\\b(?<!')(where)\\\\b(?!')\", \"name\": \"keyword.other.where.haskell\" }, { \"include\": \"#deriving\" }, { \"include\": \"#gadt_constructor\" }] }, { \"include\": \"#role_annotation\" }, { \"name\": \"meta.declaration.pattern.type.haskell\", \"begin\": \"^(\\\\s*)(pattern)\\\\s+(.*?)\\\\s+(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.pattern.haskell\" }, \"3\": { \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"#data_constructor\" }] }, \"4\": { \"name\": \"keyword.operator.double-colon.haskell\" } }, \"end\": \"(?x) # Detect end of pattern type definition by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"name\": \"meta.declaration.pattern.haskell\", \"begin\": \"^\\\\s*(pattern)\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"keyword.other.pattern.haskell\" } }, \"end\": \"(?x) # Detect end of pattern type definition by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"$self\" }] }, { \"begin\": `(?x)\n  # Data declaration\n  ^(\\\\s*)(data|newtype)(?:\\\\s+(family|instance))?\\\\s+\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol or the start of a single-line comment, or\n    (?: \n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']]) # non-symbol\n      (?:=|--+)\n      (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']])  # non-symbol\n    )\n  # the \"where\" or \"deriving\" keywords, or\n  | (?:\\\\b(?<!')(?:where|deriving)\\\\b(?!'))\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)`, \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.$2.haskell\" }, \"3\": { \"name\": \"keyword.other.$3.haskell\" }, \"4\": { \"patterns\": [{ \"include\": \"#type_signature\" }] } }, \"name\": \"meta.declaration.$2.algebraic.haskell\", \"end\": \"(?x) # Detect end of data declaration: \\n     # Decreasing indentation\\n   (?=\\\\}|;)      # Explicit indentation\\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n       \\\\1\\\\s+\\\\S    # - more indented, or\\n     | \\\\s*        # - starts with whitespace, followed by:\\n       (?: $      #   - the end of the line (i.e. empty line), or\\n       |\\\\{-[^@]   #   - the start of a block comment, or\\n       |--+       #   - the start of a single-line comment.\\n          (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                  # The double dash may not be followed by other operator characters\\n                  # (then it would be an operator, not a comment)\\n     )\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#deriving\" }, { \"include\": \"#forall\" }, { \"include\": \"#adt_constructor\" }, { \"include\": \"#context\" }, { \"include\": \"#record_decl\" }, { \"include\": \"#type_signature\" }] }, { \"name\": \"meta.declaration.type.family.haskell\", \"begin\": `(?x)\n  # Type family\n  ^(\\\\s*)(type)\\\\s+(family)\\\\b(?!')\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol or the start of a single-line comment, or\n    (?: \n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']]) # non-symbol\n      (?:=|--+)\n      (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']])  # non-symbol\n    )\n  # the \"where\" keyword, or\n  | \\\\b(?<!')where\\\\b(?!')\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)`, \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.type.haskell\" }, \"3\": { \"name\": \"keyword.other.family.haskell\" }, \"4\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#where\" }, { \"include\": \"#type_signature\" }] } }, \"end\": \"(?x) # Detect end of type family by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#where\" }, { \"include\": \"#type_signature\" }] }, { \"name\": \"meta.declaration.type.haskell\", \"begin\": \"(?x)\\n  # Type declaration\\n  ^(\\\\s*)(type)(?:\\\\s+(instance))?\\\\s+\\n  # Keep consuming characters until:\\n  (((?!\\n  # the equals symbol, the start of a single-line comment, or a type signature\\n    (?: \\n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]) # non-symbol\\n      (?:=|--+|::|\\u2237)\\n      (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])  # non-symbol\\n    )\\n  # the start of a block comment.\\n  | {-\\n  #\\n  ).)*)\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.type.haskell\" }, \"3\": { \"name\": \"keyword.other.instance.haskell\" }, \"4\": { \"patterns\": [{ \"include\": \"#type_signature\" }] } }, \"end\": \"(?x) # Detect end of type definition by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"begin\": \"^(\\\\s*)(instance)(\\\\b(?!'))\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.instance.haskell\" } }, \"end\": \"(?x) # Detect end of instance declaration:\\n  # 'where' keyword\\n  (?=\\\\b(?<!')(where)\\\\b(?!'))\\n  # Decreasing indentation\\n  |(?=\\\\}|;)      # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"name\": \"meta.declaration.instance.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#where\" }, { \"include\": \"#type_signature\" }] }, { \"begin\": \"^(\\\\s*)(import)(\\\\b(?!'))\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.import.haskell\" } }, \"end\": \"(?x) # Detect end of import\\n  # 'where' keyword\\n  (?=\\\\b(?<!')(where)\\\\b(?!'))\\n  # Decreasing indentation\\n  |(?=\\\\}|;)      # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"name\": \"meta.import.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#where\" }, { \"match\": \"(qualified|as|hiding)\", \"captures\": { \"1\": { \"name\": \"keyword.other.$1.haskell\" } } }, { \"include\": \"#module_name\" }, { \"include\": \"#module_exports\" }] }, { \"include\": \"#deriving\" }, { \"include\": \"#layout_herald\" }, { \"include\": \"#keyword\" }, { \"match\": \"^\\\\s*(infix[lr]?)\\\\s+(.*)\", \"captures\": { \"1\": { \"name\": \"keyword.other.$1.haskell\" }, \"2\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#integer_literals\" }, { \"include\": \"#infix_op\" }] } }, \"name\": \"meta.fixity-declaration.haskell\" }, { \"include\": \"#overloaded_label\" }, { \"include\": \"#type_application\" }, { \"include\": \"#reserved_symbol\" }, { \"include\": \"#fun_decl\" }, { \"include\": \"#qualifier\" }, { \"include\": \"#data_constructor\" }, { \"include\": \"#start_type_signature\" }, { \"include\": \"#prefix_op\" }, { \"include\": \"#infix_op\" }, { \"begin\": \"(\\\\()(#)\\\\s\", \"end\": \"(#)(\\\\))\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"keyword.operator.hash.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"$self\" }] }, { \"begin\": \"(\\\\()\", \"end\": \"(\\\\))\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"$self\" }] }, { \"include\": \"#quasi_quote\" }, { \"begin\": \"(\\\\[)\", \"end\": \"(\\\\])\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.bracket.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.bracket.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"$self\" }] }, { \"include\": \"#record\" }], \"repository\": { \"block_comment\": { \"applyEndPatternLast\": 1, \"begin\": \"\\\\{-\", \"captures\": { \"0\": { \"name\": \"punctuation.definition.comment.haskell\" } }, \"end\": \"-\\\\}\", \"name\": \"comment.block.haskell\", \"patterns\": [{ \"include\": \"#block_comment\" }] }, \"comments\": { \"patterns\": [{ \"begin\": \"^(\\\\s*)(--\\\\s[\\\\|\\\\$])\", \"beginCaptures\": { \"2\": { \"name\": \"punctuation.whitespace.comment.leading.haskell\" } }, \"end\": \"(?=^(?!\\\\1--+(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])))\", \"name\": \"comment.block.documentation.haskell\" }, { \"begin\": \"(^[ \\\\t]+)?(--\\\\s[\\\\^\\\\*])\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.whitespace.comment.leading.haskell\" } }, \"end\": \"\\\\n\", \"name\": \"comment.line.documentation.haskell\" }, { \"applyEndPatternLast\": 1, \"begin\": \"\\\\{-\\\\s?[\\\\|\\\\$\\\\*\\\\^]\", \"captures\": { \"0\": { \"name\": \"punctuation.definition.comment.haskell\" } }, \"end\": \"-\\\\}\", \"name\": \"comment.block.documentation.haskell\", \"patterns\": [{ \"include\": \"#block_comment\" }] }, { \"begin\": \"(^[ \\\\t]+)?(?=--+(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]))\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.whitespace.comment.leading.haskell\" } }, \"comment\": \"Operators may begin with '--' as long as they are not entirely composed of '-' characters. This means comments can't be immediately followed by an allowable operator character.\", \"end\": \"(?!\\\\G)\", \"patterns\": [{ \"begin\": \"--\", \"beginCaptures\": { \"0\": { \"name\": \"punctuation.definition.comment.haskell\" } }, \"end\": \"\\\\n\", \"name\": \"comment.line.double-dash.haskell\" }] }, { \"include\": \"#block_comment\" }] }, \"comment_like\": { \"patterns\": [{ \"include\": \"#cpp\" }, { \"include\": \"#pragma\" }, { \"include\": \"#comments\" }] }, \"cpp\": { \"captures\": { \"1\": { \"name\": \"punctuation.definition.preprocessor.c\" } }, \"comment\": `In addition to Haskell's \"native\" syntax, GHC permits the C preprocessor to be run on a source file.`, \"match\": \"^(#).*$\", \"name\": \"meta.preprocessor.c\" }, \"where\": { \"patterns\": [{ \"begin\": \"(?x)\\n  (?<!')\\\\b(where)\\n  \\\\s*(\\\\{)(?!-)\", \"end\": \"(\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.where.haskell\" }, \"2\": { \"name\": \"punctuation.brace.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"patterns\": [{ \"include\": \"$self\" }, { \"match\": \";\", \"name\": \"punctuation.semicolon.haskell\" }] }, { \"match\": \"\\\\b(?<!')(where)\\\\b(?!')\", \"name\": \"keyword.other.where.haskell\" }] }, \"layout_herald\": { \"begin\": \"(?x)\\n  (?<!')\\\\b(?:(where|let|m?do)|(of))\\n  \\\\s*(\\\\{)(?!-)\", \"end\": \"(\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.$1.haskell\" }, \"2\": { \"name\": \"keyword.control.of.haskell\" }, \"3\": { \"name\": \"punctuation.brace.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"patterns\": [{ \"include\": \"$self\" }, { \"match\": \";\", \"name\": \"punctuation.semicolon.haskell\" }] }, \"keyword\": { \"match\": \"\\\\b(?<!')(?:(where|let|in|default)|(m?do|if|then|else|case|of|proc|rec))\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"keyword.other.$1.haskell\" }, \"2\": { \"name\": \"keyword.control.$2.haskell\" } } }, \"deriving\": { \"patterns\": [{ \"begin\": \"^(\\\\s*)(deriving)\\\\s+(?:(via|stock|newtype|anyclass)\\\\s+)?\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.deriving.haskell\" }, \"3\": { \"name\": \"keyword.other.deriving.strategy.$3.haskell\" } }, \"end\": \"(?x) # Detect end of deriving statement\\n  # Decreasing indentation\\n   (?=\\\\}|;)      # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"match\": \"(?<!')\\\\b(instance)\\\\b(?!')\", \"name\": \"keyword.other.instance.haskell\" }, { \"match\": \"(?<!')\\\\b(via|stock|newtype|anyclass)\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"keyword.other.deriving.strategy.$1.haskell\" } } }, { \"include\": \"#type_signature\" }], \"name\": \"meta.deriving.haskell\" }, { \"begin\": \"(deriving)(?:\\\\s+(stock|newtype|anyclass))?\\\\s*(\\\\()\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.deriving.haskell\" }, \"2\": { \"name\": \"keyword.other.deriving.strategy.$2.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"(\\\\))\", \"endCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" } }, \"name\": \"meta.deriving.haskell\", \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"match\": \"(?x)\\n  (deriving)(?:\\\\s+(stock|newtype|anyclass))?\\\\s+\\n    ([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n    (\\\\s+(via)\\\\s+(.*)$)?\\n\", \"captures\": { \"1\": { \"name\": \"keyword.other.deriving.haskell\" }, \"2\": { \"name\": \"keyword.other.deriving.strategy.$2.haskell\" }, \"3\": { \"patterns\": [{ \"include\": \"#type_signature\" }] }, \"5\": { \"name\": \"keyword.other.deriving.strategy.via.haskell\" }, \"6\": { \"patterns\": [{ \"include\": \"#type_signature\" }] } }, \"name\": \"meta.deriving.haskell\" }, { \"match\": \"(?<!')\\\\b(via)\\\\b(?!')\", \"name\": \"keyword.other.deriving.strategy.via.haskell\" }] }, \"prefix_op\": { \"patterns\": [{ \"comment\": \"An operator cannot be composed entirely of '-' characters;  instead, it should be matched as a comment.\\n\", \"match\": \"(?x)\\n  (\\\\()\\\\s*(?!(?:--+|\\\\.\\\\.)\\\\))(\\\\#+|[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+(?<!\\\\#))\\\\s*(\\\\))\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"entity.name.function.infix.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" } } }] }, \"infix_op\": { \"patterns\": [{ \"match\": \"(?x)\\n  ((?:(?<!'')('')?[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'']*\\\\.)*)\\n    (\\\\#+|[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+(?<!\\\\#))\", \"comment\": \"In case this regex seems overly general, note that Haskell permits  the definition of new operators which can be nearly any string of  punctuation characters, such as $%^&*.\\n\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"entity.name.namespace.haskell\" }, \"3\": { \"name\": \"keyword.operator.infix.haskell\" } } }, { \"match\": \"(`)((?:[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'']*\\\\.)*)([\\\\p{Ll}\\\\p{Lu}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'']*)(`)\", \"captures\": { \"1\": { \"name\": \"punctuation.backtick.haskell\" }, \"2\": { \"name\": \"entity.name.namespace.haskell\" }, \"3\": { \"patterns\": [{ \"include\": \"#data_constructor\" }] }, \"4\": { \"name\": \"punctuation.backtick.haskell\" } }, \"comment\": \"In case this regex seems unusual for an infix operator, note that Haskell\\nallows any ordinary function application (elem 4 [1..10]) to be rewritten\\nas an infix expression (4 `elem` [1..10]).\\n\", \"name\": \"keyword.operator.function.infix.haskell\" }] }, \"module_exports\": { \"begin\": \"\\\\(\", \"beginCaptures\": { \"0\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"\\\\)\", \"endCaptures\": { \"0\": { \"name\": \"punctuation.paren.haskell\" } }, \"applyEndPatternLast\": 1, \"name\": \"meta.declaration.exports.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"match\": \"\\\\b(?<!')(module)\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"keyword.other.module.haskell\" } } }, { \"include\": \"#comma\" }, { \"include\": \"#export_constructs\" }, { \"begin\": \"\\\\(\", \"beginCaptures\": { \"0\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"\\\\)\", \"endCaptures\": { \"0\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#record_wildcard\" }, { \"include\": \"#export_constructs\" }, { \"include\": \"#comma\" }] }] }, \"export_constructs\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"begin\": \"\\\\b(?<!')(pattern)\\\\b(?!')\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.pattern.haskell\" } }, \"end\": \"(?x)\\n   # Data constructor\\n   ([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n   # Prefix form of symbolic constructor\\n   | (\\\\()\\\\s*(:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\\\s*(\\\\))\", \"endCaptures\": { \"1\": { \"name\": \"constant.other.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"constant.other.operator.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }] }, { \"begin\": \"\\\\b(?<!')(type)\\\\b(?!')\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.type.haskell\" } }, \"end\": \"(?x)\\n   # Type name\\n   ([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n   # Prefix form of type operator\\n   | (\\\\()\\\\s*([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\\\s*(\\\\))\", \"endCaptures\": { \"1\": { \"name\": \"storage.type.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"storage.type.operator.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }] }, { \"match\": \"(?<!')\\\\b[\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\", \"name\": \"entity.name.function.haskell\" }, { \"match\": \"(?<!')\\\\b[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\", \"name\": \"storage.type.haskell\" }, { \"include\": \"#record_wildcard\" }, { \"include\": \"#reserved_symbol\" }, { \"include\": \"#prefix_op\" }] }, \"comma\": { \"match\": \",\", \"name\": \"punctuation.separator.comma.haskell\" }, \"module_name\": { \"match\": \"(?<conid>[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*(\\\\.\\\\g<conid>)?)\", \"name\": \"entity.name.namespace.haskell\" }, \"pragma\": { \"begin\": \"\\\\{-#\", \"end\": \"#-\\\\}\", \"name\": \"meta.preprocessor.haskell\", \"patterns\": [{ \"begin\": \"(?xi) \\\\b(?<!')(LANGUAGE)\\\\b(?!')\", \"end\": \"(?=#-\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.preprocessor.pragma.haskell\" } }, \"patterns\": [{ \"match\": \"(?x)\\n  (?:No)?\\n  (?:AutoDeriveTypeable|DatatypeContexts|DoRec|IncoherentInstances|MonadFailDesugaring|MonoPatBinds|NullaryTypeClasses|OverlappingInstances|PatternSignatures|RecordPuns|RelaxedPolyRec)\", \"name\": \"invalid.deprecated\" }, { \"match\": \"(?x)\\n  (\\n  (?:No)?\\n  (?:AllowAmbiguousTypes|AlternativeLayoutRule|AlternativeLayoutRuleTransitional|Arrows|BangPatterns|BinaryLiterals|CApiFFI|CPP|CUSKs|ConstrainedClassMethods|ConstraintKinds|DataKinds|DefaultSignatures|DeriveAnyClass|DeriveDataTypeable|DeriveFoldable|DeriveFunctor|DeriveGeneric|DeriveLift|DeriveTraversable|DerivingStrategies|DerivingVia|DisambiguateRecordFields|DoAndIfThenElse|BlockArguments|DuplicateRecordFields|EmptyCase|EmptyDataDecls|EmptyDataDeriving|ExistentialQuantification|ExplicitForAll|ExplicitNamespaces|ExtendedDefaultRules|FlexibleContexts|FlexibleInstances|ForeignFunctionInterface|FunctionalDependencies|GADTSyntax|GADTs|GHCForeignImportPrim|Generali(?:s|z)edNewtypeDeriving|ImplicitParams|ImplicitPrelude|ImportQualifiedPost|ImpredicativeTypes|TypeFamilyDependencies|InstanceSigs|ApplicativeDo|InterruptibleFFI|JavaScriptFFI|KindSignatures|LambdaCase|LiberalTypeSynonyms|MagicHash|MonadComprehensions|MonoLocalBinds|MonomorphismRestriction|MultiParamTypeClasses|MultiWayIf|NumericUnderscores|NPlusKPatterns|NamedFieldPuns|NamedWildCards|NegativeLiterals|HexFloatLiterals|NondecreasingIndentation|NumDecimals|OverloadedLabels|OverloadedLists|OverloadedStrings|PackageImports|ParallelArrays|ParallelListComp|PartialTypeSignatures|PatternGuards|PatternSynonyms|PolyKinds|PolymorphicComponents|QuantifiedConstraints|PostfixOperators|QuasiQuotes|Rank2Types|RankNTypes|RebindableSyntax|RecordWildCards|RecursiveDo|RelaxedLayout|RoleAnnotations|ScopedTypeVariables|StandaloneDeriving|StarIsType|StaticPointers|Strict|StrictData|TemplateHaskell|TemplateHaskellQuotes|StandaloneKindSignatures|TraditionalRecordSyntax|TransformListComp|TupleSections|TypeApplications|TypeInType|TypeFamilies|TypeOperators|TypeSynonymInstances|UnboxedTuples|UnboxedSums|UndecidableInstances|UndecidableSuperClasses|UnicodeSyntax|UnliftedFFITypes|UnliftedNewtypes|ViewPatterns)\\n  )\", \"captures\": { \"1\": { \"name\": \"keyword.other.preprocessor.extension.haskell\" } } }, { \"include\": \"#comma\" }] }, { \"begin\": \"(?xi)\\n  \\\\b(?<!')(SPECIALI(?:S|Z)E)\\n  (?:\\n  \\\\s*( \\\\[ [^\\\\[\\\\]]* \\\\])?\\\\s*\\n  |\\\\s+\\n  )\\n  (instance)\\\\b(?!')\", \"end\": \"(?=#-\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.preprocessor.pragma.haskell\" }, \"2\": { \"patterns\": [{ \"include\": \"#inline_phase\" }] }, \"3\": { \"name\": \"keyword.other.instance.haskell\" } }, \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"begin\": \"(?xi)\\n  \\\\b(?<!')(SPECIALI(?:S|Z)E)\\\\b(?!')\\n  (?:\\\\s+(INLINE)\\\\b(?!'))?\\n  (?:\\\\s*(\\\\[ [^\\\\[\\\\]]* \\\\])?)\\n  \\\\s*\", \"end\": \"(?=#-\\\\})\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.preprocessor.pragma.haskell\" }, \"2\": { \"name\": \"keyword.other.preprocessor.pragma.haskell\" }, \"3\": { \"patterns\": [{ \"include\": \"#inline_phase\" }] } }, \"patterns\": [{ \"include\": \"$self\" }] }, { \"match\": \"(?xi) \\\\b(?<!')\\n  (LANGUAGE|OPTIONS_GHC|INCLUDE\\n  |MINIMAL|UNPACK|OVERLAPS|INCOHERENT\\n  |NOUNPACK|SOURCE|OVERLAPPING|OVERLAPPABLE|INLINE\\n  |NOINLINE|INLINE?ABLE|CONLIKE|LINE|COLUMN|RULES\\n  |COMPLETE)\\\\b(?!')\", \"name\": \"keyword.other.preprocessor.haskell\" }, { \"begin\": \"(?i)\\\\b(DEPRECATED|WARNING)\\\\b\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.preprocessor.pragma.haskell\" } }, \"end\": \"(?=#-\\\\})\", \"patterns\": [{ \"include\": \"#string_literal\" }] }] }, \"liquid_haskell\": { \"name\": \"block.liquidhaskell.haskell\", \"begin\": \"\\\\{-@\", \"end\": \"@-\\\\}\", \"patterns\": [{ \"include\": \"$self\" }] }, \"context\": { \"match\": \"(?x)\\n  (.*)\\n  (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n  (=>|\\u21D2)\\n  (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n\", \"captures\": { \"1\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#type_signature\" }] }, \"2\": { \"name\": \"keyword.operator.big-arrow.haskell\" } } }, \"data_constructor\": { \"match\": \"\\\\b(?<!')[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*(?![\\\\.'\\\\w])\", \"name\": \"constant.other.haskell\" }, \"qualifier\": { \"match\": \"\\\\b(?<!')[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\.\", \"name\": \"entity.name.namespace.haskell\" }, \"record_decl\": { \"begin\": \"({)(?!-)\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"end\": \"(?<!-)(})\", \"endCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"name\": \"meta.record.definition.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#record_decl_field\" }] }, \"record\": { \"begin\": \"({)(?!-)\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"end\": \"(?<!-)(})\", \"endCaptures\": { \"1\": { \"name\": \"punctuation.brace.haskell\" } }, \"name\": \"meta.record.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#record_field\" }] }, \"record_decl_field\": { \"begin\": \"(?x)\\n  (?:([\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n    |(\\\\()\\\\s*([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\\\s*(\\\\))\\n  )\\n\", \"end\": \"(,)|(?=})\", \"beginCaptures\": { \"1\": { \"name\": \"variable.other.member.definition.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"variable.other.member.definition.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.comma.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#comma\" }, { \"include\": \"#double_colon\" }, { \"include\": \"#type_signature\" }, { \"include\": \"#record_decl_field\" }] }, \"record_wildcard\": { \"match\": \"(?x)\\n  (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n  (\\\\.\\\\.)\\n  (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\", \"captures\": { \"1\": { \"name\": \"variable.other.member.wildcard.haskell\" } } }, \"record_field\": { \"patterns\": [{ \"begin\": \"(?x)\\n  (?:([\\\\p{Ll}\\\\p{Lu}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\.']*)\\n    |(\\\\()\\\\s*([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\\\s*(\\\\))\\n  )\\n\", \"end\": \"(,)|(?=})\", \"beginCaptures\": { \"1\": { \"name\": \"variable.other.member.haskell\", \"patterns\": [{ \"include\": \"#qualifier\" }] }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"variable.other.member.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.comma.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#comma\" }, { \"include\": \"$self\" }] }, { \"include\": \"#record_wildcard\" }] }, \"role_annotation\": { \"patterns\": [{ \"begin\": \"^(\\\\s*)(type)\\\\s+(role)\\\\b(?!')\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.type.haskell\" }, \"3\": { \"name\": \"keyword.other.role.haskell\" } }, \"end\": \"(?x) # Detect end of block by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\", \"name\": \"meta.role-annotation.haskell\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#type_constructor\" }, { \"match\": \"\\\\b(?<!')(nominal|representational|phantom)\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"keyword.other.role.$1.haskell\" } } }] }] }, \"fun_decl\": { \"begin\": \"(?x)^(\\\\s*)\\n  (?<fn>\\n    (?:\\n      [\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\#*\\n    | \\\\(\\\\s*\\n        (?!--+\\\\))\\n        [\\\\p{S}\\\\p{P}&&[^(),:;\\\\[\\\\]`{}_\\\"']]\\n        [\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]*\\n      \\\\s*\\\\)\\n    )\\n    (?:\\\\s*,\\\\s*\\\\g<fn>)?\\n  )\\n  \\\\s*(?<![\\\\p{S}\\\\p{P}&&[^\\\\),;\\\\]`}_\\\"']])(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^\\\\(,;\\\\[`{_\\\"']])\\n\", \"beginCaptures\": { \"2\": { \"name\": \"entity.name.function.haskell\", \"patterns\": [{ \"include\": \"#reserved_symbol\" }, { \"include\": \"#prefix_op\" }] }, \"3\": { \"name\": \"keyword.operator.double-colon.haskell\" } }, \"name\": \"meta.function.type-declaration.haskell\", \"patterns\": [{ \"include\": \"#type_signature\" }], \"end\": \"(?x)\\n  # End of type annotation:\\n    # To the left of a reserved symbolic keyword such as = or <-\\n  (?= \\n      # non-symbolic character\\n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n      # symbolic keyword except (->)\\n      ((<-|\\u2190)|(=)|(-<|\\u21A2)|(-<<|\\u291B))\\n      # non-symbolic character\\n      ([(),;\\\\[\\\\]`{}_\\\"']|[^\\\\p{S}\\\\p{P}])\\n  )\\n  # Decreasing indentation:\\n  |(?=\\\\}|;)      # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\" }, \"adt_constructor\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"begin\": \"(?x)\\n  (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]) # non-symbol\\n  (?:(=)|(\\\\|))\\n  (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])  # non-symbol\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.eq.haskell\" }, \"2\": { \"name\": \"keyword.operator.pipe.haskell\" } }, \"end\": \"(?x)\\n  (?:\\\\G|^)\\\\s* # Enforce starting condition to avoid catastrophic backtracking (https://github.com/JustusAdam/language-haskell/issues/161)\\n  (?: # Infix data constructor\\n    # First argument\\n    (?:\\n    # Simple type\\n      (?<!')\\\\b((?:[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'\\\\.])+)\\n    # Type inside balanced parentheses\\n    | ('? # Optional promotion tick\\n        (?<paren>\\n          \\\\(          # Opening parenthesis\\n          (?:\\n            [^\\\\(\\\\)]*  # Match non-parentheses\\n          | \\\\g<paren> # or recurse into further depth\\n          )*\\n          \\\\)          # Closing parenthesis\\n        )\\n      )\\n    # Type inside balanced brackets\\n    | ('? # Optional promotion tick\\n        (?<brac>\\n          \\\\(          # Opening bracket\\n          (?:\\n            [^\\\\[\\\\]]*  # Match non-brackets\\n          | \\\\g<brac>  # or recurse into further depth\\n          )*\\n          \\\\]          # Closing bracket\\n        )\\n      )\\n    )        \\n    # Then either\\n    \\\\s*\\n      # - a symbolic infix constructor, or\\n    (?:(?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])(:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]*)\\n      # - an alphabetic infix constructor\\n    | (`)([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)(`)\\n    )\\n\\n  ) # Otherwise, prefix data constructor, either:\\n  | # - an alphabetic data constructor e.g. \\\"Cons_123\\\"\\n    (?:(?<!')\\\\b([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*))\\n  | # - a symbolic (prefix) data constructor\\n    (\\\\()\\\\s*(:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]*)\\\\s*(\\\\))\", \"endCaptures\": { \"1\": { \"patterns\": [{ \"include\": \"#type_signature\" }] }, \"2\": { \"patterns\": [{ \"include\": \"#type_signature\" }] }, \"4\": { \"patterns\": [{ \"include\": \"#type_signature\" }] }, \"6\": { \"name\": \"constant.other.operator.haskell\" }, \"7\": { \"name\": \"punctuation.backtick.haskell\" }, \"8\": { \"name\": \"constant.other.haskell\" }, \"9\": { \"name\": \"punctuation.backtick.haskell\" }, \"10\": { \"name\": \"constant.other.haskell\" }, \"11\": { \"name\": \"punctuation.paren.haskell\" }, \"12\": { \"name\": \"constant.other.operator.haskell\" }, \"13\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#deriving\" }, { \"include\": \"#record_decl\" }, { \"include\": \"#forall\" }, { \"include\": \"#context\" }] }] }, \"gadt_constructor\": { \"patterns\": [{ \"begin\": \"(?x)\\n   ^(\\\\s*)\\n      (?:\\n        (\\\\b(?<!')[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n      |(\\\\()\\\\s*(:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]*)\\\\s*(\\\\))\\n      )\", \"beginCaptures\": { \"2\": { \"name\": \"constant.other.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" }, \"4\": { \"name\": \"constant.other.operator.haskell\" }, \"5\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"(?x)\\n  # GADT constructor ends\\n  (?=\\\\b(?<!'')deriving\\\\b(?!'))  \\n        # Decreasing indentation\\n  |(?=\\\\}|;)      # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#deriving\" }, { \"include\": \"#double_colon\" }, { \"include\": \"#record_decl\" }, { \"include\": \"#type_signature\" }] }, { \"begin\": \"(?x)\\n  (\\\\b(?<!')[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}]*) # named constructor\\n |(\\\\()\\\\s*(:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]*)\\\\s*(\\\\))    # prefix operator\", \"beginCaptures\": { \"1\": { \"name\": \"constant.other.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"constant.other.operator.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"$\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#deriving\" }, { \"include\": \"#double_colon\" }, { \"include\": \"#record_decl\" }, { \"include\": \"#type_signature\" }] }] }, \"type_application\": { \"patterns\": [{ \"begin\": `(?<=[\\\\s,;\\\\[\\\\]{}\"])(@)(')?(\\\\()`, \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.prefix.at.haskell\" }, \"2\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" } }, \"end\": \"\\\\)\", \"endCaptures\": { \"0\": { \"name\": \"punctuation.paren.haskell\" } }, \"name\": \"meta.type-application.haskell\", \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"begin\": `(?<=[\\\\s,;\\\\[\\\\]{}\"])(@)(')?(\\\\[)`, \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.prefix.at.haskell\" }, \"2\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"3\": { \"name\": \"punctuation.bracket.haskell\" } }, \"end\": \"\\\\]\", \"name\": \"meta.type-application.haskell\", \"endCaptures\": { \"0\": { \"name\": \"punctuation.bracket.haskell\" } }, \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"begin\": '(?<=[\\\\s,;\\\\[\\\\]{}\"])(@)(?=\\\\\")', \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.prefix.at.haskell\" } }, \"end\": '(?<=\\\\\")', \"name\": \"meta.type-application.haskell\", \"patterns\": [{ \"include\": \"#string_literal\" }] }, { \"begin\": `(?<=[\\\\s,;\\\\[\\\\]{}\"])(@)(?=[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'])`, \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.prefix.at.haskell\" } }, \"end\": \"(?![\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'])\", \"name\": \"meta.type-application.haskell\", \"patterns\": [{ \"include\": \"#type_signature\" }] }] }, \"type_signature\": { \"patterns\": [{ \"include\": \"#comment_like\" }, { \"match\": \"(')?(\\\\()\\\\s*(\\\\))\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" } }, \"name\": \"support.constant.unit.haskell\" }, { \"match\": \"(\\\\()(#)\\\\s*(#)(\\\\))\", \"name\": \"support.constant.unit.unboxed.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" }, \"3\": { \"name\": \"keyword.operator.hash.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(')?(\\\\()\\\\s*,[\\\\s,]*(\\\\))\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"punctuation.paren.haskell\" } }, \"name\": \"support.constant.tuple.haskell\" }, { \"match\": \"(\\\\()(#)\\\\s*(#)(\\\\))\", \"name\": \"support.constant.unit.unboxed.haskell\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" }, \"3\": { \"name\": \"keyword.operator.hash.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } } }, { \"match\": \"(\\\\()(#)\\\\s*,[\\\\s,]*(#)(\\\\))\", \"captures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" }, \"3\": { \"name\": \"keyword.operator.hash.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } }, \"name\": \"support.constant.tuple.unboxed.haskell\" }, { \"match\": \"(')?(\\\\[)\\\\s*(\\\\])\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.bracket.haskell\" }, \"3\": { \"name\": \"punctuation.bracket.haskell\" } }, \"name\": \"support.constant.empty-list.haskell\" }, { \"include\": \"#integer_literals\" }, { \"match\": \"(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\", \"name\": \"keyword.operator.double-colon.haskell\" }, { \"include\": \"#forall\" }, { \"match\": \"=>|\\u21D2\", \"name\": \"keyword.operator.big-arrow.haskell\" }, { \"include\": \"#string_literal\" }, { \"match\": \"'[^']'\", \"name\": \"invalid\" }, { \"include\": \"#type_application\" }, { \"include\": \"#reserved_symbol\" }, { \"include\": \"#type_operator\" }, { \"include\": \"#type_constructor\" }, { \"begin\": \"(\\\\()(#)\", \"end\": \"(#)(\\\\))\", \"beginCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" }, \"2\": { \"name\": \"keyword.operator.hash.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"keyword.operator.hash.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"#type_signature\" }] }, { \"begin\": \"(')?(\\\\()\", \"end\": \"(\\\\))\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.paren.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"#type_signature\" }] }, { \"begin\": \"(')?(\\\\[)\", \"end\": \"(\\\\])\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.bracket.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"punctuation.bracket.haskell\" } }, \"patterns\": [{ \"include\": \"#comma\" }, { \"include\": \"#type_signature\" }] }, { \"include\": \"#type_variable\" }] }, \"double_colon\": { \"match\": \"\\\\s*(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\\\s*\", \"captures\": { \"1\": { \"name\": \"keyword.operator.double-colon.haskell\" } } }, \"start_type_signature\": { \"patterns\": [{ \"begin\": \"^(\\\\s*)(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^\\\\(,;\\\\[`{_\\\"']])\\\\s*\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.operator.double-colon.haskell\" } }, \"end\": \"(?x)\\n  # End type annotation when seeing one of:\\n  (?=\\n    \\\\#?\\\\)                             # closing parenthesis\\n    |\\\\]                               # closing bracket\\n    |,                                # comma\\n    |(?<!')\\\\b(in|then|else|of)\\\\b(?!') # keyword\\n    |                                 # symbolic keyword except (->)\\n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n      (?:\\n         (\\\\\\\\|\\u03BB)\\n        |(<-|\\u2190)\\n        |(=)\\n        |(-<|\\u21A2)\\n        |(-<<|\\u291B)\\n      )\\n      ([(),;\\\\[\\\\]`{}_\\\"']|[^\\\\p{S}\\\\p{P}])\\n    |(\\\\#|@)-\\\\}                             # End of annotation block (LiquidHaskell or pragma)\\n    # Decreasing indentation:\\n    | (?=\\\\}|;)     # Explicit indentation\\n    |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n        \\\\1\\\\s*\\\\S    # - equally indented, or\\n      | \\\\s*        # - starts with whitespace, followed by:\\n        (?: $      #   - the end of the line (i.e. empty line), or\\n        |\\\\{-[^@]   #   - the start of a block comment, or\\n        |--+       #   - the start of a single-line comment.\\n           (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                   # The double dash may not be followed by other operator characters\\n                   # (then it would be an operator, not a comment)\\n      )\\n  )\", \"patterns\": [{ \"include\": \"#type_signature\" }], \"name\": \"meta.type-declaration.haskell\" }, { \"begin\": \"(?<![\\\\p{S}\\\\p{P}&&[^\\\\(,;\\\\[`{_\\\"']])(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^\\\\(,;\\\\[`{_\\\"']])\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.double-colon.haskell\" } }, \"end\": \"(?x)\\n  # End type annotation when seeing one of:\\n  (?=\\n    \\\\#?\\\\)                             # closing parenthesis\\n    |\\\\]                               # closing bracket\\n    |,                                # comma\\n    |\\\\b(?<!')(in|then|else|of)\\\\b(?!') # keyword\\n    |(\\\\#|@)-\\\\}                        # End of annotation block (LiquidHaskell or pragma)\\n    |                                 # symbolic keyword except (->)\\n      (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']])\\n      (?:\\n         (\\\\\\\\|\\u03BB)\\n        |(<-|\\u2190)\\n        |(=)\\n        |(-<|\\u21A2)\\n        |(-<<|\\u291B)\\n      )\\n      ([(),;\\\\[\\\\]`{}_\\\"']|[^\\\\p{S}\\\\p{P}])\\n    # Indentation \\n    |(?=\\\\}|;)      # Explicit indentation\\n    |$             # End of line\\n  )\", \"patterns\": [{ \"include\": \"#type_signature\" }] }] }, \"type_variable\": { \"match\": \"\\\\b(?<!')(?!(?:forall|deriving)\\\\b(?!'))[\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\", \"name\": \"variable.other.generic-type.haskell\" }, \"type_constructor\": { \"patterns\": [{ \"match\": \"(?x)\\n  # Optional promotion tick\\n    (')?\\n  # Optional qualified name\\n    ((?:\\\\b[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\.)*)\\n  # Type constructor proper\\n    (\\\\b[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"entity.name.namespace.haskell\" }, \"3\": { \"name\": \"storage.type.haskell\" } } }, { \"match\": \"(?x)\\n  # Optional promotion tick\\n    (')?\\n  # Opening parenthesis\\n    (\\\\()\\\\s*\\n  # Optional qualified name\\n    ((?:[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\.)*)\\n  # Type operator proper\\n    ([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\n  # Closing parenthesis\\n    \\\\s*(\\\\))\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"entity.name.namespace.haskell\" }, \"4\": { \"name\": \"storage.type.operator.haskell\" }, \"5\": { \"name\": \"punctuation.paren.haskell\" } } }] }, \"overloaded_label\": { \"patterns\": [{ \"match\": '(?x) \\n  (?<![\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\p{S}\\\\p{P}&&[^(,;\\\\[`{]]) # Disallow closing characters\\n  (\\\\#)\\n    (?:\\n    # String\\n    (\"(?:\\\\\\\\\"|[^\"])*\")\\n    # Sequence of allowed label identifiers\\n    |[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\'\\\\.]+\\n    )', \"captures\": { \"1\": { \"name\": \"keyword.operator.prefix.hash.haskell\" }, \"2\": { \"patterns\": [{ \"include\": \"#string_literal\" }] } }, \"name\": \"entity.name.label.haskell\" }] }, \"reserved_symbol\": { \"patterns\": [{ \"match\": \"(?x)\\n  (?<![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"'']])\\n  (?:\\n     (\\\\.\\\\.)\\n    |(:)\\n    |(=)\\n    |(\\\\\\\\)     # \\u03BB not reserved as it is a letter\\n    |(\\\\|)\\n    |(<-|\\u2190)\\n    |(->|\\u2192)\\n    |(-<|\\u21A2)\\n    |(-<<|\\u291B)\\n    |(>-|\\u291A)\\n    |(>>-|\\u291C)\\n    |(\\u2200)\\n  )\\n  (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"'']])\", \"captures\": { \"1\": { \"name\": \"keyword.operator.double-dot.haskell\" }, \"2\": { \"name\": \"keyword.operator.colon.haskell\" }, \"3\": { \"name\": \"keyword.operator.eq.haskell\" }, \"4\": { \"name\": \"keyword.operator.lambda.haskell\" }, \"5\": { \"name\": \"keyword.operator.pipe.haskell\" }, \"6\": { \"name\": \"keyword.operator.arrow.left.haskell\" }, \"7\": { \"name\": \"keyword.operator.arrow.haskell\" }, \"8\": { \"name\": \"keyword.operator.arrow.left.tail.haskell\" }, \"9\": { \"name\": \"keyword.operator.arrow.left.tail.double.haskell\" }, \"10\": { \"name\": \"keyword.operator.arrow.tail.haskell\" }, \"11\": { \"name\": \"keyword.operator.arrow.tail.double.haskell\" }, \"12\": { \"name\": \"keyword.other.forall.haskell\" } } }, { \"match\": \"(?x)\\n  (?<=[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\p{S}\\\\p{P}&&[^\\\\#,;\\\\[`{]]) # Require closing characters\\n  (\\\\#+)\\n  (?![\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\p{S}\\\\p{P}&&[^),;\\\\]`}]])   # Disallow opening character\", \"captures\": { \"1\": { \"name\": \"keyword.operator.postfix.hash.haskell\" } } }, { \"match\": \"(?x)\\n  (?<=[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\)\\\\}\\\\]]) # Require closing characters\\n  (@)\\n  (?=[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\(\\\\[\\\\{]) # Require opening character\", \"captures\": { \"1\": { \"name\": \"keyword.operator.infix.tight.at.haskell\" } } }, { \"match\": \"(?x)\\n  (?<![\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\p{S}\\\\p{P}&&[^(,;\\\\[`{]])  # Disallow closing characters\\n  (?:(~)|(!)|(-)|(\\\\$)|(\\\\$\\\\$))\\n  (?=[\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}\\\\(\\\\{\\\\[]) # Require opening character (non operator symbol)\", \"captures\": { \"1\": { \"name\": \"keyword.operator.prefix.tilde.haskell\" }, \"2\": { \"name\": \"keyword.operator.prefix.bang.haskell\" }, \"3\": { \"name\": \"keyword.operator.prefix.minus.haskell\" }, \"4\": { \"name\": \"keyword.operator.prefix.dollar.haskell\" }, \"5\": { \"name\": \"keyword.operator.prefix.double-dollar.haskell\" } } }] }, \"type_operator\": { \"patterns\": [{ \"match\": \"(?x)\\n  # Optional promotion tick\\n    (?:(?<!')('))?\\n  # Optional qualified name\\n    ((?:\\\\b[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\.)*)\\n  # Type operator proper\\n    (?![#@]?-})(\\\\#+|[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+(?<!\\\\#))\\n    #((?:[\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']&&[^#@]]|[@#](?!-}))+)\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"entity.name.namespace.haskell\" }, \"3\": { \"name\": \"storage.type.operator.infix.haskell\" } } }, { \"match\": \"(?x)\\n  # Optional promotion tick\\n    (')?\\n  # Opening backtick\\n    (\\\\`)\\n  # Optional qualified name\\n    ((?:[\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*\\\\.)*)\\n  # Type constructor proper\\n    ([\\\\p{Lu}\\\\p{Lt}][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\n  # Closing backtick\\n    (`)\", \"captures\": { \"1\": { \"name\": \"keyword.operator.promotion.haskell\" }, \"2\": { \"name\": \"punctuation.backtick.haskell\" }, \"3\": { \"name\": \"entity.name.namespace.haskell\" }, \"4\": { \"name\": \"storage.type.infix.haskell\" }, \"5\": { \"name\": \"punctuation.backtick.haskell\" } } }] }, \"forall\": { \"begin\": \"\\\\b(?<!')(forall|\\u2200)\\\\b(?!')\", \"end\": \"(\\\\.)|(->|\\u2192)\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.other.forall.haskell\" } }, \"endCaptures\": { \"1\": { \"name\": \"keyword.operator.period.haskell\" }, \"2\": { \"name\": \"keyword.operator.arrow.haskell\" } }, \"patterns\": [{ \"include\": \"#comment_like\" }, { \"include\": \"#type_variable\" }, { \"include\": \"#type_signature\" }] }, \"string_literal\": { \"begin\": '\"', \"beginCaptures\": { \"0\": { \"name\": \"punctuation.definition.string.begin.haskell\" } }, \"end\": '\"', \"endCaptures\": { \"0\": { \"name\": \"punctuation.definition.string.end.haskell\" } }, \"name\": \"string.quoted.double.haskell\", \"patterns\": [{ \"match\": `\\\\\\\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\\\\\\\"'\\\\&])`, \"name\": \"constant.character.escape.haskell\" }, { \"match\": \"\\\\\\\\o[0-7]+|\\\\\\\\x[0-9A-Fa-f]+|\\\\\\\\[0-9]+\", \"name\": \"constant.character.escape.octal.haskell\" }, { \"match\": \"\\\\\\\\\\\\^[A-Z@\\\\[\\\\]\\\\\\\\\\\\^_]\", \"name\": \"constant.character.escape.control.haskell\" }, { \"begin\": \"\\\\\\\\\\\\s\", \"beginCaptures\": { \"0\": { \"name\": \"constant.character.escape.begin.haskell\" } }, \"end\": \"\\\\\\\\\", \"endCaptures\": { \"0\": { \"name\": \"constant.character.escape.end.haskell\" } }, \"patterns\": [{ \"match\": \"\\\\S+\", \"name\": \"invalid.illegal.character-not-allowed-here.haskell\" }] }] }, \"char_literal\": { \"captures\": { \"1\": { \"name\": \"punctuation.definition.string.begin.haskell\" }, \"2\": { \"name\": \"constant.character.escape.haskell\" }, \"3\": { \"name\": \"constant.character.escape.octal.haskell\" }, \"4\": { \"name\": \"constant.character.escape.hexadecimal.haskell\" }, \"5\": { \"name\": \"constant.character.escape.control.haskell\" }, \"6\": { \"name\": \"punctuation.definition.string.end.haskell\" } }, \"match\": `(?x)\n  (?<![\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}'])\n  (')\n  (?:\n    [\\\\ -\\\\[\\\\]-~]                         # Basic Char\n  | (\\\\\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE\n       |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS\n       |US|SP|DEL|[abfnrtv\\\\\\\\\\\\\"'\\\\\\\\&]))   # Escapes\n  | (\\\\\\\\o[0-7]+)                         # Octal Escapes\n  | (\\\\\\\\x[0-9A-Fa-f]+)                   # Hexadecimal Escapes\n  | (\\\\\\\\\\\\^[A-Z@\\\\[\\\\]\\\\\\\\\\\\^_])                 # Control Chars\n  )\n  (')\n`, \"name\": \"string.quoted.single.haskell\" }, \"float_literals\": { \"comment\": \"Floats are decimal or hexadecimal\", \"match\": \"(?x)\\n  \\\\b(?<!')\\n  (?:  # Decimal\\n    ([0-9][_0-9]*\\\\.[0-9][_0-9]*(?:[eE][-+]?[0-9][_0-9]*)?\\n    |[0-9][_0-9]*[eE][-+]?[0-9][_0-9]*\\n    )\\n  |    # Hexadecimal\\n    (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*\\\\.[0-9a-fA-F][_0-9a-fA-F]*(?:[pP][-+]?[0-9][_0-9]*)?\\n    |0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*[pP][-+]?[0-9][_0-9]*\\n    )\\n  )\\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"constant.numeric.floating.decimal.haskell\" }, \"2\": { \"name\": \"constant.numeric.floating.hexadecimal.haskell\" } } }, \"integer_literals\": { \"match\": \"(?x)\\n  \\\\b(?<!')\\n  (?:\\n    ([0-9][_0-9]*)                    # Decimal integer\\n  | (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*) # Hexadecimal integer\\n  | (0[oO]_*[0-7][_0-7]*)             # Octal integer\\n  | (0[bB]_*[01][_01]*)               # Binary integer\\n  )\\n  \\\\b(?!')\", \"captures\": { \"1\": { \"name\": \"constant.numeric.integral.decimal.haskell\" }, \"2\": { \"name\": \"constant.numeric.integral.hexadecimal.haskell\" }, \"3\": { \"name\": \"constant.numeric.integral.octal.haskell\" }, \"4\": { \"name\": \"constant.numeric.integral.binary.haskell\" } } }, \"numeric_literals\": { \"patterns\": [{ \"include\": \"#float_literals\" }, { \"include\": \"#integer_literals\" }] }, \"ffi\": { \"begin\": \"^(\\\\s*)(foreign)\\\\s+(import|export)\\\\s+\", \"beginCaptures\": { \"2\": { \"name\": \"keyword.other.foreign.haskell\" }, \"3\": { \"name\": \"keyword.other.$3.haskell\" } }, \"name\": \"meta.$3.foreign.haskell\", \"end\": \"(?x) # Detect end of FFI block by decreasing indentation:\\n  (?=\\\\}|;)       # Explicit indentation\\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\\n      \\\\1\\\\s+\\\\S    # - more indented, or\\n    | \\\\s*        # - starts with whitespace, followed by:\\n      (?: $      #   - the end of the line (i.e. empty line), or\\n      |\\\\{-[^@]   #   - the start of a block comment, or\\n      |--+       #   - the start of a single-line comment.\\n         (?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]{}`_\\\"']]).*$) # non-symbol\\n                 # The double dash may not be followed by other operator characters\\n                 # (then it would be an operator, not a comment)\\n    )\\n\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"match\": \"\\\\b(?<!')(ccall|cplusplus|dotnet|jvm|stdcall|prim|capi)\\\\s+\", \"captures\": { \"1\": { \"name\": \"keyword.other.calling-convention.$1.haskell\" } } }, { \"begin\": `(?=\")|(?=\\\\b(?<!')([\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\\\b(?!'))`, \"end\": \"(?=(::|\\u2237)(?![\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]))\", \"patterns\": [{ \"include\": \"#comment_like\" }, { \"match\": `(?x)\n  \\\\b(?<!')(safe|unsafe|interruptible)\\\\b(?!')\n  \\\\s*\n  (\"(?:\\\\\\\\\"|[^\"])*\")?\n  \\\\s*\n  (?:\n    (?:\\\\b(?<!'')([\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\\\b(?!'))\n   |(?:\\\\(\\\\s*(?!--+\\\\))([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]\\`{}_\"']]+)\\\\s*\\\\))\n  )\n`, \"captures\": { \"1\": { \"name\": \"keyword.other.safety.$1.haskell\" }, \"2\": { \"name\": \"entity.name.foreign.haskell\", \"patterns\": [{ \"include\": \"#string_literal\" }] }, \"3\": { \"name\": \"entity.name.function.haskell\" }, \"4\": { \"name\": \"entity.name.function.infix.haskell\" } } }, { \"match\": `(?x)\n  \\\\b(?<!')(safe|unsafe|interruptible)\\\\b(?!')\n  \\\\s*\n  (\"(?:\\\\\\\\\"|[^\"])*\")?\n  \\\\s*$\n`, \"captures\": { \"1\": { \"name\": \"keyword.other.safety.$1.haskell\" }, \"2\": { \"name\": \"entity.name.foreign.haskell\", \"patterns\": [{ \"include\": \"#string_literal\" }] } } }, { \"match\": '(?x)\\n  \"(?:\\\\\\\\\"|[^\"])*\"', \"captures\": { \"0\": { \"name\": \"entity.name.foreign.haskell\", \"patterns\": [{ \"include\": \"#string_literal\" }] } } }, { \"match\": \"(?x)\\n   (?:\\\\b(?<!'')([\\\\p{Ll}_][\\\\p{Ll}_\\\\p{Lu}\\\\p{Lt}\\\\p{Nd}']*)\\\\b(?!'))\\n  |(?:(\\\\()\\\\s*(?!--+\\\\))([\\\\p{S}\\\\p{P}&&[^(),;\\\\[\\\\]`{}_\\\"']]+)\\\\s*(\\\\)))\\n\", \"captures\": { \"1\": { \"name\": \"entity.name.function.haskell\" }, \"2\": { \"name\": \"punctuation.paren.haskell\" }, \"3\": { \"name\": \"entity.name.function.infix.haskell\" }, \"4\": { \"name\": \"punctuation.paren.haskell\" } } }] }, { \"include\": \"#double_colon\" }, { \"include\": \"#type_signature\" }] }, \"inline_phase\": { \"begin\": \"\\\\[\", \"beginCaptures\": { \"0\": { \"name\": \"punctuation.bracket.haskell\" } }, \"end\": \"\\\\]\", \"endCaptures\": { \"0\": { \"name\": \"punctuation.bracket.haskell\" } }, \"name\": \"meta.inlining-phase.haskell\", \"patterns\": [{ \"match\": \"~\", \"name\": \"punctuation.tilde.haskell\" }, { \"include\": \"#integer_literals\" }, { \"match\": \"\\\\w*\", \"name\": \"invalid\" }] }, \"quasi_quote\": { \"patterns\": [{ \"begin\": \"(?x)\\n  (\\\\[)\\n  (e|d|p)?\\n  (\\\\|\\\\|?)\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" }, \"2\": { \"name\": \"entity.name.quasi-quoter.haskell\" }, \"3\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" } }, \"end\": \"\\\\3\\\\]\", \"endCaptures\": { \"0\": { \"name\": \"keyword.operator.quasi-quotation.end.haskell\" } }, \"name\": \"meta.quasi-quotation.haskell\", \"patterns\": [{ \"include\": \"$self\" }] }, { \"begin\": \"(?x)\\n  (\\\\[)\\n  (t)\\n  (\\\\|\\\\|?)\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" }, \"2\": { \"name\": \"entity.name.quasi-quoter.haskell\" }, \"3\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" } }, \"end\": \"\\\\3\\\\]\", \"endCaptures\": { \"0\": { \"name\": \"keyword.operator.quasi-quotation.end.haskell\" } }, \"name\": \"meta.quasi-quotation.haskell\", \"patterns\": [{ \"include\": \"#type_signature\" }] }, { \"begin\": \"(?x)\\n  (\\\\[)\\n  (?:(\\\\$\\\\$)|(\\\\$))?\\n  ((?:[^\\\\s\\\\p{S}\\\\p{P}]|[\\\\.'_])*)\\n  (\\\\|\\\\|?)\", \"beginCaptures\": { \"1\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" }, \"2\": { \"name\": \"keyword.operator.prefix.double-dollar.haskell\" }, \"3\": { \"name\": \"keyword.operator.prefix.dollar.haskell\" }, \"4\": { \"patterns\": [{ \"include\": \"#qualifier\" }], \"name\": \"entity.name.quasi-quoter.haskell\" }, \"5\": { \"name\": \"keyword.operator.quasi-quotation.begin.haskell\" } }, \"end\": \"\\\\5\\\\]\", \"endCaptures\": { \"0\": { \"name\": \"keyword.operator.quasi-quotation.end.haskell\" } }, \"name\": \"meta.quasi-quotation.haskell\" }] } }, \"scopeName\": \"source.haskell\", \"uuid\": \"5C034675-1F6D-497E-8073-369D37E2FD7D\", \"displayName\": \"Haskell\", \"aliases\": [\"hs\"] });\nvar haskell = [\n  lang\n];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaGlraWppL2Rpc3QvbGFuZ3MvaGFza2VsbC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUE2QixrR0FBa0csOEJBQThCLElBQUksNEJBQTRCLElBQUksZ0NBQWdDLElBQUksOEJBQThCLElBQUksNEJBQTRCLElBQUksc0JBQXNCLHNCQUFzQixJQUFJLG1GQUFtRixPQUFPLHFDQUFxQyxTQUFTLHlDQUF5QyxJQUFJLGlHQUFpRyxPQUFPLHFDQUFxQyxTQUFTLHlDQUF5QyxTQUFTLHlDQUF5QyxTQUFTLHlDQUF5QyxJQUFJLDJGQUEyRixPQUFPLHFDQUFxQyxTQUFTLHlDQUF5QyxJQUFJLHlHQUF5RyxPQUFPLHFDQUFxQyxTQUFTLHlDQUF5QyxTQUFTLHlDQUF5QyxTQUFTLHlDQUF5QyxJQUFJLHlGQUF5RixPQUFPLHVDQUF1QyxTQUFTLDJDQUEyQyxJQUFJLDBFQUEwRSxPQUFPLHdDQUF3QyxTQUFTLDZDQUE2QyxpR0FBaUcsNEJBQTRCLElBQUksMkJBQTJCLElBQUksOEJBQThCLElBQUksc0NBQXNDLEdBQUcsSUFBSSxtQkFBbUIsSUFBSSx3REFBd0QsT0FBTyx5Q0FBeUMsNkpBQTZKLEVBQUUsdVRBQXVULCtIQUErSCxFQUFFLElBQUksRUFBRSxRQUFRLFFBQVEsc1BBQXNQLDRCQUE0QixJQUFJLHFCQUFxQixJQUFJLDhCQUE4QixHQUFHLElBQUk7QUFDNTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUUsSUFBSSxFQUFFLFFBQVEsVUFBVTtBQUN6QztBQUNBLGNBQWMsRUFBRSxJQUFJLEVBQUUsUUFBUSxVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxvQ0FBb0MsU0FBUywwQ0FBMEMsU0FBUyxlQUFlLDhCQUE4QixLQUFLLGtOQUFrTixFQUFFLHVUQUF1VCwrSEFBK0gsRUFBRSxJQUFJLEVBQUUsUUFBUSxR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MEQsU0FBUyx5REFBeUQsU0FBUyxrREFBa0QsU0FBUyxlQUFlLHlCQUF5QiwrQ0FBK0MsU0FBUyw0REFBNEQsb0NBQW9DLE9BQU8sMERBQTBELDBDQUEwQyxLQUFLLDhIQUE4SDtBQUNod0Y7QUFDQTtBQUNBOztBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2hpa2lqaS9kaXN0L2xhbmdzL2hhc2tlbGwubWpzPzM4ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbGFuZyA9IE9iamVjdC5mcmVlemUoeyBcImZpbGVUeXBlc1wiOiBbXCJoc1wiLCBcImhzLWJvb3RcIiwgXCJoc2lnXCJdLCBcImtleUVxdWl2YWxlbnRcIjogXCJefkhcIiwgXCJuYW1lXCI6IFwiaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNsaXF1aWRfaGFza2VsbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI251bWVyaWNfbGl0ZXJhbHNcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNzdHJpbmdfbGl0ZXJhbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2NoYXJfbGl0ZXJhbFwiIH0sIHsgXCJtYXRjaFwiOiBcIig/PCFAfCMpLVxcXFx9XCIsIFwibmFtZVwiOiBcImludmFsaWRcIiB9LCB7IFwibWF0Y2hcIjogXCIoXFxcXCgpXFxcXHMqKFxcXFwpKVwiLCBcIm5hbWVcIjogXCJjb25zdGFudC5sYW5ndWFnZS51bml0Lmhhc2tlbGxcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9IH0sIHsgXCJtYXRjaFwiOiBcIihcXFxcKCkoIylcXFxccyooIykoXFxcXCkpXCIsIFwibmFtZVwiOiBcImNvbnN0YW50Lmxhbmd1YWdlLnVuaXQudW5ib3hlZC5oYXNrZWxsXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmhhc2guaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0gfSwgeyBcIm1hdGNoXCI6IFwiKFxcXFwoKVxcXFxzKixbXFxcXHMsXSooXFxcXCkpXCIsIFwibmFtZVwiOiBcInN1cHBvcnQuY29uc3RhbnQudHVwbGUuaGFza2VsbFwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0gfSwgeyBcIm1hdGNoXCI6IFwiKFxcXFwoKSgjKVxcXFxzKixbXFxcXHMsXSooIykoXFxcXCkpXCIsIFwibmFtZVwiOiBcInN1cHBvcnQuY29uc3RhbnQudHVwbGUudW5ib3hlZC5oYXNrZWxsXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmhhc2guaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0gfSwgeyBcIm1hdGNoXCI6IFwiKFxcXFxbKVxcXFxzKihcXFxcXSlcIiwgXCJuYW1lXCI6IFwiY29uc3RhbnQubGFuZ3VhZ2UuZW1wdHktbGlzdC5oYXNrZWxsXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9IH0gfSwgeyBcImJlZ2luXCI6IFwiKFxcXFxiKD88IScpKG1vZHVsZSl8XihzaWduYXR1cmUpKShcXFxcYig/IScpKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLm1vZHVsZS5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5zaWduYXR1cmUuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoPz1cXFxcYig/PCEnKXdoZXJlXFxcXGIoPyEnKSlcIiwgXCJuYW1lXCI6IFwibWV0YS5kZWNsYXJhdGlvbi5tb2R1bGUuaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNtb2R1bGVfbmFtZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI21vZHVsZV9leHBvcnRzXCIgfSwgeyBcIm1hdGNoXCI6IFwiW2Etel0rXCIsIFwibmFtZVwiOiBcImludmFsaWRcIiB9XSB9LCB7IFwiaW5jbHVkZVwiOiBcIiNmZmlcIiB9LCB7IFwiYmVnaW5cIjogXCJeKFxcXFxzKikoY2xhc3MpKFxcXFxiKD8hJykpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuY2xhc3MuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBjbGFzcyBkZWNsYXJhdGlvbjpcXG4gICAgICAgICAjICd3aGVyZScga2V5d29yZFxcbiAgICg/PSg/PCEnKVxcXFxid2hlcmVcXFxcYig/IScpKSAgXFxuICAgICAgICAgIyBEZWNyZWFzaW5nIGluZGVudGF0aW9uXFxuICAgfCg/PVxcXFx9fDspICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgIHxeKD8hICAgICAgICAgICMgSW1wbGljaXQgaW5kZW50YXRpb246IGVuZCBtYXRjaCBvbiBuZXdsaW5lICp1bmxlc3MqIHRoZSBuZXcgbGluZSBpcyBlaXRoZXI6XFxuICAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICAoPzogJCAgICAgICMgICAtIHRoZSBlbmQgb2YgdGhlIGxpbmUgKGkuZS4gZW1wdHkgbGluZSksIG9yXFxuICAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICAoPyFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXXt9YF9cXFwiJ11dKS4qJCkgIyBub24tc3ltYm9sXFxuICAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgIClcIiwgXCJuYW1lXCI6IFwibWV0YS5kZWNsYXJhdGlvbi5jbGFzcy5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3doZXJlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogYCg/eClcbiAgXihcXFxccyopKGRhdGF8bmV3dHlwZSkoPzpcXFxccysoaW5zdGFuY2UpKT9cXFxccytcbiAgIyBLZWVwIGNvbnN1bWluZyBjaGFyYWN0ZXJzIHVudGlsOlxuICAoKD86KD8hXG4gICMgdGhlIGVxdWFscyBzeW1ib2wgb3IgdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudCwgb3JcbiAgICAoPzogXG4gICAgICAoPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1cXGB7fV9cIiddXSkgIyBub24tc3ltYm9sXG4gICAgICAoPzo9fC0tKylcbiAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdXFxge31fXCInXV0pICAjIG5vbi1zeW1ib2xcbiAgICApXG4gICMgdGhlIFwid2hlcmVcIiBvciBcImRlcml2aW5nXCIga2V5d29yZHMsIG9yXG4gIHwgKD86XFxcXGIoPzwhJykoPzp3aGVyZXxkZXJpdmluZylcXFxcYig/IScpKVxuICAjIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQuXG4gIHwgey1cbiAgI1xuICApLikqKVxuICAoPz1cXFxcYig/PCEnJyl3aGVyZVxcXFxiKD8hJycpKWAsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuJDIuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuaW5zdGFuY2UuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSB9LCBcIm5hbWVcIjogXCJtZXRhLmRlY2xhcmF0aW9uLiQyLmdlbmVyYWxpemVkLmhhc2tlbGxcIiwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBkYXRhIGRlY2xhcmF0aW9uOlxcbiAgICAgICAgICMgRGVyaXZpbmcgY2xhdXNlXFxuICAgKD89KD88IScpXFxcXGJkZXJpdmluZ1xcXFxiKD8hJykpICBcXG4gICAgICAgICAjIERlY3JlYXNpbmcgaW5kZW50YXRpb25cXG4gICB8KD89XFxcXH18OykgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICAgXFxcXDFcXFxccytcXFxcUyAgICAjIC0gbW9yZSBpbmRlbnRlZCwgb3JcXG4gICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICAgfFxcXFx7LVteQF0gICAjICAgLSB0aGUgc3RhcnQgb2YgYSBibG9jayBjb21tZW50LCBvclxcbiAgICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICAjIFRoZSBkb3VibGUgZGFzaCBtYXkgbm90IGJlIGZvbGxvd2VkIGJ5IG90aGVyIG9wZXJhdG9yIGNoYXJhY3RlcnNcXG4gICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICAgKVxcblwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiYmVnaW5cIjogXCIoP3gpXFxuICAoPzwhJylcXFxcYih3aGVyZSlcXG4gIFxcXFxzKihcXFxceykoPyEtKVwiLCBcImVuZFwiOiBcIihcXFxcfSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci53aGVyZS5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYnJhY2UuaGFza2VsbFwiIH0gfSwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNlLmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2dhZHRfY29uc3RydWN0b3JcIiB9LCB7IFwibWF0Y2hcIjogXCI7XCIsIFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnNlbWljb2xvbi5oYXNrZWxsXCIgfV0gfSwgeyBcIm1hdGNoXCI6IFwiXFxcXGIoPzwhJykod2hlcmUpXFxcXGIoPyEnKVwiLCBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLndoZXJlLmhhc2tlbGxcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNkZXJpdmluZ1wiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2dhZHRfY29uc3RydWN0b3JcIiB9XSB9LCB7IFwiaW5jbHVkZVwiOiBcIiNyb2xlX2Fubm90YXRpb25cIiB9LCB7IFwibmFtZVwiOiBcIm1ldGEuZGVjbGFyYXRpb24ucGF0dGVybi50eXBlLmhhc2tlbGxcIiwgXCJiZWdpblwiOiBcIl4oXFxcXHMqKShwYXR0ZXJuKVxcXFxzKyguKj8pXFxcXHMrKDo6fFxcdTIyMzcpKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5wYXR0ZXJuLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tYVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2RhdGFfY29uc3RydWN0b3JcIiB9XSB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmRvdWJsZS1jb2xvbi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/eCkgIyBEZXRlY3QgZW5kIG9mIHBhdHRlcm4gdHlwZSBkZWZpbml0aW9uIGJ5IGRlY3JlYXNpbmcgaW5kZW50YXRpb246XFxuICAoPz1cXFxcfXw7KSAgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICApXFxuXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgeyBcIm5hbWVcIjogXCJtZXRhLmRlY2xhcmF0aW9uLnBhdHRlcm4uaGFza2VsbFwiLCBcImJlZ2luXCI6IFwiXlxcXFxzKihwYXR0ZXJuKVxcXFxiKD8hJylcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIucGF0dGVybi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/eCkgIyBEZXRlY3QgZW5kIG9mIHBhdHRlcm4gdHlwZSBkZWZpbml0aW9uIGJ5IGRlY3JlYXNpbmcgaW5kZW50YXRpb246XFxuICAoPz1cXFxcfXw7KSAgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICApXFxuXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiJHNlbGZcIiB9XSB9LCB7IFwiYmVnaW5cIjogYCg/eClcbiAgIyBEYXRhIGRlY2xhcmF0aW9uXG4gIF4oXFxcXHMqKShkYXRhfG5ld3R5cGUpKD86XFxcXHMrKGZhbWlseXxpbnN0YW5jZSkpP1xcXFxzK1xuICAjIEtlZXAgY29uc3VtaW5nIGNoYXJhY3RlcnMgdW50aWw6XG4gICgoKD8hXG4gICMgdGhlIGVxdWFscyBzeW1ib2wgb3IgdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudCwgb3JcbiAgICAoPzogXG4gICAgICAoPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1cXGB7fV9cIiddXSkgIyBub24tc3ltYm9sXG4gICAgICAoPzo9fC0tKylcbiAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdXFxge31fXCInXV0pICAjIG5vbi1zeW1ib2xcbiAgICApXG4gICMgdGhlIFwid2hlcmVcIiBvciBcImRlcml2aW5nXCIga2V5d29yZHMsIG9yXG4gIHwgKD86XFxcXGIoPzwhJykoPzp3aGVyZXxkZXJpdmluZylcXFxcYig/IScpKVxuICAjIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQuXG4gIHwgey1cbiAgI1xuICApLikqKWAsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuJDIuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuJDMuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSB9LCBcIm5hbWVcIjogXCJtZXRhLmRlY2xhcmF0aW9uLiQyLmFsZ2VicmFpYy5oYXNrZWxsXCIsIFwiZW5kXCI6IFwiKD94KSAjIERldGVjdCBlbmQgb2YgZGF0YSBkZWNsYXJhdGlvbjogXFxuICAgICAjIERlY3JlYXNpbmcgaW5kZW50YXRpb25cXG4gICAoPz1cXFxcfXw7KSAgICAgICMgRXhwbGljaXQgaW5kZW50YXRpb25cXG4gICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICAgfCBcXFxccyogICAgICAgICMgLSBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBmb2xsb3dlZCBieTpcXG4gICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgIHwtLSsgICAgICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudC5cXG4gICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgICMgKHRoZW4gaXQgd291bGQgYmUgYW4gb3BlcmF0b3IsIG5vdCBhIGNvbW1lbnQpXFxuICAgICApXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2Rlcml2aW5nXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjZm9yYWxsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjYWR0X2NvbnN0cnVjdG9yXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjY29udGV4dFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3JlY29yZF9kZWNsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwibmFtZVwiOiBcIm1ldGEuZGVjbGFyYXRpb24udHlwZS5mYW1pbHkuaGFza2VsbFwiLCBcImJlZ2luXCI6IGAoP3gpXG4gICMgVHlwZSBmYW1pbHlcbiAgXihcXFxccyopKHR5cGUpXFxcXHMrKGZhbWlseSlcXFxcYig/IScpXG4gICMgS2VlcCBjb25zdW1pbmcgY2hhcmFjdGVycyB1bnRpbDpcbiAgKCgoPyFcbiAgIyB0aGUgZXF1YWxzIHN5bWJvbCBvciB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LCBvclxuICAgICg/OiBcbiAgICAgICg/PCFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXVxcYHt9X1wiJ11dKSAjIG5vbi1zeW1ib2xcbiAgICAgICg/Oj18LS0rKVxuICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1cXGB7fV9cIiddXSkgICMgbm9uLXN5bWJvbFxuICAgIClcbiAgIyB0aGUgXCJ3aGVyZVwiIGtleXdvcmQsIG9yXG4gIHwgXFxcXGIoPzwhJyl3aGVyZVxcXFxiKD8hJylcbiAgIyB0aGUgc3RhcnQgb2YgYSBibG9jayBjb21tZW50LlxuICB8IHstXG4gICNcbiAgKS4pKilgLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnR5cGUuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZmFtaWx5Lmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiN3aGVyZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSB9LCBcImVuZFwiOiBcIig/eCkgIyBEZXRlY3QgZW5kIG9mIHR5cGUgZmFtaWx5IGJ5IGRlY3JlYXNpbmcgaW5kZW50YXRpb246XFxuICAoPz1cXFxcfXw7KSAgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICApXFxuXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3doZXJlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwibmFtZVwiOiBcIm1ldGEuZGVjbGFyYXRpb24udHlwZS5oYXNrZWxsXCIsIFwiYmVnaW5cIjogXCIoP3gpXFxuICAjIFR5cGUgZGVjbGFyYXRpb25cXG4gIF4oXFxcXHMqKSh0eXBlKSg/OlxcXFxzKyhpbnN0YW5jZSkpP1xcXFxzK1xcbiAgIyBLZWVwIGNvbnN1bWluZyBjaGFyYWN0ZXJzIHVudGlsOlxcbiAgKCgoPyFcXG4gICMgdGhlIGVxdWFscyBzeW1ib2wsIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQsIG9yIGEgdHlwZSBzaWduYXR1cmVcXG4gICAgKD86IFxcbiAgICAgICg/PCFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKSAjIG5vbi1zeW1ib2xcXG4gICAgICAoPzo9fC0tK3w6OnxcXHUyMjM3KVxcbiAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0pICAjIG5vbi1zeW1ib2xcXG4gICAgKVxcbiAgIyB0aGUgc3RhcnQgb2YgYSBibG9jayBjb21tZW50LlxcbiAgfCB7LVxcbiAgI1xcbiAgKS4pKilcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci50eXBlLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLmluc3RhbmNlLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiB0eXBlIGRlZmluaXRpb24gYnkgZGVjcmVhc2luZyBpbmRlbnRhdGlvbjpcXG4gICg/PVxcXFx9fDspICAgICAgICMgRXhwbGljaXQgaW5kZW50YXRpb25cXG4gIHxeKD8hICAgICAgICAgICMgSW1wbGljaXQgaW5kZW50YXRpb246IGVuZCBtYXRjaCBvbiBuZXdsaW5lICp1bmxlc3MqIHRoZSBuZXcgbGluZSBpcyBlaXRoZXI6XFxuICAgICAgXFxcXDFcXFxccytcXFxcUyAgICAjIC0gbW9yZSBpbmRlbnRlZCwgb3JcXG4gICAgfCBcXFxccyogICAgICAgICMgLSBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBmb2xsb3dlZCBieTpcXG4gICAgICAoPzogJCAgICAgICMgICAtIHRoZSBlbmQgb2YgdGhlIGxpbmUgKGkuZS4gZW1wdHkgbGluZSksIG9yXFxuICAgICAgfFxcXFx7LVteQF0gICAjICAgLSB0aGUgc3RhcnQgb2YgYSBibG9jayBjb21tZW50LCBvclxcbiAgICAgIHwtLSsgICAgICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudC5cXG4gICAgICAgICAoPyFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXXt9YF9cXFwiJ11dKS4qJCkgIyBub24tc3ltYm9sXFxuICAgICAgICAgICAgICAgICAjIFRoZSBkb3VibGUgZGFzaCBtYXkgbm90IGJlIGZvbGxvd2VkIGJ5IG90aGVyIG9wZXJhdG9yIGNoYXJhY3RlcnNcXG4gICAgICAgICAgICAgICAgICMgKHRoZW4gaXQgd291bGQgYmUgYW4gb3BlcmF0b3IsIG5vdCBhIGNvbW1lbnQpXFxuICAgIClcXG5cIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCJeKFxcXFxzKikoaW5zdGFuY2UpKFxcXFxiKD8hJykpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuaW5zdGFuY2UuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBpbnN0YW5jZSBkZWNsYXJhdGlvbjpcXG4gICMgJ3doZXJlJyBrZXl3b3JkXFxuICAoPz1cXFxcYig/PCEnKSh3aGVyZSlcXFxcYig/IScpKVxcbiAgIyBEZWNyZWFzaW5nIGluZGVudGF0aW9uXFxuICB8KD89XFxcXH18OykgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICApXFxuXCIsIFwibmFtZVwiOiBcIm1ldGEuZGVjbGFyYXRpb24uaW5zdGFuY2UuaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiN3aGVyZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgeyBcImJlZ2luXCI6IFwiXihcXFxccyopKGltcG9ydCkoXFxcXGIoPyEnKSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5pbXBvcnQuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBpbXBvcnRcXG4gICMgJ3doZXJlJyBrZXl3b3JkXFxuICAoPz1cXFxcYig/PCEnKSh3aGVyZSlcXFxcYig/IScpKVxcbiAgIyBEZWNyZWFzaW5nIGluZGVudGF0aW9uXFxuICB8KD89XFxcXH18OykgICAgICAjIEV4cGxpY2l0IGluZGVudGF0aW9uXFxuICB8Xig/ISAgICAgICAgICAjIEltcGxpY2l0IGluZGVudGF0aW9uOiBlbmQgbWF0Y2ggb24gbmV3bGluZSAqdW5sZXNzKiB0aGUgbmV3IGxpbmUgaXMgZWl0aGVyOlxcbiAgICAgIFxcXFwxXFxcXHMrXFxcXFMgICAgIyAtIG1vcmUgaW5kZW50ZWQsIG9yXFxuICAgIHwgXFxcXHMqICAgICAgICAjIC0gc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgZm9sbG93ZWQgYnk6XFxuICAgICAgKD86ICQgICAgICAjICAgLSB0aGUgZW5kIG9mIHRoZSBsaW5lIChpLmUuIGVtcHR5IGxpbmUpLCBvclxcbiAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICB8LS0rICAgICAgICMgICAtIHRoZSBzdGFydCBvZiBhIHNpbmdsZS1saW5lIGNvbW1lbnQuXFxuICAgICAgICAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF17fWBfXFxcIiddXSkuKiQpICMgbm9uLXN5bWJvbFxcbiAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAjICh0aGVuIGl0IHdvdWxkIGJlIGFuIG9wZXJhdG9yLCBub3QgYSBjb21tZW50KVxcbiAgICApXFxuXCIsIFwibmFtZVwiOiBcIm1ldGEuaW1wb3J0Lmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjd2hlcmVcIiB9LCB7IFwibWF0Y2hcIjogXCIocXVhbGlmaWVkfGFzfGhpZGluZylcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuJDEuaGFza2VsbFwiIH0gfSB9LCB7IFwiaW5jbHVkZVwiOiBcIiNtb2R1bGVfbmFtZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI21vZHVsZV9leHBvcnRzXCIgfV0gfSwgeyBcImluY2x1ZGVcIjogXCIjZGVyaXZpbmdcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNsYXlvdXRfaGVyYWxkXCIgfSwgeyBcImluY2x1ZGVcIjogXCIja2V5d29yZFwiIH0sIHsgXCJtYXRjaFwiOiBcIl5cXFxccyooaW5maXhbbHJdPylcXFxccysoLiopXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLiQxLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNpbnRlZ2VyX2xpdGVyYWxzXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjaW5maXhfb3BcIiB9XSB9IH0sIFwibmFtZVwiOiBcIm1ldGEuZml4aXR5LWRlY2xhcmF0aW9uLmhhc2tlbGxcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNvdmVybG9hZGVkX2xhYmVsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9hcHBsaWNhdGlvblwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3Jlc2VydmVkX3N5bWJvbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2Z1bl9kZWNsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcXVhbGlmaWVyXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjZGF0YV9jb25zdHJ1Y3RvclwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3N0YXJ0X3R5cGVfc2lnbmF0dXJlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcHJlZml4X29wXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjaW5maXhfb3BcIiB9LCB7IFwiYmVnaW5cIjogXCIoXFxcXCgpKCMpXFxcXHNcIiwgXCJlbmRcIjogXCIoIykoXFxcXCkpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmhhc2guaGFza2VsbFwiIH0gfSwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuaGFzaC5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWFcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiRzZWxmXCIgfV0gfSwgeyBcImJlZ2luXCI6IFwiKFxcXFwoKVwiLCBcImVuZFwiOiBcIihcXFxcKSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1hXCIgfSwgeyBcImluY2x1ZGVcIjogXCIkc2VsZlwiIH1dIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3F1YXNpX3F1b3RlXCIgfSwgeyBcImJlZ2luXCI6IFwiKFxcXFxbKVwiLCBcImVuZFwiOiBcIihcXFxcXSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYnJhY2tldC5oYXNrZWxsXCIgfSB9LCBcImVuZENhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYnJhY2tldC5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tYVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiJHNlbGZcIiB9XSB9LCB7IFwiaW5jbHVkZVwiOiBcIiNyZWNvcmRcIiB9XSwgXCJyZXBvc2l0b3J5XCI6IHsgXCJibG9ja19jb21tZW50XCI6IHsgXCJhcHBseUVuZFBhdHRlcm5MYXN0XCI6IDEsIFwiYmVnaW5cIjogXCJcXFxcey1cIiwgXCJjYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY29tbWVudC5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIi1cXFxcfVwiLCBcIm5hbWVcIjogXCJjb21tZW50LmJsb2NrLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjYmxvY2tfY29tbWVudFwiIH1dIH0sIFwiY29tbWVudHNcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiYmVnaW5cIjogXCJeKFxcXFxzKikoLS1cXFxcc1tcXFxcfFxcXFwkXSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ud2hpdGVzcGFjZS5jb21tZW50LmxlYWRpbmcuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoPz1eKD8hXFxcXDEtLSsoPyFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKSkpXCIsIFwibmFtZVwiOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbi5oYXNrZWxsXCIgfSwgeyBcImJlZ2luXCI6IFwiKF5bIFxcXFx0XSspPygtLVxcXFxzW1xcXFxeXFxcXCpdKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi53aGl0ZXNwYWNlLmNvbW1lbnQubGVhZGluZy5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIlxcXFxuXCIsIFwibmFtZVwiOiBcImNvbW1lbnQubGluZS5kb2N1bWVudGF0aW9uLmhhc2tlbGxcIiB9LCB7IFwiYXBwbHlFbmRQYXR0ZXJuTGFzdFwiOiAxLCBcImJlZ2luXCI6IFwiXFxcXHstXFxcXHM/W1xcXFx8XFxcXCRcXFxcKlxcXFxeXVwiLCBcImNhcHR1cmVzXCI6IHsgXCIwXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5jb21tZW50Lmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiLVxcXFx9XCIsIFwibmFtZVwiOiBcImNvbW1lbnQuYmxvY2suZG9jdW1lbnRhdGlvbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2Jsb2NrX2NvbW1lbnRcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCIoXlsgXFxcXHRdKyk/KD89LS0rKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSkpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLndoaXRlc3BhY2UuY29tbWVudC5sZWFkaW5nLmhhc2tlbGxcIiB9IH0sIFwiY29tbWVudFwiOiBcIk9wZXJhdG9ycyBtYXkgYmVnaW4gd2l0aCAnLS0nIGFzIGxvbmcgYXMgdGhleSBhcmUgbm90IGVudGlyZWx5IGNvbXBvc2VkIG9mICctJyBjaGFyYWN0ZXJzLiBUaGlzIG1lYW5zIGNvbW1lbnRzIGNhbid0IGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIGFsbG93YWJsZSBvcGVyYXRvciBjaGFyYWN0ZXIuXCIsIFwiZW5kXCI6IFwiKD8hXFxcXEcpXCIsIFwicGF0dGVybnNcIjogW3sgXCJiZWdpblwiOiBcIi0tXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY29tbWVudC5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIlxcXFxuXCIsIFwibmFtZVwiOiBcImNvbW1lbnQubGluZS5kb3VibGUtZGFzaC5oYXNrZWxsXCIgfV0gfSwgeyBcImluY2x1ZGVcIjogXCIjYmxvY2tfY29tbWVudFwiIH1dIH0sIFwiY29tbWVudF9saWtlXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY3BwXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcHJhZ21hXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjY29tbWVudHNcIiB9XSB9LCBcImNwcFwiOiB7IFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnByZXByb2Nlc3Nvci5jXCIgfSB9LCBcImNvbW1lbnRcIjogYEluIGFkZGl0aW9uIHRvIEhhc2tlbGwncyBcIm5hdGl2ZVwiIHN5bnRheCwgR0hDIHBlcm1pdHMgdGhlIEMgcHJlcHJvY2Vzc29yIHRvIGJlIHJ1biBvbiBhIHNvdXJjZSBmaWxlLmAsIFwibWF0Y2hcIjogXCJeKCMpLiokXCIsIFwibmFtZVwiOiBcIm1ldGEucHJlcHJvY2Vzc29yLmNcIiB9LCBcIndoZXJlXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImJlZ2luXCI6IFwiKD94KVxcbiAgKD88IScpXFxcXGIod2hlcmUpXFxuICBcXFxccyooXFxcXHspKD8hLSlcIiwgXCJlbmRcIjogXCIoXFxcXH0pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIud2hlcmUuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNlLmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFjZS5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiRzZWxmXCIgfSwgeyBcIm1hdGNoXCI6IFwiO1wiLCBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5zZW1pY29sb24uaGFza2VsbFwiIH1dIH0sIHsgXCJtYXRjaFwiOiBcIlxcXFxiKD88IScpKHdoZXJlKVxcXFxiKD8hJylcIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci53aGVyZS5oYXNrZWxsXCIgfV0gfSwgXCJsYXlvdXRfaGVyYWxkXCI6IHsgXCJiZWdpblwiOiBcIig/eClcXG4gICg/PCEnKVxcXFxiKD86KHdoZXJlfGxldHxtP2RvKXwob2YpKVxcbiAgXFxcXHMqKFxcXFx7KSg/IS0pXCIsIFwiZW5kXCI6IFwiKFxcXFx9KVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLiQxLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLmNvbnRyb2wub2YuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNlLmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFjZS5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiRzZWxmXCIgfSwgeyBcIm1hdGNoXCI6IFwiO1wiLCBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5zZW1pY29sb24uaGFza2VsbFwiIH1dIH0sIFwia2V5d29yZFwiOiB7IFwibWF0Y2hcIjogXCJcXFxcYig/PCEnKSg/Oih3aGVyZXxsZXR8aW58ZGVmYXVsdCl8KG0/ZG98aWZ8dGhlbnxlbHNlfGNhc2V8b2Z8cHJvY3xyZWMpKVxcXFxiKD8hJylcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuJDEuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQuY29udHJvbC4kMi5oYXNrZWxsXCIgfSB9IH0sIFwiZGVyaXZpbmdcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiYmVnaW5cIjogXCJeKFxcXFxzKikoZGVyaXZpbmcpXFxcXHMrKD86KHZpYXxzdG9ja3xuZXd0eXBlfGFueWNsYXNzKVxcXFxzKyk/XCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuc3RyYXRlZ3kuJDMuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBkZXJpdmluZyBzdGF0ZW1lbnRcXG4gICMgRGVjcmVhc2luZyBpbmRlbnRhdGlvblxcbiAgICg/PVxcXFx9fDspICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgKVwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwibWF0Y2hcIjogXCIoPzwhJylcXFxcYihpbnN0YW5jZSlcXFxcYig/IScpXCIsIFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuaW5zdGFuY2UuaGFza2VsbFwiIH0sIHsgXCJtYXRjaFwiOiBcIig/PCEnKVxcXFxiKHZpYXxzdG9ja3xuZXd0eXBlfGFueWNsYXNzKVxcXFxiKD8hJylcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuc3RyYXRlZ3kuJDEuaGFza2VsbFwiIH0gfSB9LCB7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dLCBcIm5hbWVcIjogXCJtZXRhLmRlcml2aW5nLmhhc2tlbGxcIiB9LCB7IFwiYmVnaW5cIjogXCIoZGVyaXZpbmcpKD86XFxcXHMrKHN0b2NrfG5ld3R5cGV8YW55Y2xhc3MpKT9cXFxccyooXFxcXCgpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuc3RyYXRlZ3kuJDIuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKFxcXFwpKVwiLCBcImVuZENhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwibWV0YS5kZXJpdmluZy5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgKGRlcml2aW5nKSg/OlxcXFxzKyhzdG9ja3xuZXd0eXBlfGFueWNsYXNzKSk/XFxcXHMrXFxuICAgIChbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qKVxcbiAgICAoXFxcXHMrKHZpYSlcXFxccysoLiopJCk/XFxuXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLmRlcml2aW5nLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLmRlcml2aW5nLnN0cmF0ZWd5LiQyLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0sIFwiNVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZGVyaXZpbmcuc3RyYXRlZ3kudmlhLmhhc2tlbGxcIiB9LCBcIjZcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0gfSwgXCJuYW1lXCI6IFwibWV0YS5kZXJpdmluZy5oYXNrZWxsXCIgfSwgeyBcIm1hdGNoXCI6IFwiKD88IScpXFxcXGIodmlhKVxcXFxiKD8hJylcIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5kZXJpdmluZy5zdHJhdGVneS52aWEuaGFza2VsbFwiIH1dIH0sIFwicHJlZml4X29wXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImNvbW1lbnRcIjogXCJBbiBvcGVyYXRvciBjYW5ub3QgYmUgY29tcG9zZWQgZW50aXJlbHkgb2YgJy0nIGNoYXJhY3RlcnM7ICBpbnN0ZWFkLCBpdCBzaG91bGQgYmUgbWF0Y2hlZCBhcyBhIGNvbW1lbnQuXFxuXCIsIFwibWF0Y2hcIjogXCIoP3gpXFxuICAoXFxcXCgpXFxcXHMqKD8hKD86LS0rfFxcXFwuXFxcXC4pXFxcXCkpKFxcXFwjK3xbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKyg/PCFcXFxcIykpXFxcXHMqKFxcXFwpKVwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImVudGl0eS5uYW1lLmZ1bmN0aW9uLmluZml4Lmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9IH1dIH0sIFwiaW5maXhfb3BcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwibWF0Y2hcIjogXCIoP3gpXFxuICAoKD86KD88IScnKSgnJyk/W1xcXFxwe0x1fVxcXFxwe0x0fV1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfScnXSpcXFxcLikqKVxcbiAgICAoXFxcXCMrfFtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0rKD88IVxcXFwjKSlcIiwgXCJjb21tZW50XCI6IFwiSW4gY2FzZSB0aGlzIHJlZ2V4IHNlZW1zIG92ZXJseSBnZW5lcmFsLCBub3RlIHRoYXQgSGFza2VsbCBwZXJtaXRzICB0aGUgZGVmaW5pdGlvbiBvZiBuZXcgb3BlcmF0b3JzIHdoaWNoIGNhbiBiZSBuZWFybHkgYW55IHN0cmluZyBvZiAgcHVuY3R1YXRpb24gY2hhcmFjdGVycywgc3VjaCBhcyAkJV4mKi5cXG5cIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5uYW1lc3BhY2UuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuaW5maXguaGFza2VsbFwiIH0gfSB9LCB7IFwibWF0Y2hcIjogXCIoYCkoKD86W1xcXFxwe0x1fVxcXFxwe0x0fV1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfScnXSpcXFxcLikqKShbXFxcXHB7TGx9XFxcXHB7THV9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfScnXSopKGApXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5iYWNrdGljay5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubmFtZXNwYWNlLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNkYXRhX2NvbnN0cnVjdG9yXCIgfV0gfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYmFja3RpY2suaGFza2VsbFwiIH0gfSwgXCJjb21tZW50XCI6IFwiSW4gY2FzZSB0aGlzIHJlZ2V4IHNlZW1zIHVudXN1YWwgZm9yIGFuIGluZml4IG9wZXJhdG9yLCBub3RlIHRoYXQgSGFza2VsbFxcbmFsbG93cyBhbnkgb3JkaW5hcnkgZnVuY3Rpb24gYXBwbGljYXRpb24gKGVsZW0gNCBbMS4uMTBdKSB0byBiZSByZXdyaXR0ZW5cXG5hcyBhbiBpbmZpeCBleHByZXNzaW9uICg0IGBlbGVtYCBbMS4uMTBdKS5cXG5cIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5mdW5jdGlvbi5pbmZpeC5oYXNrZWxsXCIgfV0gfSwgXCJtb2R1bGVfZXhwb3J0c1wiOiB7IFwiYmVnaW5cIjogXCJcXFxcKFwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIlxcXFwpXCIsIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcImFwcGx5RW5kUGF0dGVybkxhc3RcIjogMSwgXCJuYW1lXCI6IFwibWV0YS5kZWNsYXJhdGlvbi5leHBvcnRzLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcIm1hdGNoXCI6IFwiXFxcXGIoPzwhJykobW9kdWxlKVxcXFxiKD8hJylcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIubW9kdWxlLmhhc2tlbGxcIiB9IH0gfSwgeyBcImluY2x1ZGVcIjogXCIjY29tbWFcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNleHBvcnRfY29uc3RydWN0c1wiIH0sIHsgXCJiZWdpblwiOiBcIlxcXFwoXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiXFxcXClcIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3JlY29yZF93aWxkY2FyZFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2V4cG9ydF9jb25zdHJ1Y3RzXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjY29tbWFcIiB9XSB9XSB9LCBcImV4cG9ydF9jb25zdHJ1Y3RzXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImJlZ2luXCI6IFwiXFxcXGIoPzwhJykocGF0dGVybilcXFxcYig/IScpXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIucGF0dGVybi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/eClcXG4gICAjIERhdGEgY29uc3RydWN0b3JcXG4gICAoW1xcXFxwe0x1fVxcXFxwe0x0fV1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKilcXG4gICAjIFByZWZpeCBmb3JtIG9mIHN5bWJvbGljIGNvbnN0cnVjdG9yXFxuICAgfCAoXFxcXCgpXFxcXHMqKDpbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKylcXFxccyooXFxcXCkpXCIsIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJjb25zdGFudC5vdGhlci5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm90aGVyLm9wZXJhdG9yLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCJcXFxcYig/PCEnKSh0eXBlKVxcXFxiKD8hJylcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci50eXBlLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD94KVxcbiAgICMgVHlwZSBuYW1lXFxuICAgKFtcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopXFxuICAgIyBQcmVmaXggZm9ybSBvZiB0eXBlIG9wZXJhdG9yXFxuICAgfCAoXFxcXCgpXFxcXHMqKFtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0rKVxcXFxzKihcXFxcKSlcIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInN0b3JhZ2UudHlwZS5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInN0b3JhZ2UudHlwZS5vcGVyYXRvci5oYXNrZWxsXCIgfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfV0gfSwgeyBcIm1hdGNoXCI6IFwiKD88IScpXFxcXGJbXFxcXHB7TGx9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKlwiLCBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5oYXNrZWxsXCIgfSwgeyBcIm1hdGNoXCI6IFwiKD88IScpXFxcXGJbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qXCIsIFwibmFtZVwiOiBcInN0b3JhZ2UudHlwZS5oYXNrZWxsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcmVjb3JkX3dpbGRjYXJkXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcmVzZXJ2ZWRfc3ltYm9sXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcHJlZml4X29wXCIgfV0gfSwgXCJjb21tYVwiOiB7IFwibWF0Y2hcIjogXCIsXCIsIFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnNlcGFyYXRvci5jb21tYS5oYXNrZWxsXCIgfSwgXCJtb2R1bGVfbmFtZVwiOiB7IFwibWF0Y2hcIjogXCIoPzxjb25pZD5bXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qKFxcXFwuXFxcXGc8Y29uaWQ+KT8pXCIsIFwibmFtZVwiOiBcImVudGl0eS5uYW1lLm5hbWVzcGFjZS5oYXNrZWxsXCIgfSwgXCJwcmFnbWFcIjogeyBcImJlZ2luXCI6IFwiXFxcXHstI1wiLCBcImVuZFwiOiBcIiMtXFxcXH1cIiwgXCJuYW1lXCI6IFwibWV0YS5wcmVwcm9jZXNzb3IuaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiYmVnaW5cIjogXCIoP3hpKSBcXFxcYig/PCEnKShMQU5HVUFHRSlcXFxcYig/IScpXCIsIFwiZW5kXCI6IFwiKD89Iy1cXFxcfSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5wcmVwcm9jZXNzb3IucHJhZ21hLmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJtYXRjaFwiOiBcIig/eClcXG4gICg/Ok5vKT9cXG4gICg/OkF1dG9EZXJpdmVUeXBlYWJsZXxEYXRhdHlwZUNvbnRleHRzfERvUmVjfEluY29oZXJlbnRJbnN0YW5jZXN8TW9uYWRGYWlsRGVzdWdhcmluZ3xNb25vUGF0QmluZHN8TnVsbGFyeVR5cGVDbGFzc2VzfE92ZXJsYXBwaW5nSW5zdGFuY2VzfFBhdHRlcm5TaWduYXR1cmVzfFJlY29yZFB1bnN8UmVsYXhlZFBvbHlSZWMpXCIsIFwibmFtZVwiOiBcImludmFsaWQuZGVwcmVjYXRlZFwiIH0sIHsgXCJtYXRjaFwiOiBcIig/eClcXG4gIChcXG4gICg/Ok5vKT9cXG4gICg/OkFsbG93QW1iaWd1b3VzVHlwZXN8QWx0ZXJuYXRpdmVMYXlvdXRSdWxlfEFsdGVybmF0aXZlTGF5b3V0UnVsZVRyYW5zaXRpb25hbHxBcnJvd3N8QmFuZ1BhdHRlcm5zfEJpbmFyeUxpdGVyYWxzfENBcGlGRkl8Q1BQfENVU0tzfENvbnN0cmFpbmVkQ2xhc3NNZXRob2RzfENvbnN0cmFpbnRLaW5kc3xEYXRhS2luZHN8RGVmYXVsdFNpZ25hdHVyZXN8RGVyaXZlQW55Q2xhc3N8RGVyaXZlRGF0YVR5cGVhYmxlfERlcml2ZUZvbGRhYmxlfERlcml2ZUZ1bmN0b3J8RGVyaXZlR2VuZXJpY3xEZXJpdmVMaWZ0fERlcml2ZVRyYXZlcnNhYmxlfERlcml2aW5nU3RyYXRlZ2llc3xEZXJpdmluZ1ZpYXxEaXNhbWJpZ3VhdGVSZWNvcmRGaWVsZHN8RG9BbmRJZlRoZW5FbHNlfEJsb2NrQXJndW1lbnRzfER1cGxpY2F0ZVJlY29yZEZpZWxkc3xFbXB0eUNhc2V8RW1wdHlEYXRhRGVjbHN8RW1wdHlEYXRhRGVyaXZpbmd8RXhpc3RlbnRpYWxRdWFudGlmaWNhdGlvbnxFeHBsaWNpdEZvckFsbHxFeHBsaWNpdE5hbWVzcGFjZXN8RXh0ZW5kZWREZWZhdWx0UnVsZXN8RmxleGlibGVDb250ZXh0c3xGbGV4aWJsZUluc3RhbmNlc3xGb3JlaWduRnVuY3Rpb25JbnRlcmZhY2V8RnVuY3Rpb25hbERlcGVuZGVuY2llc3xHQURUU3ludGF4fEdBRFRzfEdIQ0ZvcmVpZ25JbXBvcnRQcmltfEdlbmVyYWxpKD86c3x6KWVkTmV3dHlwZURlcml2aW5nfEltcGxpY2l0UGFyYW1zfEltcGxpY2l0UHJlbHVkZXxJbXBvcnRRdWFsaWZpZWRQb3N0fEltcHJlZGljYXRpdmVUeXBlc3xUeXBlRmFtaWx5RGVwZW5kZW5jaWVzfEluc3RhbmNlU2lnc3xBcHBsaWNhdGl2ZURvfEludGVycnVwdGlibGVGRkl8SmF2YVNjcmlwdEZGSXxLaW5kU2lnbmF0dXJlc3xMYW1iZGFDYXNlfExpYmVyYWxUeXBlU3lub255bXN8TWFnaWNIYXNofE1vbmFkQ29tcHJlaGVuc2lvbnN8TW9ub0xvY2FsQmluZHN8TW9ub21vcnBoaXNtUmVzdHJpY3Rpb258TXVsdGlQYXJhbVR5cGVDbGFzc2VzfE11bHRpV2F5SWZ8TnVtZXJpY1VuZGVyc2NvcmVzfE5QbHVzS1BhdHRlcm5zfE5hbWVkRmllbGRQdW5zfE5hbWVkV2lsZENhcmRzfE5lZ2F0aXZlTGl0ZXJhbHN8SGV4RmxvYXRMaXRlcmFsc3xOb25kZWNyZWFzaW5nSW5kZW50YXRpb258TnVtRGVjaW1hbHN8T3ZlcmxvYWRlZExhYmVsc3xPdmVybG9hZGVkTGlzdHN8T3ZlcmxvYWRlZFN0cmluZ3N8UGFja2FnZUltcG9ydHN8UGFyYWxsZWxBcnJheXN8UGFyYWxsZWxMaXN0Q29tcHxQYXJ0aWFsVHlwZVNpZ25hdHVyZXN8UGF0dGVybkd1YXJkc3xQYXR0ZXJuU3lub255bXN8UG9seUtpbmRzfFBvbHltb3JwaGljQ29tcG9uZW50c3xRdWFudGlmaWVkQ29uc3RyYWludHN8UG9zdGZpeE9wZXJhdG9yc3xRdWFzaVF1b3Rlc3xSYW5rMlR5cGVzfFJhbmtOVHlwZXN8UmViaW5kYWJsZVN5bnRheHxSZWNvcmRXaWxkQ2FyZHN8UmVjdXJzaXZlRG98UmVsYXhlZExheW91dHxSb2xlQW5ub3RhdGlvbnN8U2NvcGVkVHlwZVZhcmlhYmxlc3xTdGFuZGFsb25lRGVyaXZpbmd8U3RhcklzVHlwZXxTdGF0aWNQb2ludGVyc3xTdHJpY3R8U3RyaWN0RGF0YXxUZW1wbGF0ZUhhc2tlbGx8VGVtcGxhdGVIYXNrZWxsUXVvdGVzfFN0YW5kYWxvbmVLaW5kU2lnbmF0dXJlc3xUcmFkaXRpb25hbFJlY29yZFN5bnRheHxUcmFuc2Zvcm1MaXN0Q29tcHxUdXBsZVNlY3Rpb25zfFR5cGVBcHBsaWNhdGlvbnN8VHlwZUluVHlwZXxUeXBlRmFtaWxpZXN8VHlwZU9wZXJhdG9yc3xUeXBlU3lub255bUluc3RhbmNlc3xVbmJveGVkVHVwbGVzfFVuYm94ZWRTdW1zfFVuZGVjaWRhYmxlSW5zdGFuY2VzfFVuZGVjaWRhYmxlU3VwZXJDbGFzc2VzfFVuaWNvZGVTeW50YXh8VW5saWZ0ZWRGRklUeXBlc3xVbmxpZnRlZE5ld3R5cGVzfFZpZXdQYXR0ZXJucylcXG4gIClcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIucHJlcHJvY2Vzc29yLmV4dGVuc2lvbi5oYXNrZWxsXCIgfSB9IH0sIHsgXCJpbmNsdWRlXCI6IFwiI2NvbW1hXCIgfV0gfSwgeyBcImJlZ2luXCI6IFwiKD94aSlcXG4gIFxcXFxiKD88IScpKFNQRUNJQUxJKD86U3xaKUUpXFxuICAoPzpcXG4gIFxcXFxzKiggXFxcXFsgW15cXFxcW1xcXFxdXSogXFxcXF0pP1xcXFxzKlxcbiAgfFxcXFxzK1xcbiAgKVxcbiAgKGluc3RhbmNlKVxcXFxiKD8hJylcIiwgXCJlbmRcIjogXCIoPz0jLVxcXFx9KVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnByZXByb2Nlc3Nvci5wcmFnbWEuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2lubGluZV9waGFzZVwiIH1dIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuaW5zdGFuY2UuaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCIoP3hpKVxcbiAgXFxcXGIoPzwhJykoU1BFQ0lBTEkoPzpTfFopRSlcXFxcYig/IScpXFxuICAoPzpcXFxccysoSU5MSU5FKVxcXFxiKD8hJykpP1xcbiAgKD86XFxcXHMqKFxcXFxbIFteXFxcXFtcXFxcXV0qIFxcXFxdKT8pXFxuICBcXFxccypcIiwgXCJlbmRcIjogXCIoPz0jLVxcXFx9KVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnByZXByb2Nlc3Nvci5wcmFnbWEuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIucHJlcHJvY2Vzc29yLnByYWdtYS5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjaW5saW5lX3BoYXNlXCIgfV0gfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiRzZWxmXCIgfV0gfSwgeyBcIm1hdGNoXCI6IFwiKD94aSkgXFxcXGIoPzwhJylcXG4gIChMQU5HVUFHRXxPUFRJT05TX0dIQ3xJTkNMVURFXFxuICB8TUlOSU1BTHxVTlBBQ0t8T1ZFUkxBUFN8SU5DT0hFUkVOVFxcbiAgfE5PVU5QQUNLfFNPVVJDRXxPVkVSTEFQUElOR3xPVkVSTEFQUEFCTEV8SU5MSU5FXFxuICB8Tk9JTkxJTkV8SU5MSU5FP0FCTEV8Q09OTElLRXxMSU5FfENPTFVNTnxSVUxFU1xcbiAgfENPTVBMRVRFKVxcXFxiKD8hJylcIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5wcmVwcm9jZXNzb3IuaGFza2VsbFwiIH0sIHsgXCJiZWdpblwiOiBcIig/aSlcXFxcYihERVBSRUNBVEVEfFdBUk5JTkcpXFxcXGJcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci5wcmVwcm9jZXNzb3IucHJhZ21hLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD89Iy1cXFxcfSlcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjc3RyaW5nX2xpdGVyYWxcIiB9XSB9XSB9LCBcImxpcXVpZF9oYXNrZWxsXCI6IHsgXCJuYW1lXCI6IFwiYmxvY2subGlxdWlkaGFza2VsbC5oYXNrZWxsXCIsIFwiYmVnaW5cIjogXCJcXFxcey1AXCIsIFwiZW5kXCI6IFwiQC1cXFxcfVwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiRzZWxmXCIgfV0gfSwgXCJjb250ZXh0XCI6IHsgXCJtYXRjaFwiOiBcIig/eClcXG4gICguKilcXG4gICg/PCFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKVxcbiAgKD0+fFxcdTIxRDIpXFxuICAoPyFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKVxcblwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmJpZy1hcnJvdy5oYXNrZWxsXCIgfSB9IH0sIFwiZGF0YV9jb25zdHJ1Y3RvclwiOiB7IFwibWF0Y2hcIjogXCJcXFxcYig/PCEnKVtcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSooPyFbXFxcXC4nXFxcXHddKVwiLCBcIm5hbWVcIjogXCJjb25zdGFudC5vdGhlci5oYXNrZWxsXCIgfSwgXCJxdWFsaWZpZXJcIjogeyBcIm1hdGNoXCI6IFwiXFxcXGIoPzwhJylbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qXFxcXC5cIiwgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubmFtZXNwYWNlLmhhc2tlbGxcIiB9LCBcInJlY29yZF9kZWNsXCI6IHsgXCJiZWdpblwiOiBcIih7KSg/IS0pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNlLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD88IS0pKH0pXCIsIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFjZS5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJtZXRhLnJlY29yZC5kZWZpbml0aW9uLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcmVjb3JkX2RlY2xfZmllbGRcIiB9XSB9LCBcInJlY29yZFwiOiB7IFwiYmVnaW5cIjogXCIoeykoPyEtKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFjZS5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/PCEtKSh9KVwiLCBcImVuZENhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYnJhY2UuaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwibWV0YS5yZWNvcmQuaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNyZWNvcmRfZmllbGRcIiB9XSB9LCBcInJlY29yZF9kZWNsX2ZpZWxkXCI6IHsgXCJiZWdpblwiOiBcIig/eClcXG4gICg/OihbXFxcXHB7TGx9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKilcXG4gICAgfChcXFxcKClcXFxccyooW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSspXFxcXHMqKFxcXFwpKVxcbiAgKVxcblwiLCBcImVuZFwiOiBcIigsKXwoPz19KVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJ2YXJpYWJsZS5vdGhlci5tZW1iZXIuZGVmaW5pdGlvbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInZhcmlhYmxlLm90aGVyLm1lbWJlci5kZWZpbml0aW9uLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcImVuZENhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uY29tbWEuaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjY29tbWFcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNkb3VibGVfY29sb25cIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3JlY29yZF9kZWNsX2ZpZWxkXCIgfV0gfSwgXCJyZWNvcmRfd2lsZGNhcmRcIjogeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgKD88IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0pXFxuICAoXFxcXC5cXFxcLilcXG4gICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0pXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJ2YXJpYWJsZS5vdGhlci5tZW1iZXIud2lsZGNhcmQuaGFza2VsbFwiIH0gfSB9LCBcInJlY29yZF9maWVsZFwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJiZWdpblwiOiBcIig/eClcXG4gICg/OihbXFxcXHB7TGx9XFxcXHB7THV9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfVxcXFwuJ10qKVxcbiAgICB8KFxcXFwoKVxcXFxzKihbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKylcXFxccyooXFxcXCkpXFxuICApXFxuXCIsIFwiZW5kXCI6IFwiKCwpfCg/PX0pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcInZhcmlhYmxlLm90aGVyLm1lbWJlci5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3F1YWxpZmllclwiIH1dIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJ2YXJpYWJsZS5vdGhlci5tZW1iZXIuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5jb21tYS5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNjb21tYVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiJHNlbGZcIiB9XSB9LCB7IFwiaW5jbHVkZVwiOiBcIiNyZWNvcmRfd2lsZGNhcmRcIiB9XSB9LCBcInJvbGVfYW5ub3RhdGlvblwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJiZWdpblwiOiBcIl4oXFxcXHMqKSh0eXBlKVxcXFxzKyhyb2xlKVxcXFxiKD8hJylcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci50eXBlLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnJvbGUuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIoP3gpICMgRGV0ZWN0IGVuZCBvZiBibG9jayBieSBkZWNyZWFzaW5nIGluZGVudGF0aW9uOlxcbiAgKD89XFxcXH18OykgICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgKVwiLCBcIm5hbWVcIjogXCJtZXRhLnJvbGUtYW5ub3RhdGlvbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfY29uc3RydWN0b3JcIiB9LCB7IFwibWF0Y2hcIjogXCJcXFxcYig/PCEnKShub21pbmFsfHJlcHJlc2VudGF0aW9uYWx8cGhhbnRvbSlcXFxcYig/IScpXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnJvbGUuJDEuaGFza2VsbFwiIH0gfSB9XSB9XSB9LCBcImZ1bl9kZWNsXCI6IHsgXCJiZWdpblwiOiBcIig/eCleKFxcXFxzKilcXG4gICg/PGZuPlxcbiAgICAoPzpcXG4gICAgICBbXFxcXHB7TGx9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKlxcXFwjKlxcbiAgICB8IFxcXFwoXFxcXHMqXFxuICAgICAgICAoPyEtLStcXFxcKSlcXG4gICAgICAgIFtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDo7XFxcXFtcXFxcXWB7fV9cXFwiJ11dXFxuICAgICAgICBbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKlxcbiAgICAgIFxcXFxzKlxcXFwpXFxuICAgIClcXG4gICAgKD86XFxcXHMqLFxcXFxzKlxcXFxnPGZuPik/XFxuICApXFxuICBcXFxccyooPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteXFxcXCksO1xcXFxdYH1fXFxcIiddXSkoOjp8XFx1MjIzNykoPyFbXFxcXHB7U31cXFxccHtQfSYmW15cXFxcKCw7XFxcXFtge19cXFwiJ11dKVxcblwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjJcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3Jlc2VydmVkX3N5bWJvbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3ByZWZpeF9vcFwiIH1dIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZG91YmxlLWNvbG9uLmhhc2tlbGxcIiB9IH0sIFwibmFtZVwiOiBcIm1ldGEuZnVuY3Rpb24udHlwZS1kZWNsYXJhdGlvbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0sIFwiZW5kXCI6IFwiKD94KVxcbiAgIyBFbmQgb2YgdHlwZSBhbm5vdGF0aW9uOlxcbiAgICAjIFRvIHRoZSBsZWZ0IG9mIGEgcmVzZXJ2ZWQgc3ltYm9saWMga2V5d29yZCBzdWNoIGFzID0gb3IgPC1cXG4gICg/PSBcXG4gICAgICAjIG5vbi1zeW1ib2xpYyBjaGFyYWN0ZXJcXG4gICAgICAoPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSlcXG4gICAgICAjIHN5bWJvbGljIGtleXdvcmQgZXhjZXB0ICgtPilcXG4gICAgICAoKDwtfFxcdTIxOTApfCg9KXwoLTx8XFx1MjFBMil8KC08PHxcXHUyOTFCKSlcXG4gICAgICAjIG5vbi1zeW1ib2xpYyBjaGFyYWN0ZXJcXG4gICAgICAoWygpLDtcXFxcW1xcXFxdYHt9X1xcXCInXXxbXlxcXFxwe1N9XFxcXHB7UH1dKVxcbiAgKVxcbiAgIyBEZWNyZWFzaW5nIGluZGVudGF0aW9uOlxcbiAgfCg/PVxcXFx9fDspICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgKVxcblwiIH0sIFwiYWR0X2NvbnN0cnVjdG9yXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImJlZ2luXCI6IFwiKD94KVxcbiAgKD88IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0pICMgbm9uLXN5bWJvbFxcbiAgKD86KD0pfChcXFxcfCkpXFxuICAoPyFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKSAgIyBub24tc3ltYm9sXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZXEuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucGlwZS5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/eClcXG4gICg/OlxcXFxHfF4pXFxcXHMqICMgRW5mb3JjZSBzdGFydGluZyBjb25kaXRpb24gdG8gYXZvaWQgY2F0YXN0cm9waGljIGJhY2t0cmFja2luZyAoaHR0cHM6Ly9naXRodWIuY29tL0p1c3R1c0FkYW0vbGFuZ3VhZ2UtaGFza2VsbC9pc3N1ZXMvMTYxKVxcbiAgKD86ICMgSW5maXggZGF0YSBjb25zdHJ1Y3RvclxcbiAgICAjIEZpcnN0IGFyZ3VtZW50XFxuICAgICg/OlxcbiAgICAjIFNpbXBsZSB0eXBlXFxuICAgICAgKD88IScpXFxcXGIoKD86W1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXFxcXC5dKSspXFxuICAgICMgVHlwZSBpbnNpZGUgYmFsYW5jZWQgcGFyZW50aGVzZXNcXG4gICAgfCAoJz8gIyBPcHRpb25hbCBwcm9tb3Rpb24gdGlja1xcbiAgICAgICAgKD88cGFyZW4+XFxuICAgICAgICAgIFxcXFwoICAgICAgICAgICMgT3BlbmluZyBwYXJlbnRoZXNpc1xcbiAgICAgICAgICAoPzpcXG4gICAgICAgICAgICBbXlxcXFwoXFxcXCldKiAgIyBNYXRjaCBub24tcGFyZW50aGVzZXNcXG4gICAgICAgICAgfCBcXFxcZzxwYXJlbj4gIyBvciByZWN1cnNlIGludG8gZnVydGhlciBkZXB0aFxcbiAgICAgICAgICApKlxcbiAgICAgICAgICBcXFxcKSAgICAgICAgICAjIENsb3NpbmcgcGFyZW50aGVzaXNcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgICMgVHlwZSBpbnNpZGUgYmFsYW5jZWQgYnJhY2tldHNcXG4gICAgfCAoJz8gIyBPcHRpb25hbCBwcm9tb3Rpb24gdGlja1xcbiAgICAgICAgKD88YnJhYz5cXG4gICAgICAgICAgXFxcXCggICAgICAgICAgIyBPcGVuaW5nIGJyYWNrZXRcXG4gICAgICAgICAgKD86XFxuICAgICAgICAgICAgW15cXFxcW1xcXFxdXSogICMgTWF0Y2ggbm9uLWJyYWNrZXRzXFxuICAgICAgICAgIHwgXFxcXGc8YnJhYz4gICMgb3IgcmVjdXJzZSBpbnRvIGZ1cnRoZXIgZGVwdGhcXG4gICAgICAgICAgKSpcXG4gICAgICAgICAgXFxcXF0gICAgICAgICAgIyBDbG9zaW5nIGJyYWNrZXRcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgICkgICAgICAgIFxcbiAgICAjIFRoZW4gZWl0aGVyXFxuICAgIFxcXFxzKlxcbiAgICAgICMgLSBhIHN5bWJvbGljIGluZml4IGNvbnN0cnVjdG9yLCBvclxcbiAgICAoPzooPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSkoOltcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0qKVxcbiAgICAgICMgLSBhbiBhbHBoYWJldGljIGluZml4IGNvbnN0cnVjdG9yXFxuICAgIHwgKGApKFtcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopKGApXFxuICAgIClcXG5cXG4gICkgIyBPdGhlcndpc2UsIHByZWZpeCBkYXRhIGNvbnN0cnVjdG9yLCBlaXRoZXI6XFxuICB8ICMgLSBhbiBhbHBoYWJldGljIGRhdGEgY29uc3RydWN0b3IgZS5nLiBcXFwiQ29uc18xMjNcXFwiXFxuICAgICg/Oig/PCEnKVxcXFxiKFtcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopKVxcbiAgfCAjIC0gYSBzeW1ib2xpYyAocHJlZml4KSBkYXRhIGNvbnN0cnVjdG9yXFxuICAgIChcXFxcKClcXFxccyooOltcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0qKVxcXFxzKihcXFxcKSlcIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgXCIyXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCBcIjRcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0sIFwiNlwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm90aGVyLm9wZXJhdG9yLmhhc2tlbGxcIiB9LCBcIjdcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5iYWNrdGljay5oYXNrZWxsXCIgfSwgXCI4XCI6IHsgXCJuYW1lXCI6IFwiY29uc3RhbnQub3RoZXIuaGFza2VsbFwiIH0sIFwiOVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJhY2t0aWNrLmhhc2tlbGxcIiB9LCBcIjEwXCI6IHsgXCJuYW1lXCI6IFwiY29uc3RhbnQub3RoZXIuaGFza2VsbFwiIH0sIFwiMTFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIxMlwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm90aGVyLm9wZXJhdG9yLmhhc2tlbGxcIiB9LCBcIjEzXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjZGVyaXZpbmdcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNyZWNvcmRfZGVjbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2ZvcmFsbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2NvbnRleHRcIiB9XSB9XSB9LCBcImdhZHRfY29uc3RydWN0b3JcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiYmVnaW5cIjogXCIoP3gpXFxuICAgXihcXFxccyopXFxuICAgICAgKD86XFxuICAgICAgICAoXFxcXGIoPzwhJylbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qKVxcbiAgICAgIHwoXFxcXCgpXFxcXHMqKDpbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKilcXFxccyooXFxcXCkpXFxuICAgICAgKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjJcIjogeyBcIm5hbWVcIjogXCJjb25zdGFudC5vdGhlci5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm90aGVyLm9wZXJhdG9yLmhhc2tlbGxcIiB9LCBcIjVcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIig/eClcXG4gICMgR0FEVCBjb25zdHJ1Y3RvciBlbmRzXFxuICAoPz1cXFxcYig/PCEnJylkZXJpdmluZ1xcXFxiKD8hJykpICBcXG4gICAgICAgICMgRGVjcmVhc2luZyBpbmRlbnRhdGlvblxcbiAgfCg/PVxcXFx9fDspICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgKVxcblwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNkZXJpdmluZ1wiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2RvdWJsZV9jb2xvblwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3JlY29yZF9kZWNsXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCIoP3gpXFxuICAoXFxcXGIoPzwhJylbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9XSopICMgbmFtZWQgY29uc3RydWN0b3JcXG4gfChcXFxcKClcXFxccyooOltcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0qKVxcXFxzKihcXFxcKSkgICAgIyBwcmVmaXggb3BlcmF0b3JcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwiY29uc3RhbnQub3RoZXIuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJjb25zdGFudC5vdGhlci5vcGVyYXRvci5oYXNrZWxsXCIgfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCIkXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1lbnRfbGlrZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2Rlcml2aW5nXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjZG91YmxlX2NvbG9uXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcmVjb3JkX2RlY2xcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH1dIH0sIFwidHlwZV9hcHBsaWNhdGlvblwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJiZWdpblwiOiBgKD88PVtcXFxccyw7XFxcXFtcXFxcXXt9XCJdKShAKSgnKT8oXFxcXCgpYCwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcmVmaXguYXQuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIlxcXFwpXCIsIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJtZXRhLnR5cGUtYXBwbGljYXRpb24uaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0sIHsgXCJiZWdpblwiOiBgKD88PVtcXFxccyw7XFxcXFtcXFxcXXt9XCJdKShAKSgnKT8oXFxcXFspYCwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcmVmaXguYXQuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiXFxcXF1cIiwgXCJuYW1lXCI6IFwibWV0YS50eXBlLWFwcGxpY2F0aW9uLmhhc2tlbGxcIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNrZXQuaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogJyg/PD1bXFxcXHMsO1xcXFxbXFxcXF17fVwiXSkoQCkoPz1cXFxcXCIpJywgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcmVmaXguYXQuaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogJyg/PD1cXFxcXCIpJywgXCJuYW1lXCI6IFwibWV0YS50eXBlLWFwcGxpY2F0aW9uLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjc3RyaW5nX2xpdGVyYWxcIiB9XSB9LCB7IFwiYmVnaW5cIjogYCg/PD1bXFxcXHMsO1xcXFxbXFxcXF17fVwiXSkoQCkoPz1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKWAsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJlZml4LmF0Lmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD8hW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSlcIiwgXCJuYW1lXCI6IFwibWV0YS50eXBlLWFwcGxpY2F0aW9uLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9XSB9LCBcInR5cGVfc2lnbmF0dXJlXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcIm1hdGNoXCI6IFwiKCcpPyhcXFxcKClcXFxccyooXFxcXCkpXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByb21vdGlvbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwibmFtZVwiOiBcInN1cHBvcnQuY29uc3RhbnQudW5pdC5oYXNrZWxsXCIgfSwgeyBcIm1hdGNoXCI6IFwiKFxcXFwoKSgjKVxcXFxzKigjKShcXFxcKSlcIiwgXCJuYW1lXCI6IFwic3VwcG9ydC5jb25zdGFudC51bml0LnVuYm94ZWQuaGFza2VsbFwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuaGFzaC5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9IH0sIHsgXCJtYXRjaFwiOiBcIignKT8oXFxcXCgpXFxcXHMqLFtcXFxccyxdKihcXFxcKSlcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwic3VwcG9ydC5jb25zdGFudC50dXBsZS5oYXNrZWxsXCIgfSwgeyBcIm1hdGNoXCI6IFwiKFxcXFwoKSgjKVxcXFxzKigjKShcXFxcKSlcIiwgXCJuYW1lXCI6IFwic3VwcG9ydC5jb25zdGFudC51bml0LnVuYm94ZWQuaGFza2VsbFwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuaGFzaC5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9IH0sIHsgXCJtYXRjaFwiOiBcIihcXFxcKCkoIylcXFxccyosW1xcXFxzLF0qKCMpKFxcXFwpKVwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24ucGFyZW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuaGFzaC5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJzdXBwb3J0LmNvbnN0YW50LnR1cGxlLnVuYm94ZWQuaGFza2VsbFwiIH0sIHsgXCJtYXRjaFwiOiBcIignKT8oXFxcXFspXFxcXHMqKFxcXFxdKVwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcm9tb3Rpb24uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNrZXQuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNrZXQuaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwic3VwcG9ydC5jb25zdGFudC5lbXB0eS1saXN0Lmhhc2tlbGxcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNpbnRlZ2VyX2xpdGVyYWxzXCIgfSwgeyBcIm1hdGNoXCI6IFwiKDo6fFxcdTIyMzcpKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSlcIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5kb3VibGUtY29sb24uaGFza2VsbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2ZvcmFsbFwiIH0sIHsgXCJtYXRjaFwiOiBcIj0+fFxcdTIxRDJcIiwgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5iaWctYXJyb3cuaGFza2VsbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3N0cmluZ19saXRlcmFsXCIgfSwgeyBcIm1hdGNoXCI6IFwiJ1teJ10nXCIsIFwibmFtZVwiOiBcImludmFsaWRcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX2FwcGxpY2F0aW9uXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjcmVzZXJ2ZWRfc3ltYm9sXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9vcGVyYXRvclwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfY29uc3RydWN0b3JcIiB9LCB7IFwiYmVnaW5cIjogXCIoXFxcXCgpKCMpXCIsIFwiZW5kXCI6IFwiKCMpKFxcXFwpKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5oYXNoLmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmhhc2guaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1hXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCIoJyk/KFxcXFwoKVwiLCBcImVuZFwiOiBcIihcXFxcKSlcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcm9tb3Rpb24uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSB9LCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tYVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgeyBcImJlZ2luXCI6IFwiKCcpPyhcXFxcWylcIiwgXCJlbmRcIjogXCIoXFxcXF0pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9IH0sIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9IH0sIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI2NvbW1hXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCB7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3ZhcmlhYmxlXCIgfV0gfSwgXCJkb3VibGVfY29sb25cIjogeyBcIm1hdGNoXCI6IFwiXFxcXHMqKDo6fFxcdTIyMzcpKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSlcXFxccypcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZG91YmxlLWNvbG9uLmhhc2tlbGxcIiB9IH0gfSwgXCJzdGFydF90eXBlX3NpZ25hdHVyZVwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJiZWdpblwiOiBcIl4oXFxcXHMqKSg6OnxcXHUyMjM3KSg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXlxcXFwoLDtcXFxcW2B7X1xcXCInXV0pXFxcXHMqXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZG91YmxlLWNvbG9uLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD94KVxcbiAgIyBFbmQgdHlwZSBhbm5vdGF0aW9uIHdoZW4gc2VlaW5nIG9uZSBvZjpcXG4gICg/PVxcbiAgICBcXFxcIz9cXFxcKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBjbG9zaW5nIHBhcmVudGhlc2lzXFxuICAgIHxcXFxcXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGNsb3NpbmcgYnJhY2tldFxcbiAgICB8LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBjb21tYVxcbiAgICB8KD88IScpXFxcXGIoaW58dGhlbnxlbHNlfG9mKVxcXFxiKD8hJykgIyBrZXl3b3JkXFxuICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHN5bWJvbGljIGtleXdvcmQgZXhjZXB0ICgtPilcXG4gICAgICAoPzwhW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSlcXG4gICAgICAoPzpcXG4gICAgICAgICAoXFxcXFxcXFx8XFx1MDNCQilcXG4gICAgICAgIHwoPC18XFx1MjE5MClcXG4gICAgICAgIHwoPSlcXG4gICAgICAgIHwoLTx8XFx1MjFBMilcXG4gICAgICAgIHwoLTw8fFxcdTI5MUIpXFxuICAgICAgKVxcbiAgICAgIChbKCksO1xcXFxbXFxcXF1ge31fXFxcIiddfFteXFxcXHB7U31cXFxccHtQfV0pXFxuICAgIHwoXFxcXCN8QCktXFxcXH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgRW5kIG9mIGFubm90YXRpb24gYmxvY2sgKExpcXVpZEhhc2tlbGwgb3IgcHJhZ21hKVxcbiAgICAjIERlY3JlYXNpbmcgaW5kZW50YXRpb246XFxuICAgIHwgKD89XFxcXH18OykgICAgICMgRXhwbGljaXQgaW5kZW50YXRpb25cXG4gICAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICAgIFxcXFwxXFxcXHMqXFxcXFMgICAgIyAtIGVxdWFsbHkgaW5kZW50ZWQsIG9yXFxuICAgICAgfCBcXFxccyogICAgICAgICMgLSBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBmb2xsb3dlZCBieTpcXG4gICAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICAgIHxcXFxcey1bXkBdICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgYmxvY2sgY29tbWVudCwgb3JcXG4gICAgICAgIHwtLSsgICAgICAgIyAgIC0gdGhlIHN0YXJ0IG9mIGEgc2luZ2xlLWxpbmUgY29tbWVudC5cXG4gICAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICAgIyBUaGUgZG91YmxlIGRhc2ggbWF5IG5vdCBiZSBmb2xsb3dlZCBieSBvdGhlciBvcGVyYXRvciBjaGFyYWN0ZXJzXFxuICAgICAgICAgICAgICAgICAgICMgKHRoZW4gaXQgd291bGQgYmUgYW4gb3BlcmF0b3IsIG5vdCBhIGNvbW1lbnQpXFxuICAgICAgKVxcbiAgKVwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dLCBcIm5hbWVcIjogXCJtZXRhLnR5cGUtZGVjbGFyYXRpb24uaGFza2VsbFwiIH0sIHsgXCJiZWdpblwiOiBcIig/PCFbXFxcXHB7U31cXFxccHtQfSYmW15cXFxcKCw7XFxcXFtge19cXFwiJ11dKSg6OnxcXHUyMjM3KSg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXlxcXFwoLDtcXFxcW2B7X1xcXCInXV0pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZG91YmxlLWNvbG9uLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiKD94KVxcbiAgIyBFbmQgdHlwZSBhbm5vdGF0aW9uIHdoZW4gc2VlaW5nIG9uZSBvZjpcXG4gICg/PVxcbiAgICBcXFxcIz9cXFxcKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBjbG9zaW5nIHBhcmVudGhlc2lzXFxuICAgIHxcXFxcXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGNsb3NpbmcgYnJhY2tldFxcbiAgICB8LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBjb21tYVxcbiAgICB8XFxcXGIoPzwhJykoaW58dGhlbnxlbHNlfG9mKVxcXFxiKD8hJykgIyBrZXl3b3JkXFxuICAgIHwoXFxcXCN8QCktXFxcXH0gICAgICAgICAgICAgICAgICAgICAgICAjIEVuZCBvZiBhbm5vdGF0aW9uIGJsb2NrIChMaXF1aWRIYXNrZWxsIG9yIHByYWdtYSlcXG4gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgc3ltYm9saWMga2V5d29yZCBleGNlcHQgKC0+KVxcbiAgICAgICg/PCFbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ11dKVxcbiAgICAgICg/OlxcbiAgICAgICAgIChcXFxcXFxcXHxcXHUwM0JCKVxcbiAgICAgICAgfCg8LXxcXHUyMTkwKVxcbiAgICAgICAgfCg9KVxcbiAgICAgICAgfCgtPHxcXHUyMUEyKVxcbiAgICAgICAgfCgtPDx8XFx1MjkxQilcXG4gICAgICApXFxuICAgICAgKFsoKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ118W15cXFxccHtTfVxcXFxwe1B9XSlcXG4gICAgIyBJbmRlbnRhdGlvbiBcXG4gICAgfCg/PVxcXFx9fDspICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgICB8JCAgICAgICAgICAgICAjIEVuZCBvZiBsaW5lXFxuICApXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfV0gfSwgXCJ0eXBlX3ZhcmlhYmxlXCI6IHsgXCJtYXRjaFwiOiBcIlxcXFxiKD88IScpKD8hKD86Zm9yYWxsfGRlcml2aW5nKVxcXFxiKD8hJykpW1xcXFxwe0xsfV9dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSpcIiwgXCJuYW1lXCI6IFwidmFyaWFibGUub3RoZXIuZ2VuZXJpYy10eXBlLmhhc2tlbGxcIiB9LCBcInR5cGVfY29uc3RydWN0b3JcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwibWF0Y2hcIjogXCIoP3gpXFxuICAjIE9wdGlvbmFsIHByb21vdGlvbiB0aWNrXFxuICAgICgnKT9cXG4gICMgT3B0aW9uYWwgcXVhbGlmaWVkIG5hbWVcXG4gICAgKCg/OlxcXFxiW1xcXFxwe0x1fVxcXFxwe0x0fV1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKlxcXFwuKSopXFxuICAjIFR5cGUgY29uc3RydWN0b3IgcHJvcGVyXFxuICAgIChcXFxcYltcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByb21vdGlvbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubmFtZXNwYWNlLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJzdG9yYWdlLnR5cGUuaGFza2VsbFwiIH0gfSB9LCB7IFwibWF0Y2hcIjogXCIoP3gpXFxuICAjIE9wdGlvbmFsIHByb21vdGlvbiB0aWNrXFxuICAgICgnKT9cXG4gICMgT3BlbmluZyBwYXJlbnRoZXNpc1xcbiAgICAoXFxcXCgpXFxcXHMqXFxuICAjIE9wdGlvbmFsIHF1YWxpZmllZCBuYW1lXFxuICAgICgoPzpbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qXFxcXC4pKilcXG4gICMgVHlwZSBvcGVyYXRvciBwcm9wZXJcXG4gICAgKFtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0rKVxcbiAgIyBDbG9zaW5nIHBhcmVudGhlc2lzXFxuICAgIFxcXFxzKihcXFxcKSlcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJvbW90aW9uLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubmFtZXNwYWNlLmhhc2tlbGxcIiB9LCBcIjRcIjogeyBcIm5hbWVcIjogXCJzdG9yYWdlLnR5cGUub3BlcmF0b3IuaGFza2VsbFwiIH0sIFwiNVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0gfV0gfSwgXCJvdmVybG9hZGVkX2xhYmVsXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcIm1hdGNoXCI6ICcoP3gpIFxcbiAgKD88IVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9XFxcXHB7U31cXFxccHtQfSYmW14oLDtcXFxcW2B7XV0pICMgRGlzYWxsb3cgY2xvc2luZyBjaGFyYWN0ZXJzXFxuICAoXFxcXCMpXFxuICAgICg/OlxcbiAgICAjIFN0cmluZ1xcbiAgICAoXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIilcXG4gICAgIyBTZXF1ZW5jZSBvZiBhbGxvd2VkIGxhYmVsIGlkZW50aWZpZXJzXFxuICAgIHxbXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfVxcJ1xcXFwuXStcXG4gICAgKScsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5oYXNoLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNzdHJpbmdfbGl0ZXJhbFwiIH1dIH0gfSwgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubGFiZWwuaGFza2VsbFwiIH1dIH0sIFwicmVzZXJ2ZWRfc3ltYm9sXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgKD88IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInJ11dKVxcbiAgKD86XFxuICAgICAoXFxcXC5cXFxcLilcXG4gICAgfCg6KVxcbiAgICB8KD0pXFxuICAgIHwoXFxcXFxcXFwpICAgICAjIFxcdTAzQkIgbm90IHJlc2VydmVkIGFzIGl0IGlzIGEgbGV0dGVyXFxuICAgIHwoXFxcXHwpXFxuICAgIHwoPC18XFx1MjE5MClcXG4gICAgfCgtPnxcXHUyMTkyKVxcbiAgICB8KC08fFxcdTIxQTIpXFxuICAgIHwoLTw8fFxcdTI5MUIpXFxuICAgIHwoPi18XFx1MjkxQSlcXG4gICAgfCg+Pi18XFx1MjkxQylcXG4gICAgfChcXHUyMjAwKVxcbiAgKVxcbiAgKD8hW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIicnXV0pXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmRvdWJsZS1kb3QuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuY29sb24uaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuZXEuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IubGFtYmRhLmhhc2tlbGxcIiB9LCBcIjVcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnBpcGUuaGFza2VsbFwiIH0sIFwiNlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuYXJyb3cubGVmdC5oYXNrZWxsXCIgfSwgXCI3XCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5hcnJvdy5oYXNrZWxsXCIgfSwgXCI4XCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5hcnJvdy5sZWZ0LnRhaWwuaGFza2VsbFwiIH0sIFwiOVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuYXJyb3cubGVmdC50YWlsLmRvdWJsZS5oYXNrZWxsXCIgfSwgXCIxMFwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuYXJyb3cudGFpbC5oYXNrZWxsXCIgfSwgXCIxMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuYXJyb3cudGFpbC5kb3VibGUuaGFza2VsbFwiIH0sIFwiMTJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLmZvcmFsbC5oYXNrZWxsXCIgfSB9IH0sIHsgXCJtYXRjaFwiOiBcIig/eClcXG4gICg/PD1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfVxcXFxwe1N9XFxcXHB7UH0mJlteXFxcXCMsO1xcXFxbYHtdXSkgIyBSZXF1aXJlIGNsb3NpbmcgY2hhcmFjdGVyc1xcbiAgKFxcXFwjKylcXG4gICg/IVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9XFxcXHB7U31cXFxccHtQfSYmW14pLDtcXFxcXWB9XV0pICAgIyBEaXNhbGxvdyBvcGVuaW5nIGNoYXJhY3RlclwiLCBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wb3N0Zml4Lmhhc2guaGFza2VsbFwiIH0gfSB9LCB7IFwibWF0Y2hcIjogXCIoP3gpXFxuICAoPzw9W1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH1cXFxcKVxcXFx9XFxcXF1dKSAjIFJlcXVpcmUgY2xvc2luZyBjaGFyYWN0ZXJzXFxuICAoQClcXG4gICg/PVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9XFxcXChcXFxcW1xcXFx7XSkgIyBSZXF1aXJlIG9wZW5pbmcgY2hhcmFjdGVyXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLmluZml4LnRpZ2h0LmF0Lmhhc2tlbGxcIiB9IH0gfSwgeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgKD88IVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9XFxcXHB7U31cXFxccHtQfSYmW14oLDtcXFxcW2B7XV0pICAjIERpc2FsbG93IGNsb3NpbmcgY2hhcmFjdGVyc1xcbiAgKD86KH4pfCghKXwoLSl8KFxcXFwkKXwoXFxcXCRcXFxcJCkpXFxuICAoPz1bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfVxcXFwoXFxcXHtcXFxcW10pICMgUmVxdWlyZSBvcGVuaW5nIGNoYXJhY3RlciAobm9uIG9wZXJhdG9yIHN5bWJvbClcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucHJlZml4LnRpbGRlLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5iYW5nLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5taW51cy5oYXNrZWxsXCIgfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wcmVmaXguZG9sbGFyLmhhc2tlbGxcIiB9LCBcIjVcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5kb3VibGUtZG9sbGFyLmhhc2tlbGxcIiB9IH0gfV0gfSwgXCJ0eXBlX29wZXJhdG9yXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgIyBPcHRpb25hbCBwcm9tb3Rpb24gdGlja1xcbiAgICAoPzooPzwhJykoJykpP1xcbiAgIyBPcHRpb25hbCBxdWFsaWZpZWQgbmFtZVxcbiAgICAoKD86XFxcXGJbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qXFxcXC4pKilcXG4gICMgVHlwZSBvcGVyYXRvciBwcm9wZXJcXG4gICAgKD8hWyNAXT8tfSkoXFxcXCMrfFtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0rKD88IVxcXFwjKSlcXG4gICAgIygoPzpbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXWB7fV9cXFwiJ10mJlteI0BdXXxbQCNdKD8hLX0pKSspXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByb21vdGlvbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUubmFtZXNwYWNlLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJzdG9yYWdlLnR5cGUub3BlcmF0b3IuaW5maXguaGFza2VsbFwiIH0gfSB9LCB7IFwibWF0Y2hcIjogXCIoP3gpXFxuICAjIE9wdGlvbmFsIHByb21vdGlvbiB0aWNrXFxuICAgICgnKT9cXG4gICMgT3BlbmluZyBiYWNrdGlja1xcbiAgICAoXFxcXGApXFxuICAjIE9wdGlvbmFsIHF1YWxpZmllZCBuYW1lXFxuICAgICgoPzpbXFxcXHB7THV9XFxcXHB7THR9XVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10qXFxcXC4pKilcXG4gICMgVHlwZSBjb25zdHJ1Y3RvciBwcm9wZXJcXG4gICAgKFtcXFxccHtMdX1cXFxccHtMdH1dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopXFxuICAjIENsb3NpbmcgYmFja3RpY2tcXG4gICAgKGApXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByb21vdGlvbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uYmFja3RpY2suaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImVudGl0eS5uYW1lLm5hbWVzcGFjZS5oYXNrZWxsXCIgfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwic3RvcmFnZS50eXBlLmluZml4Lmhhc2tlbGxcIiB9LCBcIjVcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5iYWNrdGljay5oYXNrZWxsXCIgfSB9IH1dIH0sIFwiZm9yYWxsXCI6IHsgXCJiZWdpblwiOiBcIlxcXFxiKD88IScpKGZvcmFsbHxcXHUyMjAwKVxcXFxiKD8hJylcIiwgXCJlbmRcIjogXCIoXFxcXC4pfCgtPnxcXHUyMTkyKVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLmZvcmFsbC5oYXNrZWxsXCIgfSB9LCBcImVuZENhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5wZXJpb2QuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IuYXJyb3cuaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjY29tbWVudF9saWtlXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV92YXJpYWJsZVwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI3R5cGVfc2lnbmF0dXJlXCIgfV0gfSwgXCJzdHJpbmdfbGl0ZXJhbFwiOiB7IFwiYmVnaW5cIjogJ1wiJywgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIwXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuYmVnaW4uaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogJ1wiJywgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uc3RyaW5nLmVuZC5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJzdHJpbmcucXVvdGVkLmRvdWJsZS5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJtYXRjaFwiOiBgXFxcXFxcXFwoTlVMfFNPSHxTVFh8RVRYfEVPVHxFTlF8QUNLfEJFTHxCU3xIVHxMRnxWVHxGRnxDUnxTT3xTSXxETEV8REMxfERDMnxEQzN8REM0fE5BS3xTWU58RVRCfENBTnxFTXxTVUJ8RVNDfEZTfEdTfFJTfFVTfFNQfERFTHxbYWJmbnJ0dlxcXFxcXFxcXFxcXFwiJ1xcXFwmXSlgLCBcIm5hbWVcIjogXCJjb25zdGFudC5jaGFyYWN0ZXIuZXNjYXBlLmhhc2tlbGxcIiB9LCB7IFwibWF0Y2hcIjogXCJcXFxcXFxcXG9bMC03XSt8XFxcXFxcXFx4WzAtOUEtRmEtZl0rfFxcXFxcXFxcWzAtOV0rXCIsIFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUub2N0YWwuaGFza2VsbFwiIH0sIHsgXCJtYXRjaFwiOiBcIlxcXFxcXFxcXFxcXF5bQS1aQFxcXFxbXFxcXF1cXFxcXFxcXFxcXFxeX11cIiwgXCJuYW1lXCI6IFwiY29uc3RhbnQuY2hhcmFjdGVyLmVzY2FwZS5jb250cm9sLmhhc2tlbGxcIiB9LCB7IFwiYmVnaW5cIjogXCJcXFxcXFxcXFxcXFxzXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUuYmVnaW4uaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCJcXFxcXFxcXFwiLCBcImVuZENhcHR1cmVzXCI6IHsgXCIwXCI6IHsgXCJuYW1lXCI6IFwiY29uc3RhbnQuY2hhcmFjdGVyLmVzY2FwZS5lbmQuaGFza2VsbFwiIH0gfSwgXCJwYXR0ZXJuc1wiOiBbeyBcIm1hdGNoXCI6IFwiXFxcXFMrXCIsIFwibmFtZVwiOiBcImludmFsaWQuaWxsZWdhbC5jaGFyYWN0ZXItbm90LWFsbG93ZWQtaGVyZS5oYXNrZWxsXCIgfV0gfV0gfSwgXCJjaGFyX2xpdGVyYWxcIjogeyBcImNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuYmVnaW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUub2N0YWwuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUuaGV4YWRlY2ltYWwuaGFza2VsbFwiIH0sIFwiNVwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50LmNoYXJhY3Rlci5lc2NhcGUuY29udHJvbC5oYXNrZWxsXCIgfSwgXCI2XCI6IHsgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuZW5kLmhhc2tlbGxcIiB9IH0sIFwibWF0Y2hcIjogYCg/eClcbiAgKD88IVtcXFxccHtMbH1fXFxcXHB7THV9XFxcXHB7THR9XFxcXHB7TmR9J10pXG4gICgnKVxuICAoPzpcbiAgICBbXFxcXCAtXFxcXFtcXFxcXS1+XSAgICAgICAgICAgICAgICAgICAgICAgICAjIEJhc2ljIENoYXJcbiAgfCAoXFxcXFxcXFwoPzpOVUx8U09IfFNUWHxFVFh8RU9UfEVOUXxBQ0t8QkVMfEJTfEhUfExGfFZUfEZGfENSfFNPfFNJfERMRVxuICAgICAgIHxEQzF8REMyfERDM3xEQzR8TkFLfFNZTnxFVEJ8Q0FOfEVNfFNVQnxFU0N8RlN8R1N8UlNcbiAgICAgICB8VVN8U1B8REVMfFthYmZucnR2XFxcXFxcXFxcXFxcXCInXFxcXFxcXFwmXSkpICAgIyBFc2NhcGVzXG4gIHwgKFxcXFxcXFxcb1swLTddKykgICAgICAgICAgICAgICAgICAgICAgICAgIyBPY3RhbCBFc2NhcGVzXG4gIHwgKFxcXFxcXFxceFswLTlBLUZhLWZdKykgICAgICAgICAgICAgICAgICAgIyBIZXhhZGVjaW1hbCBFc2NhcGVzXG4gIHwgKFxcXFxcXFxcXFxcXF5bQS1aQFxcXFxbXFxcXF1cXFxcXFxcXFxcXFxeX10pICAgICAgICAgICAgICAgICAjIENvbnRyb2wgQ2hhcnNcbiAgKVxuICAoJylcbmAsIFwibmFtZVwiOiBcInN0cmluZy5xdW90ZWQuc2luZ2xlLmhhc2tlbGxcIiB9LCBcImZsb2F0X2xpdGVyYWxzXCI6IHsgXCJjb21tZW50XCI6IFwiRmxvYXRzIGFyZSBkZWNpbWFsIG9yIGhleGFkZWNpbWFsXCIsIFwibWF0Y2hcIjogXCIoP3gpXFxuICBcXFxcYig/PCEnKVxcbiAgKD86ICAjIERlY2ltYWxcXG4gICAgKFswLTldW18wLTldKlxcXFwuWzAtOV1bXzAtOV0qKD86W2VFXVstK10/WzAtOV1bXzAtOV0qKT9cXG4gICAgfFswLTldW18wLTldKltlRV1bLStdP1swLTldW18wLTldKlxcbiAgICApXFxuICB8ICAgICMgSGV4YWRlY2ltYWxcXG4gICAgKDBbeFhdXypbMC05YS1mQS1GXVtfMC05YS1mQS1GXSpcXFxcLlswLTlhLWZBLUZdW18wLTlhLWZBLUZdKig/OltwUF1bLStdP1swLTldW18wLTldKik/XFxuICAgIHwwW3hYXV8qWzAtOWEtZkEtRl1bXzAtOWEtZkEtRl0qW3BQXVstK10/WzAtOV1bXzAtOV0qXFxuICAgIClcXG4gIClcXFxcYig/IScpXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJjb25zdGFudC5udW1lcmljLmZsb2F0aW5nLmRlY2ltYWwuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm51bWVyaWMuZmxvYXRpbmcuaGV4YWRlY2ltYWwuaGFza2VsbFwiIH0gfSB9LCBcImludGVnZXJfbGl0ZXJhbHNcIjogeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgXFxcXGIoPzwhJylcXG4gICg/OlxcbiAgICAoWzAtOV1bXzAtOV0qKSAgICAgICAgICAgICAgICAgICAgIyBEZWNpbWFsIGludGVnZXJcXG4gIHwgKDBbeFhdXypbMC05YS1mQS1GXVtfMC05YS1mQS1GXSopICMgSGV4YWRlY2ltYWwgaW50ZWdlclxcbiAgfCAoMFtvT11fKlswLTddW18wLTddKikgICAgICAgICAgICAgIyBPY3RhbCBpbnRlZ2VyXFxuICB8ICgwW2JCXV8qWzAxXVtfMDFdKikgICAgICAgICAgICAgICAjIEJpbmFyeSBpbnRlZ2VyXFxuICApXFxuICBcXFxcYig/IScpXCIsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJjb25zdGFudC5udW1lcmljLmludGVncmFsLmRlY2ltYWwuaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm51bWVyaWMuaW50ZWdyYWwuaGV4YWRlY2ltYWwuaGFza2VsbFwiIH0sIFwiM1wiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm51bWVyaWMuaW50ZWdyYWwub2N0YWwuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcImNvbnN0YW50Lm51bWVyaWMuaW50ZWdyYWwuYmluYXJ5Lmhhc2tlbGxcIiB9IH0gfSwgXCJudW1lcmljX2xpdGVyYWxzXCI6IHsgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjZmxvYXRfbGl0ZXJhbHNcIiB9LCB7IFwiaW5jbHVkZVwiOiBcIiNpbnRlZ2VyX2xpdGVyYWxzXCIgfV0gfSwgXCJmZmlcIjogeyBcImJlZ2luXCI6IFwiXihcXFxccyopKGZvcmVpZ24pXFxcXHMrKGltcG9ydHxleHBvcnQpXFxcXHMrXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMlwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuZm9yZWlnbi5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vdGhlci4kMy5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJtZXRhLiQzLmZvcmVpZ24uaGFza2VsbFwiLCBcImVuZFwiOiBcIig/eCkgIyBEZXRlY3QgZW5kIG9mIEZGSSBibG9jayBieSBkZWNyZWFzaW5nIGluZGVudGF0aW9uOlxcbiAgKD89XFxcXH18OykgICAgICAgIyBFeHBsaWNpdCBpbmRlbnRhdGlvblxcbiAgfF4oPyEgICAgICAgICAgIyBJbXBsaWNpdCBpbmRlbnRhdGlvbjogZW5kIG1hdGNoIG9uIG5ld2xpbmUgKnVubGVzcyogdGhlIG5ldyBsaW5lIGlzIGVpdGhlcjpcXG4gICAgICBcXFxcMVxcXFxzK1xcXFxTICAgICMgLSBtb3JlIGluZGVudGVkLCBvclxcbiAgICB8IFxcXFxzKiAgICAgICAgIyAtIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGZvbGxvd2VkIGJ5OlxcbiAgICAgICg/OiAkICAgICAgIyAgIC0gdGhlIGVuZCBvZiB0aGUgbGluZSAoaS5lLiBlbXB0eSBsaW5lKSwgb3JcXG4gICAgICB8XFxcXHstW15AXSAgICMgICAtIHRoZSBzdGFydCBvZiBhIGJsb2NrIGNvbW1lbnQsIG9yXFxuICAgICAgfC0tKyAgICAgICAjICAgLSB0aGUgc3RhcnQgb2YgYSBzaW5nbGUtbGluZSBjb21tZW50LlxcbiAgICAgICAgICg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxde31gX1xcXCInXV0pLiokKSAjIG5vbi1zeW1ib2xcXG4gICAgICAgICAgICAgICAgICMgVGhlIGRvdWJsZSBkYXNoIG1heSBub3QgYmUgZm9sbG93ZWQgYnkgb3RoZXIgb3BlcmF0b3IgY2hhcmFjdGVyc1xcbiAgICAgICAgICAgICAgICAgIyAodGhlbiBpdCB3b3VsZCBiZSBhbiBvcGVyYXRvciwgbm90IGEgY29tbWVudClcXG4gICAgKVxcblwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwibWF0Y2hcIjogXCJcXFxcYig/PCEnKShjY2FsbHxjcGx1c3BsdXN8ZG90bmV0fGp2bXxzdGRjYWxsfHByaW18Y2FwaSlcXFxccytcIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuY2FsbGluZy1jb252ZW50aW9uLiQxLmhhc2tlbGxcIiB9IH0gfSwgeyBcImJlZ2luXCI6IGAoPz1cIil8KD89XFxcXGIoPzwhJykoW1xcXFxwe0xsfV9dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopXFxcXGIoPyEnKSlgLCBcImVuZFwiOiBcIig/PSg6OnxcXHUyMjM3KSg/IVtcXFxccHtTfVxcXFxwe1B9JiZbXigpLDtcXFxcW1xcXFxdYHt9X1xcXCInXV0pKVwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiNjb21tZW50X2xpa2VcIiB9LCB7IFwibWF0Y2hcIjogYCg/eClcbiAgXFxcXGIoPzwhJykoc2FmZXx1bnNhZmV8aW50ZXJydXB0aWJsZSlcXFxcYig/IScpXG4gIFxcXFxzKlxuICAoXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIik/XG4gIFxcXFxzKlxuICAoPzpcbiAgICAoPzpcXFxcYig/PCEnJykoW1xcXFxwe0xsfV9dW1xcXFxwe0xsfV9cXFxccHtMdX1cXFxccHtMdH1cXFxccHtOZH0nXSopXFxcXGIoPyEnKSlcbiAgIHwoPzpcXFxcKFxcXFxzKig/IS0tK1xcXFwpKShbXFxcXHB7U31cXFxccHtQfSYmW14oKSw7XFxcXFtcXFxcXVxcYHt9X1wiJ11dKylcXFxccypcXFxcKSlcbiAgKVxuYCwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3RoZXIuc2FmZXR5LiQxLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5mb3JlaWduLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjc3RyaW5nX2xpdGVyYWxcIiB9XSB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5oYXNrZWxsXCIgfSwgXCI0XCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUuZnVuY3Rpb24uaW5maXguaGFza2VsbFwiIH0gfSB9LCB7IFwibWF0Y2hcIjogYCg/eClcbiAgXFxcXGIoPzwhJykoc2FmZXx1bnNhZmV8aW50ZXJydXB0aWJsZSlcXFxcYig/IScpXG4gIFxcXFxzKlxuICAoXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIik/XG4gIFxcXFxzKiRcbmAsIFwiY2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm90aGVyLnNhZmV0eS4kMS5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUuZm9yZWlnbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3N0cmluZ19saXRlcmFsXCIgfV0gfSB9IH0sIHsgXCJtYXRjaFwiOiAnKD94KVxcbiAgXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicsIFwiY2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5mb3JlaWduLmhhc2tlbGxcIiwgXCJwYXR0ZXJuc1wiOiBbeyBcImluY2x1ZGVcIjogXCIjc3RyaW5nX2xpdGVyYWxcIiB9XSB9IH0gfSwgeyBcIm1hdGNoXCI6IFwiKD94KVxcbiAgICg/OlxcXFxiKD88IScnKShbXFxcXHB7TGx9X11bXFxcXHB7TGx9X1xcXFxwe0x1fVxcXFxwe0x0fVxcXFxwe05kfSddKilcXFxcYig/IScpKVxcbiAgfCg/OihcXFxcKClcXFxccyooPyEtLStcXFxcKSkoW1xcXFxwe1N9XFxcXHB7UH0mJlteKCksO1xcXFxbXFxcXF1ge31fXFxcIiddXSspXFxcXHMqKFxcXFwpKSlcXG5cIiwgXCJjYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImVudGl0eS5uYW1lLmZ1bmN0aW9uLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5wYXJlbi5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUuZnVuY3Rpb24uaW5maXguaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLnBhcmVuLmhhc2tlbGxcIiB9IH0gfV0gfSwgeyBcImluY2x1ZGVcIjogXCIjZG91YmxlX2NvbG9uXCIgfSwgeyBcImluY2x1ZGVcIjogXCIjdHlwZV9zaWduYXR1cmVcIiB9XSB9LCBcImlubGluZV9waGFzZVwiOiB7IFwiYmVnaW5cIjogXCJcXFxcW1wiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5icmFja2V0Lmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiXFxcXF1cIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmJyYWNrZXQuaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwibWV0YS5pbmxpbmluZy1waGFzZS5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJtYXRjaFwiOiBcIn5cIiwgXCJuYW1lXCI6IFwicHVuY3R1YXRpb24udGlsZGUuaGFza2VsbFwiIH0sIHsgXCJpbmNsdWRlXCI6IFwiI2ludGVnZXJfbGl0ZXJhbHNcIiB9LCB7IFwibWF0Y2hcIjogXCJcXFxcdypcIiwgXCJuYW1lXCI6IFwiaW52YWxpZFwiIH1dIH0sIFwicXVhc2lfcXVvdGVcIjogeyBcInBhdHRlcm5zXCI6IFt7IFwiYmVnaW5cIjogXCIoP3gpXFxuICAoXFxcXFspXFxuICAoZXxkfHApP1xcbiAgKFxcXFx8XFxcXHw/KVwiLCBcImJlZ2luQ2FwdHVyZXNcIjogeyBcIjFcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnF1YXNpLXF1b3RhdGlvbi5iZWdpbi5oYXNrZWxsXCIgfSwgXCIyXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUucXVhc2ktcXVvdGVyLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnF1YXNpLXF1b3RhdGlvbi5iZWdpbi5oYXNrZWxsXCIgfSB9LCBcImVuZFwiOiBcIlxcXFwzXFxcXF1cIiwgXCJlbmRDYXB0dXJlc1wiOiB7IFwiMFwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucXVhc2ktcXVvdGF0aW9uLmVuZC5oYXNrZWxsXCIgfSB9LCBcIm5hbWVcIjogXCJtZXRhLnF1YXNpLXF1b3RhdGlvbi5oYXNrZWxsXCIsIFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiJHNlbGZcIiB9XSB9LCB7IFwiYmVnaW5cIjogXCIoP3gpXFxuICAoXFxcXFspXFxuICAodClcXG4gIChcXFxcfFxcXFx8PylcIiwgXCJiZWdpbkNhcHR1cmVzXCI6IHsgXCIxXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5xdWFzaS1xdW90YXRpb24uYmVnaW4uaGFza2VsbFwiIH0sIFwiMlwiOiB7IFwibmFtZVwiOiBcImVudGl0eS5uYW1lLnF1YXNpLXF1b3Rlci5oYXNrZWxsXCIgfSwgXCIzXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5xdWFzaS1xdW90YXRpb24uYmVnaW4uaGFza2VsbFwiIH0gfSwgXCJlbmRcIjogXCJcXFxcM1xcXFxdXCIsIFwiZW5kQ2FwdHVyZXNcIjogeyBcIjBcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnF1YXNpLXF1b3RhdGlvbi5lbmQuaGFza2VsbFwiIH0gfSwgXCJuYW1lXCI6IFwibWV0YS5xdWFzaS1xdW90YXRpb24uaGFza2VsbFwiLCBcInBhdHRlcm5zXCI6IFt7IFwiaW5jbHVkZVwiOiBcIiN0eXBlX3NpZ25hdHVyZVwiIH1dIH0sIHsgXCJiZWdpblwiOiBcIig/eClcXG4gIChcXFxcWylcXG4gICg/OihcXFxcJFxcXFwkKXwoXFxcXCQpKT9cXG4gICgoPzpbXlxcXFxzXFxcXHB7U31cXFxccHtQfV18W1xcXFwuJ19dKSopXFxuICAoXFxcXHxcXFxcfD8pXCIsIFwiYmVnaW5DYXB0dXJlc1wiOiB7IFwiMVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucXVhc2ktcXVvdGF0aW9uLmJlZ2luLmhhc2tlbGxcIiB9LCBcIjJcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5kb3VibGUtZG9sbGFyLmhhc2tlbGxcIiB9LCBcIjNcIjogeyBcIm5hbWVcIjogXCJrZXl3b3JkLm9wZXJhdG9yLnByZWZpeC5kb2xsYXIuaGFza2VsbFwiIH0sIFwiNFwiOiB7IFwicGF0dGVybnNcIjogW3sgXCJpbmNsdWRlXCI6IFwiI3F1YWxpZmllclwiIH1dLCBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS5xdWFzaS1xdW90ZXIuaGFza2VsbFwiIH0sIFwiNVwiOiB7IFwibmFtZVwiOiBcImtleXdvcmQub3BlcmF0b3IucXVhc2ktcXVvdGF0aW9uLmJlZ2luLmhhc2tlbGxcIiB9IH0sIFwiZW5kXCI6IFwiXFxcXDVcXFxcXVwiLCBcImVuZENhcHR1cmVzXCI6IHsgXCIwXCI6IHsgXCJuYW1lXCI6IFwia2V5d29yZC5vcGVyYXRvci5xdWFzaS1xdW90YXRpb24uZW5kLmhhc2tlbGxcIiB9IH0sIFwibmFtZVwiOiBcIm1ldGEucXVhc2ktcXVvdGF0aW9uLmhhc2tlbGxcIiB9XSB9IH0sIFwic2NvcGVOYW1lXCI6IFwic291cmNlLmhhc2tlbGxcIiwgXCJ1dWlkXCI6IFwiNUMwMzQ2NzUtMUY2RC00OTdFLTgwNzMtMzY5RDM3RTJGRDdEXCIsIFwiZGlzcGxheU5hbWVcIjogXCJIYXNrZWxsXCIsIFwiYWxpYXNlc1wiOiBbXCJoc1wiXSB9KTtcbnZhciBoYXNrZWxsID0gW1xuICBsYW5nXG5dO1xuXG5leHBvcnQgeyBoYXNrZWxsIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/shikiji/dist/langs/haskell.mjs\n"));

/***/ })

}]);