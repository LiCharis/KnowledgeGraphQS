/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/highlight.js";
exports.ids = ["vendor-chunks/highlight.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/highlight.js/lib/core.js":
/*!***********************************************!*\
  !*** ./node_modules/highlight.js/lib/core.js ***!
  \***********************************************/
/***/ ((module) => {

eval("function deepFreeze(obj) {\n    if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function() {\n            throw new Error(\"map is read-only\");\n        };\n    } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function() {\n            throw new Error(\"set is read-only\");\n        };\n    }\n    // Freeze self\n    Object.freeze(obj);\n    Object.getOwnPropertyNames(obj).forEach(function(name) {\n        var prop = obj[name];\n        // Freeze prop if it is an object\n        if (typeof prop == \"object\" && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n        }\n    });\n    return obj;\n}\nvar deepFreezeEs6 = deepFreeze;\nvar _default = deepFreeze;\ndeepFreezeEs6.default = _default;\nclass Response {\n    /**\n   * @param {CompiledMode} mode\n   */ constructor(mode){\n        // eslint-disable-next-line no-undefined\n        if (mode.data === undefined) mode.data = {};\n        this.data = mode.data;\n    }\n    ignoreMatch() {\n        this.ignore = true;\n    }\n}\n/**\n * @param {string} value\n * @returns {string}\n */ function escapeHTML(value) {\n    return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n}\n/**\n * performs a shallow merge of multiple objects into one\n *\n * @template T\n * @param {T} original\n * @param {Record<string,any>[]} objects\n * @returns {T} a single new object\n */ function inherit(original, ...objects) {\n    /** @type Record<string,any> */ const result = Object.create(null);\n    for(const key in original){\n        result[key] = original[key];\n    }\n    objects.forEach(function(obj) {\n        for(const key in obj){\n            result[key] = obj[key];\n        }\n    });\n    return /** @type {T} */ result;\n}\n/**\n * @typedef {object} Renderer\n * @property {(text: string) => void} addText\n * @property {(node: Node) => void} openNode\n * @property {(node: Node) => void} closeNode\n * @property {() => string} value\n */ /** @typedef {{kind?: string, sublanguage?: boolean}} Node */ /** @typedef {{walk: (r: Renderer) => void}} Tree */ /** */ const SPAN_CLOSE = \"</span>\";\n/**\n * Determines if a node needs to be wrapped in <span>\n *\n * @param {Node} node */ const emitsWrappingTags = (node)=>{\n    return !!node.kind;\n};\n/** @type {Renderer} */ class HTMLRenderer {\n    /**\n   * Creates a new HTMLRenderer\n   *\n   * @param {Tree} parseTree - the parse tree (must support `walk` API)\n   * @param {{classPrefix: string}} options\n   */ constructor(parseTree, options){\n        this.buffer = \"\";\n        this.classPrefix = options.classPrefix;\n        parseTree.walk(this);\n    }\n    /**\n   * Adds texts to the output stream\n   *\n   * @param {string} text */ addText(text) {\n        this.buffer += escapeHTML(text);\n    }\n    /**\n   * Adds a node open to the output stream (if needed)\n   *\n   * @param {Node} node */ openNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        let className = node.kind;\n        if (!node.sublanguage) {\n            className = `${this.classPrefix}${className}`;\n        }\n        this.span(className);\n    }\n    /**\n   * Adds a node close to the output stream (if needed)\n   *\n   * @param {Node} node */ closeNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        this.buffer += SPAN_CLOSE;\n    }\n    /**\n   * returns the accumulated buffer\n  */ value() {\n        return this.buffer;\n    }\n    // helpers\n    /**\n   * Builds a span element\n   *\n   * @param {string} className */ span(className) {\n        this.buffer += `<span class=\"${className}\">`;\n    }\n}\n/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */ /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */ /**  */ class TokenTree {\n    constructor(){\n        /** @type DataNode */ this.rootNode = {\n            children: []\n        };\n        this.stack = [\n            this.rootNode\n        ];\n    }\n    get top() {\n        return this.stack[this.stack.length - 1];\n    }\n    get root() {\n        return this.rootNode;\n    }\n    /** @param {Node} node */ add(node) {\n        this.top.children.push(node);\n    }\n    /** @param {string} kind */ openNode(kind) {\n        /** @type Node */ const node = {\n            kind,\n            children: []\n        };\n        this.add(node);\n        this.stack.push(node);\n    }\n    closeNode() {\n        if (this.stack.length > 1) {\n            return this.stack.pop();\n        }\n        // eslint-disable-next-line no-undefined\n        return undefined;\n    }\n    closeAllNodes() {\n        while(this.closeNode());\n    }\n    toJSON() {\n        return JSON.stringify(this.rootNode, null, 4);\n    }\n    /**\n   * @typedef { import(\"./html_renderer\").Renderer } Renderer\n   * @param {Renderer} builder\n   */ walk(builder) {\n        // this does not\n        return this.constructor._walk(builder, this.rootNode);\n    // this works\n    // return TokenTree._walk(builder, this.rootNode);\n    }\n    /**\n   * @param {Renderer} builder\n   * @param {Node} node\n   */ static _walk(builder, node) {\n        if (typeof node === \"string\") {\n            builder.addText(node);\n        } else if (node.children) {\n            builder.openNode(node);\n            node.children.forEach((child)=>this._walk(builder, child));\n            builder.closeNode(node);\n        }\n        return builder;\n    }\n    /**\n   * @param {Node} node\n   */ static _collapse(node) {\n        if (typeof node === \"string\") return;\n        if (!node.children) return;\n        if (node.children.every((el)=>typeof el === \"string\")) {\n            // node.text = node.children.join(\"\");\n            // delete node.children;\n            node.children = [\n                node.children.join(\"\")\n            ];\n        } else {\n            node.children.forEach((child)=>{\n                TokenTree._collapse(child);\n            });\n        }\n    }\n}\n/**\n  Currently this is all private API, but this is the minimal API necessary\n  that an Emitter must implement to fully support the parser.\n\n  Minimal interface:\n\n  - addKeyword(text, kind)\n  - addText(text)\n  - addSublanguage(emitter, subLanguageName)\n  - finalize()\n  - openNode(kind)\n  - closeNode()\n  - closeAllNodes()\n  - toHTML()\n\n*/ /**\n * @implements {Emitter}\n */ class TokenTreeEmitter extends TokenTree {\n    /**\n   * @param {*} options\n   */ constructor(options){\n        super();\n        this.options = options;\n    }\n    /**\n   * @param {string} text\n   * @param {string} kind\n   */ addKeyword(text, kind) {\n        if (text === \"\") {\n            return;\n        }\n        this.openNode(kind);\n        this.addText(text);\n        this.closeNode();\n    }\n    /**\n   * @param {string} text\n   */ addText(text) {\n        if (text === \"\") {\n            return;\n        }\n        this.add(text);\n    }\n    /**\n   * @param {Emitter & {root: DataNode}} emitter\n   * @param {string} name\n   */ addSublanguage(emitter, name) {\n        /** @type DataNode */ const node = emitter.root;\n        node.kind = name;\n        node.sublanguage = true;\n        this.add(node);\n    }\n    toHTML() {\n        const renderer = new HTMLRenderer(this, this.options);\n        return renderer.value();\n    }\n    finalize() {\n        return true;\n    }\n}\n/**\n * @param {string} value\n * @returns {RegExp}\n * */ function escape(value) {\n    return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"m\");\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */ function either(...args) {\n    const joined = \"(\" + args.map((x)=>source(x)).join(\"|\") + \")\";\n    return joined;\n}\n/**\n * @param {RegExp} re\n * @returns {number}\n */ function countMatchGroups(re) {\n    return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n}\n/**\n * Does lexeme start with a regular expression match at the beginning\n * @param {RegExp} re\n * @param {string} lexeme\n */ function startsWith(re, lexeme) {\n    const match = re && re.exec(lexeme);\n    return match && match.index === 0;\n}\n// join logically computes regexps.join(separator), but fixes the\n// backreferences so they continue to match.\n// it also places each individual regular expression into it's own\n// match group, keeping track of the sequencing of those match groups\n// is currently an exercise for the caller. :-)\n/**\n * @param {(string | RegExp)[]} regexps\n * @param {string} separator\n * @returns {string}\n */ function join(regexps, separator = \"|\") {\n    // backreferenceRe matches an open parenthesis or backreference. To avoid\n    // an incorrect parse, it additionally matches the following:\n    // - [...] elements, where the meaning of parentheses and escapes change\n    // - other escape sequences, so we do not misparse escape sequences as\n    //   interesting elements\n    // - non-matching or lookahead parentheses, which do not capture. These\n    //   follow the '(' with a '?'.\n    const backreferenceRe = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n    let numCaptures = 0;\n    let ret = \"\";\n    for(let i = 0; i < regexps.length; i++){\n        numCaptures += 1;\n        const offset = numCaptures;\n        let re = source(regexps[i]);\n        if (i > 0) {\n            ret += separator;\n        }\n        ret += \"(\";\n        while(re.length > 0){\n            const match = backreferenceRe.exec(re);\n            if (match == null) {\n                ret += re;\n                break;\n            }\n            ret += re.substring(0, match.index);\n            re = re.substring(match.index + match[0].length);\n            if (match[0][0] === \"\\\\\" && match[1]) {\n                // Adjust the backreference.\n                ret += \"\\\\\" + String(Number(match[1]) + offset);\n            } else {\n                ret += match[0];\n                if (match[0] === \"(\") {\n                    numCaptures++;\n                }\n            }\n        }\n        ret += \")\";\n    }\n    return ret;\n}\n// Common regexps\nconst IDENT_RE = \"[a-zA-Z]\\\\w*\";\nconst UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\nconst NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\nconst C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\"; // 0x..., 0..., decimal, float\nconst BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\"; // 0b...\nconst RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/ const SHEBANG = (opts = {})=>{\n    const beginShebang = /^#![ ]*\\//;\n    if (opts.binary) {\n        opts.begin = concat(beginShebang, /.*\\b/, opts.binary, /\\b.*/);\n    }\n    return inherit({\n        className: \"meta\",\n        begin: beginShebang,\n        end: /$/,\n        relevance: 0,\n        /** @type {ModeCallback} */ \"on:begin\": (m, resp)=>{\n            if (m.index !== 0) resp.ignoreMatch();\n        }\n    }, opts);\n};\n// Common modes\nconst BACKSLASH_ESCAPE = {\n    begin: \"\\\\\\\\[\\\\s\\\\S]\",\n    relevance: 0\n};\nconst APOS_STRING_MODE = {\n    className: \"string\",\n    begin: \"'\",\n    end: \"'\",\n    illegal: \"\\\\n\",\n    contains: [\n        BACKSLASH_ESCAPE\n    ]\n};\nconst QUOTE_STRING_MODE = {\n    className: \"string\",\n    begin: '\"',\n    end: '\"',\n    illegal: \"\\\\n\",\n    contains: [\n        BACKSLASH_ESCAPE\n    ]\n};\nconst PHRASAL_WORDS_MODE = {\n    begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */ const COMMENT = function(begin, end, modeOptions = {}) {\n    const mode = inherit({\n        className: \"comment\",\n        begin,\n        end,\n        contains: []\n    }, modeOptions);\n    mode.contains.push(PHRASAL_WORDS_MODE);\n    mode.contains.push({\n        className: \"doctag\",\n        begin: \"(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\",\n        relevance: 0\n    });\n    return mode;\n};\nconst C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\nconst C_BLOCK_COMMENT_MODE = COMMENT(\"/\\\\*\", \"\\\\*/\");\nconst HASH_COMMENT_MODE = COMMENT(\"#\", \"$\");\nconst NUMBER_MODE = {\n    className: \"number\",\n    begin: NUMBER_RE,\n    relevance: 0\n};\nconst C_NUMBER_MODE = {\n    className: \"number\",\n    begin: C_NUMBER_RE,\n    relevance: 0\n};\nconst BINARY_NUMBER_MODE = {\n    className: \"number\",\n    begin: BINARY_NUMBER_RE,\n    relevance: 0\n};\nconst CSS_NUMBER_MODE = {\n    className: \"number\",\n    begin: NUMBER_RE + \"(\" + \"%|em|ex|ch|rem\" + \"|vw|vh|vmin|vmax\" + \"|cm|mm|in|pt|pc|px\" + \"|deg|grad|rad|turn\" + \"|s|ms\" + \"|Hz|kHz\" + \"|dpi|dpcm|dppx\" + \")?\",\n    relevance: 0\n};\nconst REGEXP_MODE = {\n    // this outer rule makes sure we actually have a WHOLE regex and not simply\n    // an expression such as:\n    //\n    //     3 / something\n    //\n    // (which will then blow up when regex's `illegal` sees the newline)\n    begin: /(?=\\/[^/\\n]*\\/)/,\n    contains: [\n        {\n            className: \"regexp\",\n            begin: /\\//,\n            end: /\\/[gimuy]*/,\n            illegal: /\\n/,\n            contains: [\n                BACKSLASH_ESCAPE,\n                {\n                    begin: /\\[/,\n                    end: /\\]/,\n                    relevance: 0,\n                    contains: [\n                        BACKSLASH_ESCAPE\n                    ]\n                }\n            ]\n        }\n    ]\n};\nconst TITLE_MODE = {\n    className: \"title\",\n    begin: IDENT_RE,\n    relevance: 0\n};\nconst UNDERSCORE_TITLE_MODE = {\n    className: \"title\",\n    begin: UNDERSCORE_IDENT_RE,\n    relevance: 0\n};\nconst METHOD_GUARD = {\n    // excludes method names from keyword processing\n    begin: \"\\\\.\\\\s*\" + UNDERSCORE_IDENT_RE,\n    relevance: 0\n};\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */ const END_SAME_AS_BEGIN = function(mode) {\n    return Object.assign(mode, {\n        /** @type {ModeCallback} */ \"on:begin\": (m, resp)=>{\n            resp.data._beginMatch = m[1];\n        },\n        /** @type {ModeCallback} */ \"on:end\": (m, resp)=>{\n            if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();\n        }\n    });\n};\nvar MODES = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    IDENT_RE: IDENT_RE,\n    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n    NUMBER_RE: NUMBER_RE,\n    C_NUMBER_RE: C_NUMBER_RE,\n    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n    RE_STARTERS_RE: RE_STARTERS_RE,\n    SHEBANG: SHEBANG,\n    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n    APOS_STRING_MODE: APOS_STRING_MODE,\n    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n    COMMENT: COMMENT,\n    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n    NUMBER_MODE: NUMBER_MODE,\n    C_NUMBER_MODE: C_NUMBER_MODE,\n    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n    CSS_NUMBER_MODE: CSS_NUMBER_MODE,\n    REGEXP_MODE: REGEXP_MODE,\n    TITLE_MODE: TITLE_MODE,\n    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,\n    METHOD_GUARD: METHOD_GUARD,\n    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN\n});\n// Grammar extensions / plugins\n// See: https://github.com/highlightjs/highlight.js/issues/2833\n// Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n// without requiring any underlying changes to the compiler internals.\n// `compileMatch` being the perfect small example of now allowing a grammar\n// author to write `match` when they desire to match a single expression rather\n// than being forced to use `begin`.  The extension then just moves `match` into\n// `begin` when it runs.  Ie, no features have been added, but we've just made\n// the experience of writing (and reading grammars) a little bit nicer.\n// ------\n// TODO: We need negative look-behind support to do this properly\n/**\n * Skip a match if it has a preceding dot\n *\n * This is used for `beginKeywords` to prevent matching expressions such as\n * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n * @param {RegExpMatchArray} match\n * @param {CallbackResponse} response\n */ function skipIfhasPrecedingDot(match, response) {\n    const before = match.input[match.index - 1];\n    if (before === \".\") {\n        response.ignoreMatch();\n    }\n}\n/**\n * `beginKeywords` syntactic sugar\n * @type {CompilerExt}\n */ function beginKeywords(mode, parent) {\n    if (!parent) return;\n    if (!mode.beginKeywords) return;\n    // for languages with keywords that include non-word characters checking for\n    // a word boundary is not sufficient, so instead we check for a word boundary\n    // or whitespace - this does no harm in any case since our keyword engine\n    // doesn't allow spaces in keywords anyways and we still check for the boundary\n    // first\n    mode.begin = \"\\\\b(\" + mode.beginKeywords.split(\" \").join(\"|\") + \")(?!\\\\.)(?=\\\\b|\\\\s)\";\n    mode.__beforeBegin = skipIfhasPrecedingDot;\n    mode.keywords = mode.keywords || mode.beginKeywords;\n    delete mode.beginKeywords;\n}\n/**\n * Allow `illegal` to contain an array of illegal values\n * @type {CompilerExt}\n */ function compileIllegal(mode, _parent) {\n    if (!Array.isArray(mode.illegal)) return;\n    mode.illegal = either(...mode.illegal);\n}\n/**\n * `match` to match a single expression for readability\n * @type {CompilerExt}\n */ function compileMatch(mode, _parent) {\n    if (!mode.match) return;\n    if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n    mode.begin = mode.match;\n    delete mode.match;\n}\n/**\n * provides the default 1 relevance to all modes\n * @type {CompilerExt}\n */ function compileRelevance(mode, _parent) {\n    // eslint-disable-next-line no-undefined\n    if (mode.relevance === undefined) mode.relevance = 1;\n}\n// keywords that should have no default relevance value\nconst COMMON_KEYWORDS = [\n    \"of\",\n    \"and\",\n    \"for\",\n    \"in\",\n    \"not\",\n    \"or\",\n    \"if\",\n    \"then\",\n    \"parent\",\n    \"list\",\n    \"value\" // common variable name\n];\n/**\n * Given raw keywords from a language definition, compile them.\n *\n * @param {string | Record<string,string>} rawKeywords\n * @param {boolean} caseInsensitive\n */ function compileKeywords(rawKeywords, caseInsensitive) {\n    /** @type KeywordDict */ const compiledKeywords = {};\n    if (typeof rawKeywords === \"string\") {\n        splitAndCompile(\"keyword\", rawKeywords);\n    } else {\n        Object.keys(rawKeywords).forEach(function(className) {\n            splitAndCompile(className, rawKeywords[className]);\n        });\n    }\n    return compiledKeywords;\n    // ---\n    /**\n   * Compiles an individual list of keywords\n   *\n   * Ex: \"for if when while|5\"\n   *\n   * @param {string} className\n   * @param {string} keywordList\n   */ function splitAndCompile(className, keywordList) {\n        if (caseInsensitive) {\n            keywordList = keywordList.toLowerCase();\n        }\n        keywordList.split(\" \").forEach(function(keyword) {\n            const pair = keyword.split(\"|\");\n            compiledKeywords[pair[0]] = [\n                className,\n                scoreForKeyword(pair[0], pair[1])\n            ];\n        });\n    }\n}\n/**\n * Returns the proper score for a given keyword\n *\n * Also takes into account comment keywords, which will be scored 0 UNLESS\n * another score has been manually assigned.\n * @param {string} keyword\n * @param {string} [providedScore]\n */ function scoreForKeyword(keyword, providedScore) {\n    // manual scores always win over common keywords\n    // so you can force a score of 1 if you really insist\n    if (providedScore) {\n        return Number(providedScore);\n    }\n    return commonKeyword(keyword) ? 0 : 1;\n}\n/**\n * Determines if a given keyword is common or not\n *\n * @param {string} keyword */ function commonKeyword(keyword) {\n    return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n}\n// compilation\n/**\n * Compiles a language definition result\n *\n * Given the raw result of a language definition (Language), compiles this so\n * that it is ready for highlighting code.\n * @param {Language} language\n * @param {{plugins: HLJSPlugin[]}} opts\n * @returns {CompiledLanguage}\n */ function compileLanguage(language, { plugins }) {\n    /**\n   * Builds a regex with the case sensativility of the current language\n   *\n   * @param {RegExp | string} value\n   * @param {boolean} [global]\n   */ function langRe(value, global) {\n        return new RegExp(source(value), \"m\" + (language.case_insensitive ? \"i\" : \"\") + (global ? \"g\" : \"\"));\n    }\n    /**\n    Stores multiple regular expressions and allows you to quickly search for\n    them all in a string simultaneously - returning the first match.  It does\n    this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n    and joined by `|` - using match groups to track position.  When a match is\n    found checking which position in the array has content allows us to figure\n    out which of the original regexes / match groups triggered the match.\n\n    The match object itself (the result of `Regex.exec`) is returned but also\n    enhanced by merging in any meta-data that was registered with the regex.\n    This is how we keep track of which mode matched, and what type of rule\n    (`illegal`, `begin`, end, etc).\n  */ class MultiRegex {\n        constructor(){\n            this.matchIndexes = {};\n            // @ts-ignore\n            this.regexes = [];\n            this.matchAt = 1;\n            this.position = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n            opts.position = this.position++;\n            // @ts-ignore\n            this.matchIndexes[this.matchAt] = opts;\n            this.regexes.push([\n                opts,\n                re\n            ]);\n            this.matchAt += countMatchGroups(re) + 1;\n        }\n        compile() {\n            if (this.regexes.length === 0) {\n                // avoids the need to check length every time exec is called\n                // @ts-ignore\n                this.exec = ()=>null;\n            }\n            const terminators = this.regexes.map((el)=>el[1]);\n            this.matcherRe = langRe(join(terminators), true);\n            this.lastIndex = 0;\n        }\n        /** @param {string} s */ exec(s) {\n            this.matcherRe.lastIndex = this.lastIndex;\n            const match = this.matcherRe.exec(s);\n            if (!match) {\n                return null;\n            }\n            // eslint-disable-next-line no-undefined\n            const i = match.findIndex((el, i)=>i > 0 && el !== undefined);\n            // @ts-ignore\n            const matchData = this.matchIndexes[i];\n            // trim off any earlier non-relevant match groups (ie, the other regex\n            // match groups that make up the multi-matcher)\n            match.splice(0, i);\n            return Object.assign(match, matchData);\n        }\n    }\n    /*\n    Created to solve the key deficiently with MultiRegex - there is no way to\n    test for multiple matches at a single location.  Why would we need to do\n    that?  In the future a more dynamic engine will allow certain matches to be\n    ignored.  An example: if we matched say the 3rd regex in a large group but\n    decided to ignore it - we'd need to started testing again at the 4th\n    regex... but MultiRegex itself gives us no real way to do that.\n\n    So what this class creates MultiRegexs on the fly for whatever search\n    position they are needed.\n\n    NOTE: These additional MultiRegex objects are created dynamically.  For most\n    grammars most of the time we will never actually need anything more than the\n    first MultiRegex - so this shouldn't have too much overhead.\n\n    Say this is our search group, and we match regex3, but wish to ignore it.\n\n      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n\n    What we need is a new MultiRegex that only includes the remaining\n    possibilities:\n\n      regex4 | regex5                               ' ie, startAt = 3\n\n    This class wraps all that complexity up in a simple API... `startAt` decides\n    where in the array of expressions to start doing the matching. It\n    auto-increments, so if a match is found at position 2, then startAt will be\n    set to 3.  If the end is reached startAt will return to 0.\n\n    MOST of the time the parser will be setting startAt manually to 0.\n  */ class ResumableMultiRegex {\n        constructor(){\n            // @ts-ignore\n            this.rules = [];\n            // @ts-ignore\n            this.multiRegexes = [];\n            this.count = 0;\n            this.lastIndex = 0;\n            this.regexIndex = 0;\n        }\n        // @ts-ignore\n        getMatcher(index) {\n            if (this.multiRegexes[index]) return this.multiRegexes[index];\n            const matcher = new MultiRegex();\n            this.rules.slice(index).forEach(([re, opts])=>matcher.addRule(re, opts));\n            matcher.compile();\n            this.multiRegexes[index] = matcher;\n            return matcher;\n        }\n        resumingScanAtSamePosition() {\n            return this.regexIndex !== 0;\n        }\n        considerAll() {\n            this.regexIndex = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n            this.rules.push([\n                re,\n                opts\n            ]);\n            if (opts.type === \"begin\") this.count++;\n        }\n        /** @param {string} s */ exec(s) {\n            const m = this.getMatcher(this.regexIndex);\n            m.lastIndex = this.lastIndex;\n            let result = m.exec(s);\n            // The following is because we have no easy way to say \"resume scanning at the\n            // existing position but also skip the current rule ONLY\". What happens is\n            // all prior rules are also skipped which can result in matching the wrong\n            // thing. Example of matching \"booger\":\n            // our matcher is [string, \"booger\", number]\n            //\n            // ....booger....\n            // if \"booger\" is ignored then we'd really need a regex to scan from the\n            // SAME position for only: [string, number] but ignoring \"booger\" (if it\n            // was the first match), a simple resume would scan ahead who knows how\n            // far looking only for \"number\", ignoring potential string matches (or\n            // future \"booger\" matches that might be valid.)\n            // So what we do: We execute two matchers, one resuming at the same\n            // position, but the second full matcher starting at the position after:\n            //     /--- resume first regex match here (for [number])\n            //     |/---- full match here for [string, \"booger\", number]\n            //     vv\n            // ....booger....\n            // Which ever results in a match first is then used. So this 3-4 step\n            // process essentially allows us to say \"match at this position, excluding\n            // a prior rule that was ignored\".\n            //\n            // 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n            // 2. Resume matching for [number]\n            // 3. Match at index + 1 for [string, \"booger\", number]\n            // 4. If #2 and #3 result in matches, which came first?\n            if (this.resumingScanAtSamePosition()) {\n                if (result && result.index === this.lastIndex) ;\n                else {\n                    const m2 = this.getMatcher(0);\n                    m2.lastIndex = this.lastIndex + 1;\n                    result = m2.exec(s);\n                }\n            }\n            if (result) {\n                this.regexIndex += result.position + 1;\n                if (this.regexIndex === this.count) {\n                    // wrap-around to considering all matches again\n                    this.considerAll();\n                }\n            }\n            return result;\n        }\n    }\n    /**\n   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n   * the content and find matches.\n   *\n   * @param {CompiledMode} mode\n   * @returns {ResumableMultiRegex}\n   */ function buildModeRegex(mode) {\n        const mm = new ResumableMultiRegex();\n        mode.contains.forEach((term)=>mm.addRule(term.begin, {\n                rule: term,\n                type: \"begin\"\n            }));\n        if (mode.terminatorEnd) {\n            mm.addRule(mode.terminatorEnd, {\n                type: \"end\"\n            });\n        }\n        if (mode.illegal) {\n            mm.addRule(mode.illegal, {\n                type: \"illegal\"\n            });\n        }\n        return mm;\n    }\n    /** skip vs abort vs ignore\n   *\n   * @skip   - The mode is still entered and exited normally (and contains rules apply),\n   *           but all content is held and added to the parent buffer rather than being\n   *           output when the mode ends.  Mostly used with `sublanguage` to build up\n   *           a single large buffer than can be parsed by sublanguage.\n   *\n   *             - The mode begin ands ends normally.\n   *             - Content matched is added to the parent mode buffer.\n   *             - The parser cursor is moved forward normally.\n   *\n   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n   *           never matched) but DOES NOT continue to match subsequent `contains`\n   *           modes.  Abort is bad/suboptimal because it can result in modes\n   *           farther down not getting applied because an earlier rule eats the\n   *           content but then aborts.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is added to the mode buffer.\n   *             - The parser cursor is moved forward accordingly.\n   *\n   * @ignore - Ignores the mode (as if it never matched) and continues to match any\n   *           subsequent `contains` modes.  Ignore isn't technically possible with\n   *           the current parser implementation.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is ignored.\n   *             - The parser cursor is not moved forward.\n   */ /**\n   * Compiles an individual mode\n   *\n   * This can raise an error if the mode contains certain detectable known logic\n   * issues.\n   * @param {Mode} mode\n   * @param {CompiledMode | null} [parent]\n   * @returns {CompiledMode | never}\n   */ function compileMode(mode, parent) {\n        const cmode = /** @type CompiledMode */ mode;\n        if (mode.compiled) return cmode;\n        [\n            // do this early so compiler extensions generally don't have to worry about\n            // the distinction between match/begin\n            compileMatch\n        ].forEach((ext)=>ext(mode, parent));\n        language.compilerExtensions.forEach((ext)=>ext(mode, parent));\n        // __beforeBegin is considered private API, internal use only\n        mode.__beforeBegin = null;\n        [\n            beginKeywords,\n            // do this later so compiler extensions that come earlier have access to the\n            // raw array if they wanted to perhaps manipulate it, etc.\n            compileIllegal,\n            // default to 1 relevance if not specified\n            compileRelevance\n        ].forEach((ext)=>ext(mode, parent));\n        mode.compiled = true;\n        let keywordPattern = null;\n        if (typeof mode.keywords === \"object\") {\n            keywordPattern = mode.keywords.$pattern;\n            delete mode.keywords.$pattern;\n        }\n        if (mode.keywords) {\n            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n        }\n        // both are not allowed\n        if (mode.lexemes && keywordPattern) {\n            throw new Error(\"ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) \");\n        }\n        // `mode.lexemes` was the old standard before we added and now recommend\n        // using `keywords.$pattern` to pass the keyword pattern\n        keywordPattern = keywordPattern || mode.lexemes || /\\w+/;\n        cmode.keywordPatternRe = langRe(keywordPattern, true);\n        if (parent) {\n            if (!mode.begin) mode.begin = /\\B|\\b/;\n            cmode.beginRe = langRe(mode.begin);\n            if (mode.endSameAsBegin) mode.end = mode.begin;\n            if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n            if (mode.end) cmode.endRe = langRe(mode.end);\n            cmode.terminatorEnd = source(mode.end) || \"\";\n            if (mode.endsWithParent && parent.terminatorEnd) {\n                cmode.terminatorEnd += (mode.end ? \"|\" : \"\") + parent.terminatorEnd;\n            }\n        }\n        if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ mode.illegal);\n        if (!mode.contains) mode.contains = [];\n        mode.contains = [].concat(...mode.contains.map(function(c) {\n            return expandOrCloneMode(c === \"self\" ? mode : c);\n        }));\n        mode.contains.forEach(function(c) {\n            compileMode(/** @type Mode */ c, cmode);\n        });\n        if (mode.starts) {\n            compileMode(mode.starts, parent);\n        }\n        cmode.matcher = buildModeRegex(cmode);\n        return cmode;\n    }\n    if (!language.compilerExtensions) language.compilerExtensions = [];\n    // self is not valid at the top-level\n    if (language.contains && language.contains.includes(\"self\")) {\n        throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n    }\n    // we need a null object, which inherit will guarantee\n    language.classNameAliases = inherit(language.classNameAliases || {});\n    return compileMode(/** @type Mode */ language);\n}\n/**\n * Determines if a mode has a dependency on it's parent or not\n *\n * If a mode does have a parent dependency then often we need to clone it if\n * it's used in multiple places so that each copy points to the correct parent,\n * where-as modes without a parent can often safely be re-used at the bottom of\n * a mode chain.\n *\n * @param {Mode | null} mode\n * @returns {boolean} - is there a dependency on the parent?\n * */ function dependencyOnParent(mode) {\n    if (!mode) return false;\n    return mode.endsWithParent || dependencyOnParent(mode.starts);\n}\n/**\n * Expands a mode or clones it if necessary\n *\n * This is necessary for modes with parental dependenceis (see notes on\n * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n * exploded into their own individual modes at compile time.\n *\n * @param {Mode} mode\n * @returns {Mode | Mode[]}\n * */ function expandOrCloneMode(mode) {\n    if (mode.variants && !mode.cachedVariants) {\n        mode.cachedVariants = mode.variants.map(function(variant) {\n            return inherit(mode, {\n                variants: null\n            }, variant);\n        });\n    }\n    // EXPAND\n    // if we have variants then essentially \"replace\" the mode with the variants\n    // this happens in compileMode, where this function is called from\n    if (mode.cachedVariants) {\n        return mode.cachedVariants;\n    }\n    // CLONE\n    // if we have dependencies on parents then we need a unique\n    // instance of ourselves, so we can be reused with many\n    // different parents without issue\n    if (dependencyOnParent(mode)) {\n        return inherit(mode, {\n            starts: mode.starts ? inherit(mode.starts) : null\n        });\n    }\n    if (Object.isFrozen(mode)) {\n        return inherit(mode);\n    }\n    // no special dependency issues, just return ourselves\n    return mode;\n}\nvar version = \"10.5.0\";\n// @ts-nocheck\nfunction hasValueOrEmptyAttribute(value) {\n    return Boolean(value || value === \"\");\n}\nfunction BuildVuePlugin(hljs) {\n    const Component = {\n        props: [\n            \"language\",\n            \"code\",\n            \"autodetect\"\n        ],\n        data: function() {\n            return {\n                detectedLanguage: \"\",\n                unknownLanguage: false\n            };\n        },\n        computed: {\n            className () {\n                if (this.unknownLanguage) return \"\";\n                return \"hljs \" + this.detectedLanguage;\n            },\n            highlighted () {\n                // no idea what language to use, return raw code\n                if (!this.autoDetect && !hljs.getLanguage(this.language)) {\n                    console.warn(`The language \"${this.language}\" you specified could not be found.`);\n                    this.unknownLanguage = true;\n                    return escapeHTML(this.code);\n                }\n                let result = {};\n                if (this.autoDetect) {\n                    result = hljs.highlightAuto(this.code);\n                    this.detectedLanguage = result.language;\n                } else {\n                    result = hljs.highlight(this.language, this.code, this.ignoreIllegals);\n                    this.detectedLanguage = this.language;\n                }\n                return result.value;\n            },\n            autoDetect () {\n                return !this.language || hasValueOrEmptyAttribute(this.autodetect);\n            },\n            ignoreIllegals () {\n                return true;\n            }\n        },\n        // this avoids needing to use a whole Vue compilation pipeline just\n        // to build Highlight.js\n        render (createElement) {\n            return createElement(\"pre\", {}, [\n                createElement(\"code\", {\n                    class: this.className,\n                    domProps: {\n                        innerHTML: this.highlighted\n                    }\n                })\n            ]);\n        }\n    };\n    const VuePlugin = {\n        install (Vue) {\n            Vue.component(\"highlightjs\", Component);\n        }\n    };\n    return {\n        Component,\n        VuePlugin\n    };\n}\n/* plugin itself */ /** @type {HLJSPlugin} */ const mergeHTMLPlugin = {\n    \"after:highlightBlock\": ({ block, result, text })=>{\n        const originalStream = nodeStream(block);\n        if (!originalStream.length) return;\n        const resultNode = document.createElement(\"div\");\n        resultNode.innerHTML = result.value;\n        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n    }\n};\n/* Stream merging support functions */ /**\n * @typedef Event\n * @property {'start'|'stop'} event\n * @property {number} offset\n * @property {Node} node\n */ /**\n * @param {Node} node\n */ function tag(node) {\n    return node.nodeName.toLowerCase();\n}\n/**\n * @param {Node} node\n */ function nodeStream(node) {\n    /** @type Event[] */ const result = [];\n    (function _nodeStream(node, offset) {\n        for(let child = node.firstChild; child; child = child.nextSibling){\n            if (child.nodeType === 3) {\n                offset += child.nodeValue.length;\n            } else if (child.nodeType === 1) {\n                result.push({\n                    event: \"start\",\n                    offset: offset,\n                    node: child\n                });\n                offset = _nodeStream(child, offset);\n                // Prevent void elements from having an end tag that would actually\n                // double them in the output. There are more void elements in HTML\n                // but we list only those realistically expected in code display.\n                if (!tag(child).match(/br|hr|img|input/)) {\n                    result.push({\n                        event: \"stop\",\n                        offset: offset,\n                        node: child\n                    });\n                }\n            }\n        }\n        return offset;\n    })(node, 0);\n    return result;\n}\n/**\n * @param {any} original - the original stream\n * @param {any} highlighted - stream of the highlighted source\n * @param {string} value - the original source itself\n */ function mergeStreams(original, highlighted, value) {\n    let processed = 0;\n    let result = \"\";\n    const nodeStack = [];\n    function selectStream() {\n        if (!original.length || !highlighted.length) {\n            return original.length ? original : highlighted;\n        }\n        if (original[0].offset !== highlighted[0].offset) {\n            return original[0].offset < highlighted[0].offset ? original : highlighted;\n        }\n        /*\n    To avoid starting the stream just before it should stop the order is\n    ensured that original always starts first and closes last:\n\n    if (event1 == 'start' && event2 == 'start')\n      return original;\n    if (event1 == 'start' && event2 == 'stop')\n      return highlighted;\n    if (event1 == 'stop' && event2 == 'start')\n      return original;\n    if (event1 == 'stop' && event2 == 'stop')\n      return highlighted;\n\n    ... which is collapsed to:\n    */ return highlighted[0].event === \"start\" ? original : highlighted;\n    }\n    /**\n   * @param {Node} node\n   */ function open(node) {\n        /** @param {Attr} attr */ function attributeString(attr) {\n            return \" \" + attr.nodeName + '=\"' + escapeHTML(attr.value) + '\"';\n        }\n        // @ts-ignore\n        result += \"<\" + tag(node) + [].map.call(node.attributes, attributeString).join(\"\") + \">\";\n    }\n    /**\n   * @param {Node} node\n   */ function close(node) {\n        result += \"</\" + tag(node) + \">\";\n    }\n    /**\n   * @param {Event} event\n   */ function render(event) {\n        (event.event === \"start\" ? open : close)(event.node);\n    }\n    while(original.length || highlighted.length){\n        let stream = selectStream();\n        result += escapeHTML(value.substring(processed, stream[0].offset));\n        processed = stream[0].offset;\n        if (stream === original) {\n            /*\n      On any opening or closing tag of the original markup we first close\n      the entire highlighted node stack, then render the original tag along\n      with all the following original tags at the same offset and then\n      reopen all the tags on the highlighted stack.\n      */ nodeStack.reverse().forEach(close);\n            do {\n                render(stream.splice(0, 1)[0]);\n                stream = selectStream();\n            }while (stream === original && stream.length && stream[0].offset === processed);\n            nodeStack.reverse().forEach(open);\n        } else {\n            if (stream[0].event === \"start\") {\n                nodeStack.push(stream[0].node);\n            } else {\n                nodeStack.pop();\n            }\n            render(stream.splice(0, 1)[0]);\n        }\n    }\n    return result + escapeHTML(value.substr(processed));\n}\n/*\n\nFor the reasoning behind this please see:\nhttps://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419\n\n*/ /**\n * @param {string} message\n */ const error = (message)=>{\n    console.error(message);\n};\n/**\n * @param {string} message\n * @param {any} args\n */ const warn = (message, ...args)=>{\n    console.log(`WARN: ${message}`, ...args);\n};\n/**\n * @param {string} version\n * @param {string} message\n */ const deprecated = (version, message)=>{\n    console.log(`Deprecated as of ${version}. ${message}`);\n};\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/ const escape$1 = escapeHTML;\nconst inherit$1 = inherit;\nconst NO_MATCH = Symbol(\"nomatch\");\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */ const HLJS = function(hljs) {\n    // Global internal variables used within the highlight.js library.\n    /** @type {Record<string, Language>} */ const languages = Object.create(null);\n    /** @type {Record<string, string>} */ const aliases = Object.create(null);\n    /** @type {HLJSPlugin[]} */ const plugins = [];\n    // safe/production mode - swallows more errors, tries to keep running\n    // even if a single syntax or parse hits a fatal error\n    let SAFE_MODE = true;\n    const fixMarkupRe = /(^(<[^>]+>|\\t|)+|\\n)/gm;\n    const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n    /** @type {Language} */ const PLAINTEXT_LANGUAGE = {\n        disableAutodetect: true,\n        name: \"Plain text\",\n        contains: []\n    };\n    // Global options used when within external APIs. This is modified when\n    // calling the `hljs.configure` function.\n    /** @type HLJSOptions */ let options = {\n        noHighlightRe: /^(no-?highlight)$/i,\n        languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n        classPrefix: \"hljs-\",\n        tabReplace: null,\n        useBR: false,\n        languages: null,\n        // beta configuration options, subject to change, welcome to discuss\n        // https://github.com/highlightjs/highlight.js/issues/1086\n        __emitter: TokenTreeEmitter\n    };\n    /* Utility functions */ /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */ function shouldNotHighlight(languageName) {\n        return options.noHighlightRe.test(languageName);\n    }\n    /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */ function blockLanguage(block) {\n        let classes = block.className + \" \";\n        classes += block.parentNode ? block.parentNode.className : \"\";\n        // language-* takes precedence over non-prefixed class names.\n        const match = options.languageDetectRe.exec(classes);\n        if (match) {\n            const language = getLanguage(match[1]);\n            if (!language) {\n                warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n                warn(\"Falling back to no-highlight mode for this block.\", block);\n            }\n            return language ? match[1] : \"no-highlight\";\n        }\n        return classes.split(/\\s+/).find((_class)=>shouldNotHighlight(_class) || getLanguage(_class));\n    }\n    /**\n   * Core highlighting function.\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode} [continuation] - current continuation mode, if any\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */ function highlight(languageName, code, ignoreIllegals, continuation) {\n        /** @type {BeforeHighlightContext} */ const context = {\n            code,\n            language: languageName\n        };\n        // the plugin can change the desired language or the code to be highlighted\n        // just be changing the object it was passed\n        fire(\"before:highlight\", context);\n        // a before plugin can usurp the result completely by providing it's own\n        // in which case we don't even need to call highlight\n        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals, continuation);\n        result.code = context.code;\n        // the plugin can change anything in result to suite it\n        fire(\"after:highlight\", result);\n        return result;\n    }\n    /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */ function _highlight(languageName, code, ignoreIllegals, continuation) {\n        const codeToHighlight = code;\n        /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {RegExpMatchArray} match - regexp match data\n     * @returns {KeywordData | false}\n     */ function keywordData(mode, match) {\n            const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];\n            return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];\n        }\n        function processKeywords() {\n            if (!top.keywords) {\n                emitter.addText(modeBuffer);\n                return;\n            }\n            let lastIndex = 0;\n            top.keywordPatternRe.lastIndex = 0;\n            let match = top.keywordPatternRe.exec(modeBuffer);\n            let buf = \"\";\n            while(match){\n                buf += modeBuffer.substring(lastIndex, match.index);\n                const data = keywordData(top, match);\n                if (data) {\n                    const [kind, keywordRelevance] = data;\n                    emitter.addText(buf);\n                    buf = \"\";\n                    relevance += keywordRelevance;\n                    const cssClass = language.classNameAliases[kind] || kind;\n                    emitter.addKeyword(match[0], cssClass);\n                } else {\n                    buf += match[0];\n                }\n                lastIndex = top.keywordPatternRe.lastIndex;\n                match = top.keywordPatternRe.exec(modeBuffer);\n            }\n            buf += modeBuffer.substr(lastIndex);\n            emitter.addText(buf);\n        }\n        function processSubLanguage() {\n            if (modeBuffer === \"\") return;\n            /** @type HighlightResult */ let result = null;\n            if (typeof top.subLanguage === \"string\") {\n                if (!languages[top.subLanguage]) {\n                    emitter.addText(modeBuffer);\n                    return;\n                }\n                result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n                continuations[top.subLanguage] = /** @type {CompiledMode} */ result.top;\n            } else {\n                result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n            }\n            // Counting embedded language score towards the host language may be disabled\n            // with zeroing the containing mode relevance. Use case in point is Markdown that\n            // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n            // score.\n            if (top.relevance > 0) {\n                relevance += result.relevance;\n            }\n            emitter.addSublanguage(result.emitter, result.language);\n        }\n        function processBuffer() {\n            if (top.subLanguage != null) {\n                processSubLanguage();\n            } else {\n                processKeywords();\n            }\n            modeBuffer = \"\";\n        }\n        /**\n     * @param {Mode} mode - new mode to start\n     */ function startNewMode(mode) {\n            if (mode.className) {\n                emitter.openNode(language.classNameAliases[mode.className] || mode.className);\n            }\n            top = Object.create(mode, {\n                parent: {\n                    value: top\n                }\n            });\n            return top;\n        }\n        /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */ function endOfMode(mode, match, matchPlusRemainder) {\n            let matched = startsWith(mode.endRe, matchPlusRemainder);\n            if (matched) {\n                if (mode[\"on:end\"]) {\n                    const resp = new Response(mode);\n                    mode[\"on:end\"](match, resp);\n                    if (resp.ignore) matched = false;\n                }\n                if (matched) {\n                    while(mode.endsParent && mode.parent){\n                        mode = mode.parent;\n                    }\n                    return mode;\n                }\n            }\n            // even if on:end fires an `ignore` it's still possible\n            // that we might trigger the end node because of a parent mode\n            if (mode.endsWithParent) {\n                return endOfMode(mode.parent, match, matchPlusRemainder);\n            }\n        }\n        /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */ function doIgnore(lexeme) {\n            if (top.matcher.regexIndex === 0) {\n                // no more regexs to potentially match here, so we move the cursor forward one\n                // space\n                modeBuffer += lexeme[0];\n                return 1;\n            } else {\n                // no need to move the cursor, we still have additional regexes to try and\n                // match at this very spot\n                resumeScanAtSamePosition = true;\n                return 0;\n            }\n        }\n        /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */ function doBeginMatch(match) {\n            const lexeme = match[0];\n            const newMode = match.rule;\n            const resp = new Response(newMode);\n            // first internal before callbacks, then the public ones\n            const beforeCallbacks = [\n                newMode.__beforeBegin,\n                newMode[\"on:begin\"]\n            ];\n            for (const cb of beforeCallbacks){\n                if (!cb) continue;\n                cb(match, resp);\n                if (resp.ignore) return doIgnore(lexeme);\n            }\n            if (newMode && newMode.endSameAsBegin) {\n                newMode.endRe = escape(lexeme);\n            }\n            if (newMode.skip) {\n                modeBuffer += lexeme;\n            } else {\n                if (newMode.excludeBegin) {\n                    modeBuffer += lexeme;\n                }\n                processBuffer();\n                if (!newMode.returnBegin && !newMode.excludeBegin) {\n                    modeBuffer = lexeme;\n                }\n            }\n            startNewMode(newMode);\n            // if (mode[\"after:begin\"]) {\n            //   let resp = new Response(mode);\n            //   mode[\"after:begin\"](match, resp);\n            // }\n            return newMode.returnBegin ? 0 : lexeme.length;\n        }\n        /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */ function doEndMatch(match) {\n            const lexeme = match[0];\n            const matchPlusRemainder = codeToHighlight.substr(match.index);\n            const endMode = endOfMode(top, match, matchPlusRemainder);\n            if (!endMode) {\n                return NO_MATCH;\n            }\n            const origin = top;\n            if (origin.skip) {\n                modeBuffer += lexeme;\n            } else {\n                if (!(origin.returnEnd || origin.excludeEnd)) {\n                    modeBuffer += lexeme;\n                }\n                processBuffer();\n                if (origin.excludeEnd) {\n                    modeBuffer = lexeme;\n                }\n            }\n            do {\n                if (top.className) {\n                    emitter.closeNode();\n                }\n                if (!top.skip && !top.subLanguage) {\n                    relevance += top.relevance;\n                }\n                top = top.parent;\n            }while (top !== endMode.parent);\n            if (endMode.starts) {\n                if (endMode.endSameAsBegin) {\n                    endMode.starts.endRe = endMode.endRe;\n                }\n                startNewMode(endMode.starts);\n            }\n            return origin.returnEnd ? 0 : lexeme.length;\n        }\n        function processContinuations() {\n            const list = [];\n            for(let current = top; current !== language; current = current.parent){\n                if (current.className) {\n                    list.unshift(current.className);\n                }\n            }\n            list.forEach((item)=>emitter.openNode(item));\n        }\n        /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */ let lastMatch = {};\n        /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceeding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */ function processLexeme(textBeforeMatch, match) {\n            const lexeme = match && match[0];\n            // add non-matched text to the current mode buffer\n            modeBuffer += textBeforeMatch;\n            if (lexeme == null) {\n                processBuffer();\n                return 0;\n            }\n            // we've found a 0 width match and we're stuck, so we need to advance\n            // this happens when we have badly behaved rules that have optional matchers to the degree that\n            // sometimes they can end up matching nothing at all\n            // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n            if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n                // spit the \"skipped\" character that our regex choked on back into the output sequence\n                modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n                if (!SAFE_MODE) {\n                    /** @type {AnnotatedError} */ const err = new Error(\"0 width match regex\");\n                    err.languageName = languageName;\n                    err.badRule = lastMatch.rule;\n                    throw err;\n                }\n                return 1;\n            }\n            lastMatch = match;\n            if (match.type === \"begin\") {\n                return doBeginMatch(match);\n            } else if (match.type === \"illegal\" && !ignoreIllegals) {\n                // illegal match, we do not continue processing\n                /** @type {AnnotatedError} */ const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || \"<unnamed>\") + '\"');\n                err.mode = top;\n                throw err;\n            } else if (match.type === \"end\") {\n                const processed = doEndMatch(match);\n                if (processed !== NO_MATCH) {\n                    return processed;\n                }\n            }\n            // edge case for when illegal matches $ (end of line) which is technically\n            // a 0 width match but not a begin/end match so it's not caught by the\n            // first handler (when ignoreIllegals is true)\n            if (match.type === \"illegal\" && lexeme === \"\") {\n                // advance so we aren't stuck in an infinite loop\n                return 1;\n            }\n            // infinite loops are BAD, this is a last ditch catch all. if we have a\n            // decent number of iterations yet our index (cursor position in our\n            // parsing) still 3x behind our index then something is very wrong\n            // so we bail\n            if (iterations > 100000 && iterations > match.index * 3) {\n                const err = new Error(\"potential infinite loop, way more iterations than matches\");\n                throw err;\n            }\n            /*\n      Why might be find ourselves here?  Only one occasion now.  An end match that was\n      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`\n      rule sets the end rule to a specific match.  Since the overall mode termination rule that's\n      being used to scan the text isn't recompiled that means that any match that LOOKS like\n      the end (but is not, because it is not an exact match to the beginning) will\n      end up here.  A definite end match, but when `doEndMatch` tries to \"reapply\"\n      the end rule and fails to match, we wind up here, and just silently ignore the end.\n\n      This causes no real harm other than stopping a few times too many.\n      */ modeBuffer += lexeme;\n            return lexeme.length;\n        }\n        const language = getLanguage(languageName);\n        if (!language) {\n            error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n            throw new Error('Unknown language: \"' + languageName + '\"');\n        }\n        const md = compileLanguage(language, {\n            plugins\n        });\n        let result = \"\";\n        /** @type {CompiledMode} */ let top = continuation || md;\n        /** @type Record<string,CompiledMode> */ const continuations = {}; // keep continuations for sub-languages\n        const emitter = new options.__emitter(options);\n        processContinuations();\n        let modeBuffer = \"\";\n        let relevance = 0;\n        let index = 0;\n        let iterations = 0;\n        let resumeScanAtSamePosition = false;\n        try {\n            top.matcher.considerAll();\n            for(;;){\n                iterations++;\n                if (resumeScanAtSamePosition) {\n                    // only regexes not matched previously will now be\n                    // considered for a potential match\n                    resumeScanAtSamePosition = false;\n                } else {\n                    top.matcher.considerAll();\n                }\n                top.matcher.lastIndex = index;\n                const match = top.matcher.exec(codeToHighlight);\n                // console.log(\"match\", match[0], match.rule && match.rule.begin)\n                if (!match) break;\n                const beforeMatch = codeToHighlight.substring(index, match.index);\n                const processedCount = processLexeme(beforeMatch, match);\n                index = match.index + processedCount;\n            }\n            processLexeme(codeToHighlight.substr(index));\n            emitter.closeAllNodes();\n            emitter.finalize();\n            result = emitter.toHTML();\n            return {\n                relevance: relevance,\n                value: result,\n                language: languageName,\n                illegal: false,\n                emitter: emitter,\n                top: top\n            };\n        } catch (err) {\n            if (err.message && err.message.includes(\"Illegal\")) {\n                return {\n                    illegal: true,\n                    illegalBy: {\n                        msg: err.message,\n                        context: codeToHighlight.slice(index - 100, index + 100),\n                        mode: err.mode\n                    },\n                    sofar: result,\n                    relevance: 0,\n                    value: escape$1(codeToHighlight),\n                    emitter: emitter\n                };\n            } else if (SAFE_MODE) {\n                return {\n                    illegal: false,\n                    relevance: 0,\n                    value: escape$1(codeToHighlight),\n                    emitter: emitter,\n                    language: languageName,\n                    top: top,\n                    errorRaised: err\n                };\n            } else {\n                throw err;\n            }\n        }\n    }\n    /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */ function justTextHighlightResult(code) {\n        const result = {\n            relevance: 0,\n            emitter: new options.__emitter(options),\n            value: escape$1(code),\n            illegal: false,\n            top: PLAINTEXT_LANGUAGE\n        };\n        result.emitter.addText(code);\n        return result;\n    }\n    /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}\n  */ function highlightAuto(code, languageSubset) {\n        languageSubset = languageSubset || options.languages || Object.keys(languages);\n        const plaintext = justTextHighlightResult(code);\n        const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name)=>_highlight(name, code, false));\n        results.unshift(plaintext); // plaintext is always an option\n        const sorted = results.sort((a, b)=>{\n            // sort base on relevance\n            if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n            // always award the tie to the base language\n            // ie if C++ and Arduino are tied, it's more likely to be C++\n            if (a.language && b.language) {\n                if (getLanguage(a.language).supersetOf === b.language) {\n                    return 1;\n                } else if (getLanguage(b.language).supersetOf === a.language) {\n                    return -1;\n                }\n            }\n            // otherwise say they are equal, which has the effect of sorting on\n            // relevance while preserving the original ordering - which is how ties\n            // have historically been settled, ie the language that comes first always\n            // wins in the case of a tie\n            return 0;\n        });\n        const [best, secondBest] = sorted;\n        /** @type {AutoHighlightResult} */ const result = best;\n        result.second_best = secondBest;\n        return result;\n    }\n    /**\n  Post-processing of the highlighted markup:\n\n  - replace TABs with something more useful\n  - replace real line-breaks with '<br>' for non-pre containers\n\n    @param {string} html\n    @returns {string}\n  */ function fixMarkup(html) {\n        if (!(options.tabReplace || options.useBR)) {\n            return html;\n        }\n        return html.replace(fixMarkupRe, (match)=>{\n            if (match === \"\\n\") {\n                return options.useBR ? \"<br>\" : match;\n            } else if (options.tabReplace) {\n                return match.replace(/\\t/g, options.tabReplace);\n            }\n            return match;\n        });\n    }\n    /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */ function updateClassName(element, currentLang, resultLang) {\n        const language = currentLang ? aliases[currentLang] : resultLang;\n        element.classList.add(\"hljs\");\n        if (language) element.classList.add(language);\n    }\n    /** @type {HLJSPlugin} */ const brPlugin = {\n        \"before:highlightBlock\": ({ block })=>{\n            if (options.useBR) {\n                block.innerHTML = block.innerHTML.replace(/\\n/g, \"\").replace(/<br[ /]*>/g, \"\\n\");\n            }\n        },\n        \"after:highlightBlock\": ({ result })=>{\n            if (options.useBR) {\n                result.value = result.value.replace(/\\n/g, \"<br>\");\n            }\n        }\n    };\n    const TAB_REPLACE_RE = /^(<[^>]+>|\\t)+/gm;\n    /** @type {HLJSPlugin} */ const tabReplacePlugin = {\n        \"after:highlightBlock\": ({ result })=>{\n            if (options.tabReplace) {\n                result.value = result.value.replace(TAB_REPLACE_RE, (m)=>m.replace(/\\t/g, options.tabReplace));\n            }\n        }\n    };\n    /**\n   * Applies highlighting to a DOM node containing code. Accepts a DOM node and\n   * two optional parameters for fixMarkup.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */ function highlightBlock(element) {\n        /** @type HTMLElement */ let node = null;\n        const language = blockLanguage(element);\n        if (shouldNotHighlight(language)) return;\n        fire(\"before:highlightBlock\", {\n            block: element,\n            language: language\n        });\n        node = element;\n        const text = node.textContent;\n        const result = language ? highlight(language, text, true) : highlightAuto(text);\n        fire(\"after:highlightBlock\", {\n            block: element,\n            result,\n            text\n        });\n        element.innerHTML = result.value;\n        updateClassName(element, language, result.language);\n        element.result = {\n            language: result.language,\n            // TODO: remove with version 11.0\n            re: result.relevance,\n            relavance: result.relevance\n        };\n        if (result.second_best) {\n            element.second_best = {\n                language: result.second_best.language,\n                // TODO: remove with version 11.0\n                re: result.second_best.relevance,\n                relavance: result.second_best.relevance\n            };\n        }\n    }\n    /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */ function configure(userOptions) {\n        if (userOptions.useBR) {\n            deprecated(\"10.3.0\", \"'useBR' will be removed entirely in v11.0\");\n            deprecated(\"10.3.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2559\");\n        }\n        options = inherit$1(options, userOptions);\n    }\n    /**\n   * Highlights to all <pre><code> blocks on a page\n   *\n   * @type {Function & {called?: boolean}}\n   */ const initHighlighting = ()=>{\n        if (initHighlighting.called) return;\n        initHighlighting.called = true;\n        const blocks = document.querySelectorAll(\"pre code\");\n        blocks.forEach(highlightBlock);\n    };\n    // Higlights all when DOMContentLoaded fires\n    function initHighlightingOnLoad() {\n        // @ts-ignore\n        window.addEventListener(\"DOMContentLoaded\", initHighlighting, false);\n    }\n    /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */ function registerLanguage(languageName, languageDefinition) {\n        let lang = null;\n        try {\n            lang = languageDefinition(hljs);\n        } catch (error$1) {\n            error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n            // hard or soft error\n            if (!SAFE_MODE) {\n                throw error$1;\n            } else {\n                error(error$1);\n            }\n            // languages that have serious errors are replaced with essentially a\n            // \"plaintext\" stand-in so that the code blocks will still get normal\n            // css classes applied to them - and one bad language won't break the\n            // entire highlighter\n            lang = PLAINTEXT_LANGUAGE;\n        }\n        // give it a temporary name if it doesn't have one in the meta-data\n        if (!lang.name) lang.name = languageName;\n        languages[languageName] = lang;\n        lang.rawDefinition = languageDefinition.bind(null, hljs);\n        if (lang.aliases) {\n            registerAliases(lang.aliases, {\n                languageName\n            });\n        }\n    }\n    /**\n   * @returns {string[]} List of language internal names\n   */ function listLanguages() {\n        return Object.keys(languages);\n    }\n    /**\n    intended usage: When one language truly requires another\n\n    Unlike `getLanguage`, this will throw when the requested language\n    is not available.\n\n    @param {string} name - name of the language to fetch/require\n    @returns {Language | never}\n  */ function requireLanguage(name) {\n        deprecated(\"10.4.0\", \"requireLanguage will be removed entirely in v11.\");\n        deprecated(\"10.4.0\", \"Please see https://github.com/highlightjs/highlight.js/pull/2844\");\n        const lang = getLanguage(name);\n        if (lang) {\n            return lang;\n        }\n        const err = new Error(\"The '{}' language is required, but not loaded.\".replace(\"{}\", name));\n        throw err;\n    }\n    /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */ function getLanguage(name) {\n        name = (name || \"\").toLowerCase();\n        return languages[name] || languages[aliases[name]];\n    }\n    /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */ function registerAliases(aliasList, { languageName }) {\n        if (typeof aliasList === \"string\") {\n            aliasList = [\n                aliasList\n            ];\n        }\n        aliasList.forEach((alias)=>{\n            aliases[alias] = languageName;\n        });\n    }\n    /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */ function autoDetection(name) {\n        const lang = getLanguage(name);\n        return lang && !lang.disableAutodetect;\n    }\n    /**\n   * @param {HLJSPlugin} plugin\n   */ function addPlugin(plugin) {\n        plugins.push(plugin);\n    }\n    /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */ function fire(event, args) {\n        const cb = event;\n        plugins.forEach(function(plugin) {\n            if (plugin[cb]) {\n                plugin[cb](args);\n            }\n        });\n    }\n    /**\n  Note: fixMarkup is deprecated and will be removed entirely in v11\n\n  @param {string} arg\n  @returns {string}\n  */ function deprecateFixMarkup(arg) {\n        deprecated(\"10.2.0\", \"fixMarkup will be removed entirely in v11.0\");\n        deprecated(\"10.2.0\", \"Please see https://github.com/highlightjs/highlight.js/issues/2534\");\n        return fixMarkup(arg);\n    }\n    /* Interface definition */ Object.assign(hljs, {\n        highlight,\n        highlightAuto,\n        fixMarkup: deprecateFixMarkup,\n        highlightBlock,\n        configure,\n        initHighlighting,\n        initHighlightingOnLoad,\n        registerLanguage,\n        listLanguages,\n        getLanguage,\n        registerAliases,\n        requireLanguage,\n        autoDetection,\n        inherit: inherit$1,\n        addPlugin,\n        // plugins for frameworks\n        vuePlugin: BuildVuePlugin(hljs).VuePlugin\n    });\n    hljs.debugMode = function() {\n        SAFE_MODE = false;\n    };\n    hljs.safeMode = function() {\n        SAFE_MODE = true;\n    };\n    hljs.versionString = version;\n    for(const key in MODES){\n        // @ts-ignore\n        if (typeof MODES[key] === \"object\") {\n            // @ts-ignore\n            deepFreezeEs6(MODES[key]);\n        }\n    }\n    // merge all the modes/regexs into our main object\n    Object.assign(hljs, MODES);\n    // built-in plugins, likely to be moved out of core in the future\n    hljs.addPlugin(brPlugin); // slated to be removed in v11\n    hljs.addPlugin(mergeHTMLPlugin);\n    hljs.addPlugin(tabReplacePlugin);\n    return hljs;\n};\n// export an \"instance\" of the highlighter\nvar highlight = HLJS({});\nmodule.exports = highlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvY29yZS5qcz9kOTU4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gb2JqLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwIGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgaXMgcmVhZC1vbmx5Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJlZXplIHNlbGZcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3AgPSBvYmpbbmFtZV07XG5cbiAgICAgICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHByb3ApKSB7XG4gICAgICAgICAgICBkZWVwRnJlZXplKHByb3ApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG52YXIgZGVlcEZyZWV6ZUVzNiA9IGRlZXBGcmVlemU7XG52YXIgX2RlZmF1bHQgPSBkZWVwRnJlZXplO1xuZGVlcEZyZWV6ZUVzNi5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmNsYXNzIFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIGlmIChtb2RlLmRhdGEgPT09IHVuZGVmaW5lZCkgbW9kZS5kYXRhID0ge307XG5cbiAgICB0aGlzLmRhdGEgPSBtb2RlLmRhdGE7XG4gIH1cblxuICBpZ25vcmVNYXRjaCgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUhUTUwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7Jyk7XG59XG5cbi8qKlxuICogcGVyZm9ybXMgYSBzaGFsbG93IG1lcmdlIG9mIG11bHRpcGxlIG9iamVjdHMgaW50byBvbmVcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBvcmlnaW5hbFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLGFueT5bXX0gb2JqZWN0c1xuICogQHJldHVybnMge1R9IGEgc2luZ2xlIG5ldyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5oZXJpdChvcmlnaW5hbCwgLi4ub2JqZWN0cykge1xuICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxhbnk+ICovXG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICByZXN1bHRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gIH1cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZW5kZXJlclxuICogQHByb3BlcnR5IHsodGV4dDogc3RyaW5nKSA9PiB2b2lkfSBhZGRUZXh0XG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBvcGVuTm9kZVxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZSkgPT4gdm9pZH0gY2xvc2VOb2RlXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdmFsdWVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3traW5kPzogc3RyaW5nLCBzdWJsYW5ndWFnZT86IGJvb2xlYW59fSBOb2RlICovXG4vKiogQHR5cGVkZWYge3t3YWxrOiAocjogUmVuZGVyZXIpID0+IHZvaWR9fSBUcmVlICovXG4vKiogKi9cblxuY29uc3QgU1BBTl9DTE9TRSA9ICc8L3NwYW4+JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbm9kZSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIDxzcGFuPlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuY29uc3QgZW1pdHNXcmFwcGluZ1RhZ3MgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gISFub2RlLmtpbmQ7XG59O1xuXG4vKiogQHR5cGUge1JlbmRlcmVyfSAqL1xuY2xhc3MgSFRNTFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSFRNTFJlbmRlcmVyXG4gICAqXG4gICAqIEBwYXJhbSB7VHJlZX0gcGFyc2VUcmVlIC0gdGhlIHBhcnNlIHRyZWUgKG11c3Qgc3VwcG9ydCBgd2Fsa2AgQVBJKVxuICAgKiBAcGFyYW0ge3tjbGFzc1ByZWZpeDogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyc2VUcmVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSBvcHRpb25zLmNsYXNzUHJlZml4O1xuICAgIHBhcnNlVHJlZS53YWxrKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGV4dHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5idWZmZXIgKz0gZXNjYXBlSFRNTCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbm9kZSBvcGVuIHRvIHRoZSBvdXRwdXQgc3RyZWFtIChpZiBuZWVkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBvcGVuTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgbGV0IGNsYXNzTmFtZSA9IG5vZGUua2luZDtcbiAgICBpZiAoIW5vZGUuc3VibGFuZ3VhZ2UpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGAke3RoaXMuY2xhc3NQcmVmaXh9JHtjbGFzc05hbWV9YDtcbiAgICB9XG4gICAgdGhpcy5zcGFuKGNsYXNzTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5vZGUgY2xvc2UgdG8gdGhlIG91dHB1dCBzdHJlYW0gKGlmIG5lZWRlZClcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGNsb3NlTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5idWZmZXIgKz0gU1BBTl9DTE9TRTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCBidWZmZXJcbiAgKi9cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzcGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBzcGFuKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3NOYW1lfVwiPmA7XG4gIH1cbn1cblxuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB8IHN0cmluZ30gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7a2luZD86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFuLCBjaGlsZHJlbjogTm9kZVtdfSB9IERhdGFOb2RlICovXG4vKiogICovXG5cbmNsYXNzIFRva2VuVHJlZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSBEYXRhTm9kZSAqL1xuICAgIHRoaXMucm9vdE5vZGUgPSB7IGNoaWxkcmVuOiBbXSB9O1xuICAgIHRoaXMuc3RhY2sgPSBbdGhpcy5yb290Tm9kZV07XG4gIH1cblxuICBnZXQgdG9wKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMucm9vdE5vZGU7IH1cblxuICAvKiogQHBhcmFtIHtOb2RlfSBub2RlICovXG4gIGFkZChub2RlKSB7XG4gICAgdGhpcy50b3AuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30ga2luZCAqL1xuICBvcGVuTm9kZShraW5kKSB7XG4gICAgLyoqIEB0eXBlIE5vZGUgKi9cbiAgICBjb25zdCBub2RlID0geyBraW5kLCBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLmFkZChub2RlKTtcbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gIH1cblxuICBjbG9zZU5vZGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY2xvc2VBbGxOb2RlcygpIHtcbiAgICB3aGlsZSAodGhpcy5jbG9zZU5vZGUoKSk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucm9vdE5vZGUsIG51bGwsIDQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiLi9odG1sX3JlbmRlcmVyXCIpLlJlbmRlcmVyIH0gUmVuZGVyZXJcbiAgICogQHBhcmFtIHtSZW5kZXJlcn0gYnVpbGRlclxuICAgKi9cbiAgd2FsayhidWlsZGVyKSB7XG4gICAgLy8gdGhpcyBkb2VzIG5vdFxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl93YWxrKGJ1aWxkZXIsIHRoaXMucm9vdE5vZGUpO1xuICAgIC8vIHRoaXMgd29ya3NcbiAgICAvLyByZXR1cm4gVG9rZW5UcmVlLl93YWxrKGJ1aWxkZXIsIHRoaXMucm9vdE5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVuZGVyZXJ9IGJ1aWxkZXJcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBzdGF0aWMgX3dhbGsoYnVpbGRlciwgbm9kZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYnVpbGRlci5hZGRUZXh0KG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgYnVpbGRlci5vcGVuTm9kZShub2RlKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX3dhbGsoYnVpbGRlciwgY2hpbGQpKTtcbiAgICAgIGJ1aWxkZXIuY2xvc2VOb2RlKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHN0YXRpYyBfY29sbGFwc2Uobm9kZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuO1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikgcmV0dXJuO1xuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4uZXZlcnkoZWwgPT4gdHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgLy8gbm9kZS50ZXh0ID0gbm9kZS5jaGlsZHJlbi5qb2luKFwiXCIpO1xuICAgICAgLy8gZGVsZXRlIG5vZGUuY2hpbGRyZW47XG4gICAgICBub2RlLmNoaWxkcmVuID0gW25vZGUuY2hpbGRyZW4uam9pbihcIlwiKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgVG9rZW5UcmVlLl9jb2xsYXBzZShjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gIEN1cnJlbnRseSB0aGlzIGlzIGFsbCBwcml2YXRlIEFQSSwgYnV0IHRoaXMgaXMgdGhlIG1pbmltYWwgQVBJIG5lY2Vzc2FyeVxuICB0aGF0IGFuIEVtaXR0ZXIgbXVzdCBpbXBsZW1lbnQgdG8gZnVsbHkgc3VwcG9ydCB0aGUgcGFyc2VyLlxuXG4gIE1pbmltYWwgaW50ZXJmYWNlOlxuXG4gIC0gYWRkS2V5d29yZCh0ZXh0LCBraW5kKVxuICAtIGFkZFRleHQodGV4dClcbiAgLSBhZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBzdWJMYW5ndWFnZU5hbWUpXG4gIC0gZmluYWxpemUoKVxuICAtIG9wZW5Ob2RlKGtpbmQpXG4gIC0gY2xvc2VOb2RlKClcbiAgLSBjbG9zZUFsbE5vZGVzKClcbiAgLSB0b0hUTUwoKVxuXG4qL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtFbWl0dGVyfVxuICovXG5jbGFzcyBUb2tlblRyZWVFbWl0dGVyIGV4dGVuZHMgVG9rZW5UcmVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKi9cbiAgYWRkS2V5d29yZCh0ZXh0LCBraW5kKSB7XG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLm9wZW5Ob2RlKGtpbmQpO1xuICAgIHRoaXMuYWRkVGV4dCh0ZXh0KTtcbiAgICB0aGlzLmNsb3NlTm9kZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqL1xuICBhZGRUZXh0KHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gXCJcIikgeyByZXR1cm47IH1cblxuICAgIHRoaXMuYWRkKHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RW1pdHRlciAmIHtyb290OiBEYXRhTm9kZX19IGVtaXR0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGFkZFN1Ymxhbmd1YWdlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgICBjb25zdCBub2RlID0gZW1pdHRlci5yb290O1xuICAgIG5vZGUua2luZCA9IG5hbWU7XG4gICAgbm9kZS5zdWJsYW5ndWFnZSA9IHRydWU7XG4gICAgdGhpcy5hZGQobm9kZSk7XG4gIH1cblxuICB0b0hUTUwoKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgSFRNTFJlbmRlcmVyKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlbmRlcmVyLnZhbHVlKCk7XG4gIH1cblxuICBmaW5hbGl6ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAodmFsdWUucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpLCAnbScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi4oUmVnRXhwIHwgc3RyaW5nKSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9IGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qKlxuICogQW55IG9mIHRoZSBwYXNzZWQgZXhwcmVzc3Npb25zIG1heSBtYXRjaFxuICpcbiAqIENyZWF0ZXMgYSBodWdlIHRoaXMgfCB0aGlzIHwgdGhhdCB8IHRoYXQgbWF0Y2hcbiAqIEBwYXJhbSB7KFJlZ0V4cCB8IHN0cmluZylbXSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVpdGhlciguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJyArIGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb3VudE1hdGNoR3JvdXBzKHJlKSB7XG4gIHJldHVybiAobmV3IFJlZ0V4cChyZS50b1N0cmluZygpICsgJ3wnKSkuZXhlYygnJykubGVuZ3RoIC0gMTtcbn1cblxuLyoqXG4gKiBEb2VzIGxleGVtZSBzdGFydCB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoIGF0IHRoZSBiZWdpbm5pbmdcbiAqIEBwYXJhbSB7UmVnRXhwfSByZVxuICogQHBhcmFtIHtzdHJpbmd9IGxleGVtZVxuICovXG5mdW5jdGlvbiBzdGFydHNXaXRoKHJlLCBsZXhlbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSByZSAmJiByZS5leGVjKGxleGVtZSk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5pbmRleCA9PT0gMDtcbn1cblxuLy8gam9pbiBsb2dpY2FsbHkgY29tcHV0ZXMgcmVnZXhwcy5qb2luKHNlcGFyYXRvciksIGJ1dCBmaXhlcyB0aGVcbi8vIGJhY2tyZWZlcmVuY2VzIHNvIHRoZXkgY29udGludWUgdG8gbWF0Y2guXG4vLyBpdCBhbHNvIHBsYWNlcyBlYWNoIGluZGl2aWR1YWwgcmVndWxhciBleHByZXNzaW9uIGludG8gaXQncyBvd25cbi8vIG1hdGNoIGdyb3VwLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBzZXF1ZW5jaW5nIG9mIHRob3NlIG1hdGNoIGdyb3Vwc1xuLy8gaXMgY3VycmVudGx5IGFuIGV4ZXJjaXNlIGZvciB0aGUgY2FsbGVyLiA6LSlcbi8qKlxuICogQHBhcmFtIHsoc3RyaW5nIHwgUmVnRXhwKVtdfSByZWdleHBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBqb2luKHJlZ2V4cHMsIHNlcGFyYXRvciA9IFwifFwiKSB7XG4gIC8vIGJhY2tyZWZlcmVuY2VSZSBtYXRjaGVzIGFuIG9wZW4gcGFyZW50aGVzaXMgb3IgYmFja3JlZmVyZW5jZS4gVG8gYXZvaWRcbiAgLy8gYW4gaW5jb3JyZWN0IHBhcnNlLCBpdCBhZGRpdGlvbmFsbHkgbWF0Y2hlcyB0aGUgZm9sbG93aW5nOlxuICAvLyAtIFsuLi5dIGVsZW1lbnRzLCB3aGVyZSB0aGUgbWVhbmluZyBvZiBwYXJlbnRoZXNlcyBhbmQgZXNjYXBlcyBjaGFuZ2VcbiAgLy8gLSBvdGhlciBlc2NhcGUgc2VxdWVuY2VzLCBzbyB3ZSBkbyBub3QgbWlzcGFyc2UgZXNjYXBlIHNlcXVlbmNlcyBhc1xuICAvLyAgIGludGVyZXN0aW5nIGVsZW1lbnRzXG4gIC8vIC0gbm9uLW1hdGNoaW5nIG9yIGxvb2thaGVhZCBwYXJlbnRoZXNlcywgd2hpY2ggZG8gbm90IGNhcHR1cmUuIFRoZXNlXG4gIC8vICAgZm9sbG93IHRoZSAnKCcgd2l0aCBhICc/Jy5cbiAgY29uc3QgYmFja3JlZmVyZW5jZVJlID0gL1xcWyg/OlteXFxcXFxcXV18XFxcXC4pKlxcXXxcXChcXD8/fFxcXFwoWzEtOV1bMC05XSopfFxcXFwuLztcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcbiAgbGV0IHJldCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2V4cHMubGVuZ3RoOyBpKyspIHtcbiAgICBudW1DYXB0dXJlcyArPSAxO1xuICAgIGNvbnN0IG9mZnNldCA9IG51bUNhcHR1cmVzO1xuICAgIGxldCByZSA9IHNvdXJjZShyZWdleHBzW2ldKTtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIHJldCArPSBzZXBhcmF0b3I7XG4gICAgfVxuICAgIHJldCArPSBcIihcIjtcbiAgICB3aGlsZSAocmUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBiYWNrcmVmZXJlbmNlUmUuZXhlYyhyZSk7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICByZXQgKz0gcmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0ICs9IHJlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICByZSA9IHJlLnN1YnN0cmluZyhtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBpZiAobWF0Y2hbMF1bMF0gPT09ICdcXFxcJyAmJiBtYXRjaFsxXSkge1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGJhY2tyZWZlcmVuY2UuXG4gICAgICAgIHJldCArPSAnXFxcXCcgKyBTdHJpbmcoTnVtYmVyKG1hdGNoWzFdKSArIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgKz0gbWF0Y2hbMF07XG4gICAgICAgIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICAgICAgbnVtQ2FwdHVyZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXQgKz0gXCIpXCI7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29tbW9uIHJlZ2V4cHNcbmNvbnN0IElERU5UX1JFID0gJ1thLXpBLVpdXFxcXHcqJztcbmNvbnN0IFVOREVSU0NPUkVfSURFTlRfUkUgPSAnW2EtekEtWl9dXFxcXHcqJztcbmNvbnN0IE5VTUJFUl9SRSA9ICdcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKyk/JztcbmNvbnN0IENfTlVNQkVSX1JFID0gJygtPykoXFxcXGIwW3hYXVthLWZBLUYwLTldK3woXFxcXGJcXFxcZCsoXFxcXC5cXFxcZCopP3xcXFxcLlxcXFxkKykoW2VFXVstK10/XFxcXGQrKT8pJzsgLy8gMHguLi4sIDAuLi4sIGRlY2ltYWwsIGZsb2F0XG5jb25zdCBCSU5BUllfTlVNQkVSX1JFID0gJ1xcXFxiKDBiWzAxXSspJzsgLy8gMGIuLi5cbmNvbnN0IFJFX1NUQVJURVJTX1JFID0gJyF8IT18IT09fCV8JT18JnwmJnwmPXxcXFxcKnxcXFxcKj18XFxcXCt8XFxcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXFxcP3xcXFxcW3xcXFxce3xcXFxcKHxcXFxcXnxcXFxcXj18XFxcXHx8XFxcXHw9fFxcXFx8XFxcXHx8fic7XG5cbi8qKlxuKiBAcGFyYW0geyBQYXJ0aWFsPE1vZGU+ICYge2JpbmFyeT86IHN0cmluZyB8IFJlZ0V4cH0gfSBvcHRzXG4qL1xuY29uc3QgU0hFQkFORyA9IChvcHRzID0ge30pID0+IHtcbiAgY29uc3QgYmVnaW5TaGViYW5nID0gL14jIVsgXSpcXC8vO1xuICBpZiAob3B0cy5iaW5hcnkpIHtcbiAgICBvcHRzLmJlZ2luID0gY29uY2F0KFxuICAgICAgYmVnaW5TaGViYW5nLFxuICAgICAgLy4qXFxiLyxcbiAgICAgIG9wdHMuYmluYXJ5LFxuICAgICAgL1xcYi4qLyk7XG4gIH1cbiAgcmV0dXJuIGluaGVyaXQoe1xuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIGJlZ2luOiBiZWdpblNoZWJhbmcsXG4gICAgZW5kOiAvJC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgIFwib246YmVnaW5cIjogKG0sIHJlc3ApID0+IHtcbiAgICAgIGlmIChtLmluZGV4ICE9PSAwKSByZXNwLmlnbm9yZU1hdGNoKCk7XG4gICAgfVxuICB9LCBvcHRzKTtcbn07XG5cbi8vIENvbW1vbiBtb2Rlc1xuY29uc3QgQkFDS1NMQVNIX0VTQ0FQRSA9IHtcbiAgYmVnaW46ICdcXFxcXFxcXFtcXFxcc1xcXFxTXScsIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IEFQT1NfU1RSSU5HX01PREUgPSB7XG4gIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gIGJlZ2luOiAnXFwnJyxcbiAgZW5kOiAnXFwnJyxcbiAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgY29udGFpbnM6IFtCQUNLU0xBU0hfRVNDQVBFXVxufTtcbmNvbnN0IFFVT1RFX1NUUklOR19NT0RFID0ge1xuICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICBiZWdpbjogJ1wiJyxcbiAgZW5kOiAnXCInLFxuICBpbGxlZ2FsOiAnXFxcXG4nLFxuICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG59O1xuY29uc3QgUEhSQVNBTF9XT1JEU19NT0RFID0ge1xuICBiZWdpbjogL1xcYihhfGFufHRoZXxhcmV8SSdtfGlzbid0fGRvbid0fGRvZXNuJ3R8d29uJ3R8YnV0fGp1c3R8c2hvdWxkfHByZXR0eXxzaW1wbHl8ZW5vdWdofGdvbm5hfGdvaW5nfHd0Znxzb3xzdWNofHdpbGx8eW91fHlvdXJ8dGhleXxsaWtlfG1vcmUpXFxiL1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIGNvbW1lbnQgbW9kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBiZWdpblxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWdFeHB9IGVuZFxuICogQHBhcmFtIHtNb2RlIHwge319IFttb2RlT3B0aW9uc11cbiAqIEByZXR1cm5zIHtQYXJ0aWFsPE1vZGU+fVxuICovXG5jb25zdCBDT01NRU5UID0gZnVuY3Rpb24oYmVnaW4sIGVuZCwgbW9kZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtb2RlID0gaW5oZXJpdChcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdjb21tZW50JyxcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kLFxuICAgICAgY29udGFpbnM6IFtdXG4gICAgfSxcbiAgICBtb2RlT3B0aW9uc1xuICApO1xuICBtb2RlLmNvbnRhaW5zLnB1c2goUEhSQVNBTF9XT1JEU19NT0RFKTtcbiAgbW9kZS5jb250YWlucy5wdXNoKHtcbiAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgIGJlZ2luOiAnKD86VE9ET3xGSVhNRXxOT1RFfEJVR3xPUFRJTUlaRXxIQUNLfFhYWCk6JyxcbiAgICByZWxldmFuY2U6IDBcbiAgfSk7XG4gIHJldHVybiBtb2RlO1xufTtcbmNvbnN0IENfTElORV9DT01NRU5UX01PREUgPSBDT01NRU5UKCcvLycsICckJyk7XG5jb25zdCBDX0JMT0NLX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJy9cXFxcKicsICdcXFxcKi8nKTtcbmNvbnN0IEhBU0hfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnIycsICckJyk7XG5jb25zdCBOVU1CRVJfTU9ERSA9IHtcbiAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgYmVnaW46IE5VTUJFUl9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgQ19OVU1CRVJfTU9ERSA9IHtcbiAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgYmVnaW46IENfTlVNQkVSX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBCSU5BUllfTlVNQkVSX01PREUgPSB7XG4gIGNsYXNzTmFtZTogJ251bWJlcicsXG4gIGJlZ2luOiBCSU5BUllfTlVNQkVSX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBDU1NfTlVNQkVSX01PREUgPSB7XG4gIGNsYXNzTmFtZTogJ251bWJlcicsXG4gIGJlZ2luOiBOVU1CRVJfUkUgKyAnKCcgK1xuICAgICclfGVtfGV4fGNofHJlbScgK1xuICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgJ3xjbXxtbXxpbnxwdHxwY3xweCcgK1xuICAgICd8ZGVnfGdyYWR8cmFkfHR1cm4nICtcbiAgICAnfHN8bXMnICtcbiAgICAnfEh6fGtIeicgK1xuICAgICd8ZHBpfGRwY218ZHBweCcgK1xuICAgICcpPycsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFJFR0VYUF9NT0RFID0ge1xuICAvLyB0aGlzIG91dGVyIHJ1bGUgbWFrZXMgc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgV0hPTEUgcmVnZXggYW5kIG5vdCBzaW1wbHlcbiAgLy8gYW4gZXhwcmVzc2lvbiBzdWNoIGFzOlxuICAvL1xuICAvLyAgICAgMyAvIHNvbWV0aGluZ1xuICAvL1xuICAvLyAod2hpY2ggd2lsbCB0aGVuIGJsb3cgdXAgd2hlbiByZWdleCdzIGBpbGxlZ2FsYCBzZWVzIHRoZSBuZXdsaW5lKVxuICBiZWdpbjogLyg/PVxcL1teL1xcbl0qXFwvKS8sXG4gIGNvbnRhaW5zOiBbe1xuICAgIGNsYXNzTmFtZTogJ3JlZ2V4cCcsXG4gICAgYmVnaW46IC9cXC8vLFxuICAgIGVuZDogL1xcL1tnaW11eV0qLyxcbiAgICBpbGxlZ2FsOiAvXFxuLyxcbiAgICBjb250YWluczogW1xuICAgICAgQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXFsvLFxuICAgICAgICBlbmQ6IC9cXF0vLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbQkFDS1NMQVNIX0VTQ0FQRV1cbiAgICAgIH1cbiAgICBdXG4gIH1dXG59O1xuY29uc3QgVElUTEVfTU9ERSA9IHtcbiAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICBiZWdpbjogSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICBiZWdpbjogVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuY29uc3QgTUVUSE9EX0dVQVJEID0ge1xuICAvLyBleGNsdWRlcyBtZXRob2QgbmFtZXMgZnJvbSBrZXl3b3JkIHByb2Nlc3NpbmdcbiAgYmVnaW46ICdcXFxcLlxcXFxzKicgKyBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5cbi8qKlxuICogQWRkcyBlbmQgc2FtZSBhcyBiZWdpbiBtZWNoYW5pY3MgdG8gYSBtb2RlXG4gKlxuICogWW91ciBtb2RlIG11c3QgaW5jbHVkZSBhdCBsZWFzdCBhIHNpbmdsZSAoKSBtYXRjaCBncm91cCBhcyB0aGF0IGZpcnN0IG1hdGNoXG4gKiBncm91cCBpcyB3aGF0IGlzIHVzZWQgZm9yIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7UGFydGlhbDxNb2RlPn0gbW9kZVxuICovXG5jb25zdCBFTkRfU0FNRV9BU19CRUdJTiA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obW9kZSxcbiAgICB7XG4gICAgICAvKiogQHR5cGUge01vZGVDYWxsYmFja30gKi9cbiAgICAgICdvbjpiZWdpbic6IChtLCByZXNwKSA9PiB7IHJlc3AuZGF0YS5fYmVnaW5NYXRjaCA9IG1bMV07IH0sXG4gICAgICAvKiogQHR5cGUge01vZGVDYWxsYmFja30gKi9cbiAgICAgICdvbjplbmQnOiAobSwgcmVzcCkgPT4geyBpZiAocmVzcC5kYXRhLl9iZWdpbk1hdGNoICE9PSBtWzFdKSByZXNwLmlnbm9yZU1hdGNoKCk7IH1cbiAgICB9KTtcbn07XG5cbnZhciBNT0RFUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgSURFTlRfUkU6IElERU5UX1JFLFxuICAgIFVOREVSU0NPUkVfSURFTlRfUkU6IFVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgTlVNQkVSX1JFOiBOVU1CRVJfUkUsXG4gICAgQ19OVU1CRVJfUkU6IENfTlVNQkVSX1JFLFxuICAgIEJJTkFSWV9OVU1CRVJfUkU6IEJJTkFSWV9OVU1CRVJfUkUsXG4gICAgUkVfU1RBUlRFUlNfUkU6IFJFX1NUQVJURVJTX1JFLFxuICAgIFNIRUJBTkc6IFNIRUJBTkcsXG4gICAgQkFDS1NMQVNIX0VTQ0FQRTogQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICBBUE9TX1NUUklOR19NT0RFOiBBUE9TX1NUUklOR19NT0RFLFxuICAgIFFVT1RFX1NUUklOR19NT0RFOiBRVU9URV9TVFJJTkdfTU9ERSxcbiAgICBQSFJBU0FMX1dPUkRTX01PREU6IFBIUkFTQUxfV09SRFNfTU9ERSxcbiAgICBDT01NRU5UOiBDT01NRU5ULFxuICAgIENfTElORV9DT01NRU5UX01PREU6IENfTElORV9DT01NRU5UX01PREUsXG4gICAgQ19CTE9DS19DT01NRU5UX01PREU6IENfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgIEhBU0hfQ09NTUVOVF9NT0RFOiBIQVNIX0NPTU1FTlRfTU9ERSxcbiAgICBOVU1CRVJfTU9ERTogTlVNQkVSX01PREUsXG4gICAgQ19OVU1CRVJfTU9ERTogQ19OVU1CRVJfTU9ERSxcbiAgICBCSU5BUllfTlVNQkVSX01PREU6IEJJTkFSWV9OVU1CRVJfTU9ERSxcbiAgICBDU1NfTlVNQkVSX01PREU6IENTU19OVU1CRVJfTU9ERSxcbiAgICBSRUdFWFBfTU9ERTogUkVHRVhQX01PREUsXG4gICAgVElUTEVfTU9ERTogVElUTEVfTU9ERSxcbiAgICBVTkRFUlNDT1JFX1RJVExFX01PREU6IFVOREVSU0NPUkVfVElUTEVfTU9ERSxcbiAgICBNRVRIT0RfR1VBUkQ6IE1FVEhPRF9HVUFSRCxcbiAgICBFTkRfU0FNRV9BU19CRUdJTjogRU5EX1NBTUVfQVNfQkVHSU5cbn0pO1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgLyBwbHVnaW5zXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4MzNcblxuLy8gR3JhbW1hciBleHRlbnNpb25zIGFsbG93IFwic3ludGFjdGljIHN1Z2FyXCIgdG8gYmUgYWRkZWQgdG8gdGhlIGdyYW1tYXIgbW9kZXNcbi8vIHdpdGhvdXQgcmVxdWlyaW5nIGFueSB1bmRlcmx5aW5nIGNoYW5nZXMgdG8gdGhlIGNvbXBpbGVyIGludGVybmFscy5cblxuLy8gYGNvbXBpbGVNYXRjaGAgYmVpbmcgdGhlIHBlcmZlY3Qgc21hbGwgZXhhbXBsZSBvZiBub3cgYWxsb3dpbmcgYSBncmFtbWFyXG4vLyBhdXRob3IgdG8gd3JpdGUgYG1hdGNoYCB3aGVuIHRoZXkgZGVzaXJlIHRvIG1hdGNoIGEgc2luZ2xlIGV4cHJlc3Npb24gcmF0aGVyXG4vLyB0aGFuIGJlaW5nIGZvcmNlZCB0byB1c2UgYGJlZ2luYC4gIFRoZSBleHRlbnNpb24gdGhlbiBqdXN0IG1vdmVzIGBtYXRjaGAgaW50b1xuLy8gYGJlZ2luYCB3aGVuIGl0IHJ1bnMuICBJZSwgbm8gZmVhdHVyZXMgaGF2ZSBiZWVuIGFkZGVkLCBidXQgd2UndmUganVzdCBtYWRlXG4vLyB0aGUgZXhwZXJpZW5jZSBvZiB3cml0aW5nIChhbmQgcmVhZGluZyBncmFtbWFycykgYSBsaXR0bGUgYml0IG5pY2VyLlxuXG4vLyAtLS0tLS1cblxuLy8gVE9ETzogV2UgbmVlZCBuZWdhdGl2ZSBsb29rLWJlaGluZCBzdXBwb3J0IHRvIGRvIHRoaXMgcHJvcGVybHlcbi8qKlxuICogU2tpcCBhIG1hdGNoIGlmIGl0IGhhcyBhIHByZWNlZGluZyBkb3RcbiAqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGBiZWdpbktleXdvcmRzYCB0byBwcmV2ZW50IG1hdGNoaW5nIGV4cHJlc3Npb25zIHN1Y2ggYXNcbiAqIGBib2Iua2V5d29yZC5kbygpYC4gVGhlIG1vZGUgY29tcGlsZXIgYXV0b21hdGljYWxseSB3aXJlcyB0aGlzIHVwIGFzIGFcbiAqIHNwZWNpYWwgX2ludGVybmFsXyAnb246YmVnaW4nIGNhbGxiYWNrIGZvciBtb2RlcyB3aXRoIGBiZWdpbktleXdvcmRzYFxuICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBza2lwSWZoYXNQcmVjZWRpbmdEb3QobWF0Y2gsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IGJlZm9yZSA9IG1hdGNoLmlucHV0W21hdGNoLmluZGV4IC0gMV07XG4gIGlmIChiZWZvcmUgPT09IFwiLlwiKSB7XG4gICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgfVxufVxuXG5cbi8qKlxuICogYGJlZ2luS2V5d29yZHNgIHN5bnRhY3RpYyBzdWdhclxuICogQHR5cGUge0NvbXBpbGVyRXh0fVxuICovXG5mdW5jdGlvbiBiZWdpbktleXdvcmRzKG1vZGUsIHBhcmVudCkge1xuICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICBpZiAoIW1vZGUuYmVnaW5LZXl3b3JkcykgcmV0dXJuO1xuXG4gIC8vIGZvciBsYW5ndWFnZXMgd2l0aCBrZXl3b3JkcyB0aGF0IGluY2x1ZGUgbm9uLXdvcmQgY2hhcmFjdGVycyBjaGVja2luZyBmb3JcbiAgLy8gYSB3b3JkIGJvdW5kYXJ5IGlzIG5vdCBzdWZmaWNpZW50LCBzbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBhIHdvcmQgYm91bmRhcnlcbiAgLy8gb3Igd2hpdGVzcGFjZSAtIHRoaXMgZG9lcyBubyBoYXJtIGluIGFueSBjYXNlIHNpbmNlIG91ciBrZXl3b3JkIGVuZ2luZVxuICAvLyBkb2Vzbid0IGFsbG93IHNwYWNlcyBpbiBrZXl3b3JkcyBhbnl3YXlzIGFuZCB3ZSBzdGlsbCBjaGVjayBmb3IgdGhlIGJvdW5kYXJ5XG4gIC8vIGZpcnN0XG4gIG1vZGUuYmVnaW4gPSAnXFxcXGIoJyArIG1vZGUuYmVnaW5LZXl3b3Jkcy5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcpKD8hXFxcXC4pKD89XFxcXGJ8XFxcXHMpJztcbiAgbW9kZS5fX2JlZm9yZUJlZ2luID0gc2tpcElmaGFzUHJlY2VkaW5nRG90O1xuICBtb2RlLmtleXdvcmRzID0gbW9kZS5rZXl3b3JkcyB8fCBtb2RlLmJlZ2luS2V5d29yZHM7XG4gIGRlbGV0ZSBtb2RlLmJlZ2luS2V5d29yZHM7XG59XG5cbi8qKlxuICogQWxsb3cgYGlsbGVnYWxgIHRvIGNvbnRhaW4gYW4gYXJyYXkgb2YgaWxsZWdhbCB2YWx1ZXNcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUlsbGVnYWwobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZS5pbGxlZ2FsKSkgcmV0dXJuO1xuXG4gIG1vZGUuaWxsZWdhbCA9IGVpdGhlciguLi5tb2RlLmlsbGVnYWwpO1xufVxuXG4vKipcbiAqIGBtYXRjaGAgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiBmb3IgcmVhZGFiaWxpdHlcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZU1hdGNoKG1vZGUsIF9wYXJlbnQpIHtcbiAgaWYgKCFtb2RlLm1hdGNoKSByZXR1cm47XG4gIGlmIChtb2RlLmJlZ2luIHx8IG1vZGUuZW5kKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpbiAmIGVuZCBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1hdGNoXCIpO1xuXG4gIG1vZGUuYmVnaW4gPSBtb2RlLm1hdGNoO1xuICBkZWxldGUgbW9kZS5tYXRjaDtcbn1cblxuLyoqXG4gKiBwcm92aWRlcyB0aGUgZGVmYXVsdCAxIHJlbGV2YW5jZSB0byBhbGwgbW9kZXNcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVJlbGV2YW5jZShtb2RlLCBfcGFyZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMTtcbn1cblxuLy8ga2V5d29yZHMgdGhhdCBzaG91bGQgaGF2ZSBubyBkZWZhdWx0IHJlbGV2YW5jZSB2YWx1ZVxuY29uc3QgQ09NTU9OX0tFWVdPUkRTID0gW1xuICAnb2YnLFxuICAnYW5kJyxcbiAgJ2ZvcicsXG4gICdpbicsXG4gICdub3QnLFxuICAnb3InLFxuICAnaWYnLFxuICAndGhlbicsXG4gICdwYXJlbnQnLCAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuICAnbGlzdCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICd2YWx1ZScgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbl07XG5cbi8qKlxuICogR2l2ZW4gcmF3IGtleXdvcmRzIGZyb20gYSBsYW5ndWFnZSBkZWZpbml0aW9uLCBjb21waWxlIHRoZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLHN0cmluZz59IHJhd0tleXdvcmRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNhc2VJbnNlbnNpdGl2ZVxuICovXG5mdW5jdGlvbiBjb21waWxlS2V5d29yZHMocmF3S2V5d29yZHMsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAvKiogQHR5cGUgS2V5d29yZERpY3QgKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcmF3S2V5d29yZHMgPT09ICdzdHJpbmcnKSB7IC8vIHN0cmluZ1xuICAgIHNwbGl0QW5kQ29tcGlsZSgna2V5d29yZCcsIHJhd0tleXdvcmRzKTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3Qua2V5cyhyYXdLZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHNwbGl0QW5kQ29tcGlsZShjbGFzc05hbWUsIHJhd0tleXdvcmRzW2NsYXNzTmFtZV0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb21waWxlZEtleXdvcmRzO1xuXG4gIC8vIC0tLVxuXG4gIC8qKlxuICAgKiBDb21waWxlcyBhbiBpbmRpdmlkdWFsIGxpc3Qgb2Yga2V5d29yZHNcbiAgICpcbiAgICogRXg6IFwiZm9yIGlmIHdoZW4gd2hpbGV8NVwiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleXdvcmRMaXN0XG4gICAqL1xuICBmdW5jdGlvbiBzcGxpdEFuZENvbXBpbGUoY2xhc3NOYW1lLCBrZXl3b3JkTGlzdCkge1xuICAgIGlmIChjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgIGtleXdvcmRMaXN0ID0ga2V5d29yZExpc3QudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAga2V5d29yZExpc3Quc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICAgIGNvbnN0IHBhaXIgPSBrZXl3b3JkLnNwbGl0KCd8Jyk7XG4gICAgICBjb21waWxlZEtleXdvcmRzW3BhaXJbMF1dID0gW2NsYXNzTmFtZSwgc2NvcmVGb3JLZXl3b3JkKHBhaXJbMF0sIHBhaXJbMV0pXTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb3BlciBzY29yZSBmb3IgYSBnaXZlbiBrZXl3b3JkXG4gKlxuICogQWxzbyB0YWtlcyBpbnRvIGFjY291bnQgY29tbWVudCBrZXl3b3Jkcywgd2hpY2ggd2lsbCBiZSBzY29yZWQgMCBVTkxFU1NcbiAqIGFub3RoZXIgc2NvcmUgaGFzIGJlZW4gbWFudWFsbHkgYXNzaWduZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZFxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm92aWRlZFNjb3JlXVxuICovXG5mdW5jdGlvbiBzY29yZUZvcktleXdvcmQoa2V5d29yZCwgcHJvdmlkZWRTY29yZSkge1xuICAvLyBtYW51YWwgc2NvcmVzIGFsd2F5cyB3aW4gb3ZlciBjb21tb24ga2V5d29yZHNcbiAgLy8gc28geW91IGNhbiBmb3JjZSBhIHNjb3JlIG9mIDEgaWYgeW91IHJlYWxseSBpbnNpc3RcbiAgaWYgKHByb3ZpZGVkU2NvcmUpIHtcbiAgICByZXR1cm4gTnVtYmVyKHByb3ZpZGVkU2NvcmUpO1xuICB9XG5cbiAgcmV0dXJuIGNvbW1vbktleXdvcmQoa2V5d29yZCkgPyAwIDogMTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4ga2V5d29yZCBpcyBjb21tb24gb3Igbm90XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleXdvcmQgKi9cbmZ1bmN0aW9uIGNvbW1vbktleXdvcmQoa2V5d29yZCkge1xuICByZXR1cm4gQ09NTU9OX0tFWVdPUkRTLmluY2x1ZGVzKGtleXdvcmQudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8vIGNvbXBpbGF0aW9uXG5cbi8qKlxuICogQ29tcGlsZXMgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHJlc3VsdFxuICpcbiAqIEdpdmVuIHRoZSByYXcgcmVzdWx0IG9mIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiAoTGFuZ3VhZ2UpLCBjb21waWxlcyB0aGlzIHNvXG4gKiB0aGF0IGl0IGlzIHJlYWR5IGZvciBoaWdobGlnaHRpbmcgY29kZS5cbiAqIEBwYXJhbSB7TGFuZ3VhZ2V9IGxhbmd1YWdlXG4gKiBAcGFyYW0ge3twbHVnaW5zOiBITEpTUGx1Z2luW119fSBvcHRzXG4gKiBAcmV0dXJucyB7Q29tcGlsZWRMYW5ndWFnZX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUxhbmd1YWdlKGxhbmd1YWdlLCB7IHBsdWdpbnMgfSkge1xuICAvKipcbiAgICogQnVpbGRzIGEgcmVnZXggd2l0aCB0aGUgY2FzZSBzZW5zYXRpdmlsaXR5IG9mIHRoZSBjdXJyZW50IGxhbmd1YWdlXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxdXG4gICAqL1xuICBmdW5jdGlvbiBsYW5nUmUodmFsdWUsIGdsb2JhbCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgc291cmNlKHZhbHVlKSxcbiAgICAgICdtJyArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICBTdG9yZXMgbXVsdGlwbGUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgYWxsb3dzIHlvdSB0byBxdWlja2x5IHNlYXJjaCBmb3JcbiAgICB0aGVtIGFsbCBpbiBhIHN0cmluZyBzaW11bHRhbmVvdXNseSAtIHJldHVybmluZyB0aGUgZmlyc3QgbWF0Y2guICBJdCBkb2VzXG4gICAgdGhpcyBieSBjcmVhdGluZyBhIGh1Z2UgKGF8YnxjKSByZWdleCAtIGVhY2ggaW5kaXZpZHVhbCBpdGVtIHdyYXBwZWQgd2l0aCAoKVxuICAgIGFuZCBqb2luZWQgYnkgYHxgIC0gdXNpbmcgbWF0Y2ggZ3JvdXBzIHRvIHRyYWNrIHBvc2l0aW9uLiAgV2hlbiBhIG1hdGNoIGlzXG4gICAgZm91bmQgY2hlY2tpbmcgd2hpY2ggcG9zaXRpb24gaW4gdGhlIGFycmF5IGhhcyBjb250ZW50IGFsbG93cyB1cyB0byBmaWd1cmVcbiAgICBvdXQgd2hpY2ggb2YgdGhlIG9yaWdpbmFsIHJlZ2V4ZXMgLyBtYXRjaCBncm91cHMgdHJpZ2dlcmVkIHRoZSBtYXRjaC5cblxuICAgIFRoZSBtYXRjaCBvYmplY3QgaXRzZWxmICh0aGUgcmVzdWx0IG9mIGBSZWdleC5leGVjYCkgaXMgcmV0dXJuZWQgYnV0IGFsc29cbiAgICBlbmhhbmNlZCBieSBtZXJnaW5nIGluIGFueSBtZXRhLWRhdGEgdGhhdCB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSByZWdleC5cbiAgICBUaGlzIGlzIGhvdyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG1vZGUgbWF0Y2hlZCwgYW5kIHdoYXQgdHlwZSBvZiBydWxlXG4gICAgKGBpbGxlZ2FsYCwgYGJlZ2luYCwgZW5kLCBldGMpLlxuICAqL1xuICBjbGFzcyBNdWx0aVJlZ2V4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzID0ge307XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMubWF0Y2hBdCA9IDE7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgb3B0cy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24rKztcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzW3RoaXMubWF0Y2hBdF0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWdleGVzLnB1c2goW29wdHMsIHJlXSk7XG4gICAgICB0aGlzLm1hdGNoQXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZSkgKyAxO1xuICAgIH1cblxuICAgIGNvbXBpbGUoKSB7XG4gICAgICBpZiAodGhpcy5yZWdleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBhdm9pZHMgdGhlIG5lZWQgdG8gY2hlY2sgbGVuZ3RoIGV2ZXJ5IHRpbWUgZXhlYyBpcyBjYWxsZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmV4ZWMgPSAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVybWluYXRvcnMgPSB0aGlzLnJlZ2V4ZXMubWFwKGVsID0+IGVsWzFdKTtcbiAgICAgIHRoaXMubWF0Y2hlclJlID0gbGFuZ1JlKGpvaW4odGVybWluYXRvcnMpLCB0cnVlKTtcbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHMgKi9cbiAgICBleGVjKHMpIHtcbiAgICAgIHRoaXMubWF0Y2hlclJlLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4O1xuICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm1hdGNoZXJSZS5leGVjKHMpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICBjb25zdCBpID0gbWF0Y2guZmluZEluZGV4KChlbCwgaSkgPT4gaSA+IDAgJiYgZWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBtYXRjaERhdGEgPSB0aGlzLm1hdGNoSW5kZXhlc1tpXTtcbiAgICAgIC8vIHRyaW0gb2ZmIGFueSBlYXJsaWVyIG5vbi1yZWxldmFudCBtYXRjaCBncm91cHMgKGllLCB0aGUgb3RoZXIgcmVnZXhcbiAgICAgIC8vIG1hdGNoIGdyb3VwcyB0aGF0IG1ha2UgdXAgdGhlIG11bHRpLW1hdGNoZXIpXG4gICAgICBtYXRjaC5zcGxpY2UoMCwgaSk7XG5cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG1hdGNoLCBtYXRjaERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgQ3JlYXRlZCB0byBzb2x2ZSB0aGUga2V5IGRlZmljaWVudGx5IHdpdGggTXVsdGlSZWdleCAtIHRoZXJlIGlzIG5vIHdheSB0b1xuICAgIHRlc3QgZm9yIG11bHRpcGxlIG1hdGNoZXMgYXQgYSBzaW5nbGUgbG9jYXRpb24uICBXaHkgd291bGQgd2UgbmVlZCB0byBkb1xuICAgIHRoYXQ/ICBJbiB0aGUgZnV0dXJlIGEgbW9yZSBkeW5hbWljIGVuZ2luZSB3aWxsIGFsbG93IGNlcnRhaW4gbWF0Y2hlcyB0byBiZVxuICAgIGlnbm9yZWQuICBBbiBleGFtcGxlOiBpZiB3ZSBtYXRjaGVkIHNheSB0aGUgM3JkIHJlZ2V4IGluIGEgbGFyZ2UgZ3JvdXAgYnV0XG4gICAgZGVjaWRlZCB0byBpZ25vcmUgaXQgLSB3ZSdkIG5lZWQgdG8gc3RhcnRlZCB0ZXN0aW5nIGFnYWluIGF0IHRoZSA0dGhcbiAgICByZWdleC4uLiBidXQgTXVsdGlSZWdleCBpdHNlbGYgZ2l2ZXMgdXMgbm8gcmVhbCB3YXkgdG8gZG8gdGhhdC5cblxuICAgIFNvIHdoYXQgdGhpcyBjbGFzcyBjcmVhdGVzIE11bHRpUmVnZXhzIG9uIHRoZSBmbHkgZm9yIHdoYXRldmVyIHNlYXJjaFxuICAgIHBvc2l0aW9uIHRoZXkgYXJlIG5lZWRlZC5cblxuICAgIE5PVEU6IFRoZXNlIGFkZGl0aW9uYWwgTXVsdGlSZWdleCBvYmplY3RzIGFyZSBjcmVhdGVkIGR5bmFtaWNhbGx5LiAgRm9yIG1vc3RcbiAgICBncmFtbWFycyBtb3N0IG9mIHRoZSB0aW1lIHdlIHdpbGwgbmV2ZXIgYWN0dWFsbHkgbmVlZCBhbnl0aGluZyBtb3JlIHRoYW4gdGhlXG4gICAgZmlyc3QgTXVsdGlSZWdleCAtIHNvIHRoaXMgc2hvdWxkbid0IGhhdmUgdG9vIG11Y2ggb3ZlcmhlYWQuXG5cbiAgICBTYXkgdGhpcyBpcyBvdXIgc2VhcmNoIGdyb3VwLCBhbmQgd2UgbWF0Y2ggcmVnZXgzLCBidXQgd2lzaCB0byBpZ25vcmUgaXQuXG5cbiAgICAgIHJlZ2V4MSB8IHJlZ2V4MiB8IHJlZ2V4MyB8IHJlZ2V4NCB8IHJlZ2V4NSAgICAnIGllLCBzdGFydEF0ID0gMFxuXG4gICAgV2hhdCB3ZSBuZWVkIGlzIGEgbmV3IE11bHRpUmVnZXggdGhhdCBvbmx5IGluY2x1ZGVzIHRoZSByZW1haW5pbmdcbiAgICBwb3NzaWJpbGl0aWVzOlxuXG4gICAgICByZWdleDQgfCByZWdleDUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpZSwgc3RhcnRBdCA9IDNcblxuICAgIFRoaXMgY2xhc3Mgd3JhcHMgYWxsIHRoYXQgY29tcGxleGl0eSB1cCBpbiBhIHNpbXBsZSBBUEkuLi4gYHN0YXJ0QXRgIGRlY2lkZXNcbiAgICB3aGVyZSBpbiB0aGUgYXJyYXkgb2YgZXhwcmVzc2lvbnMgdG8gc3RhcnQgZG9pbmcgdGhlIG1hdGNoaW5nLiBJdFxuICAgIGF1dG8taW5jcmVtZW50cywgc28gaWYgYSBtYXRjaCBpcyBmb3VuZCBhdCBwb3NpdGlvbiAyLCB0aGVuIHN0YXJ0QXQgd2lsbCBiZVxuICAgIHNldCB0byAzLiAgSWYgdGhlIGVuZCBpcyByZWFjaGVkIHN0YXJ0QXQgd2lsbCByZXR1cm4gdG8gMC5cblxuICAgIE1PU1Qgb2YgdGhlIHRpbWUgdGhlIHBhcnNlciB3aWxsIGJlIHNldHRpbmcgc3RhcnRBdCBtYW51YWxseSB0byAwLlxuICAqL1xuICBjbGFzcyBSZXN1bWFibGVNdWx0aVJlZ2V4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMucnVsZXMgPSBbXTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubXVsdGlSZWdleGVzID0gW107XG4gICAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgICAgdGhpcy5sYXN0SW5kZXggPSAwO1xuICAgICAgdGhpcy5yZWdleEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZ2V0TWF0Y2hlcihpbmRleCkge1xuICAgICAgaWYgKHRoaXMubXVsdGlSZWdleGVzW2luZGV4XSkgcmV0dXJuIHRoaXMubXVsdGlSZWdleGVzW2luZGV4XTtcblxuICAgICAgY29uc3QgbWF0Y2hlciA9IG5ldyBNdWx0aVJlZ2V4KCk7XG4gICAgICB0aGlzLnJ1bGVzLnNsaWNlKGluZGV4KS5mb3JFYWNoKChbcmUsIG9wdHNdKSA9PiBtYXRjaGVyLmFkZFJ1bGUocmUsIG9wdHMpKTtcbiAgICAgIG1hdGNoZXIuY29tcGlsZSgpO1xuICAgICAgdGhpcy5tdWx0aVJlZ2V4ZXNbaW5kZXhdID0gbWF0Y2hlcjtcbiAgICAgIHJldHVybiBtYXRjaGVyO1xuICAgIH1cblxuICAgIHJlc3VtaW5nU2NhbkF0U2FtZVBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnZXhJbmRleCAhPT0gMDtcbiAgICB9XG5cbiAgICBjb25zaWRlckFsbCgpIHtcbiAgICAgIHRoaXMucmVnZXhJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFkZFJ1bGUocmUsIG9wdHMpIHtcbiAgICAgIHRoaXMucnVsZXMucHVzaChbcmUsIG9wdHNdKTtcbiAgICAgIGlmIChvcHRzLnR5cGUgPT09IFwiYmVnaW5cIikgdGhpcy5jb3VudCsrO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gcyAqL1xuICAgIGV4ZWMocykge1xuICAgICAgY29uc3QgbSA9IHRoaXMuZ2V0TWF0Y2hlcih0aGlzLnJlZ2V4SW5kZXgpO1xuICAgICAgbS5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleDtcbiAgICAgIGxldCByZXN1bHQgPSBtLmV4ZWMocyk7XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYmVjYXVzZSB3ZSBoYXZlIG5vIGVhc3kgd2F5IHRvIHNheSBcInJlc3VtZSBzY2FubmluZyBhdCB0aGVcbiAgICAgIC8vIGV4aXN0aW5nIHBvc2l0aW9uIGJ1dCBhbHNvIHNraXAgdGhlIGN1cnJlbnQgcnVsZSBPTkxZXCIuIFdoYXQgaGFwcGVucyBpc1xuICAgICAgLy8gYWxsIHByaW9yIHJ1bGVzIGFyZSBhbHNvIHNraXBwZWQgd2hpY2ggY2FuIHJlc3VsdCBpbiBtYXRjaGluZyB0aGUgd3JvbmdcbiAgICAgIC8vIHRoaW5nLiBFeGFtcGxlIG9mIG1hdGNoaW5nIFwiYm9vZ2VyXCI6XG5cbiAgICAgIC8vIG91ciBtYXRjaGVyIGlzIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vXG4gICAgICAvLyAuLi4uYm9vZ2VyLi4uLlxuXG4gICAgICAvLyBpZiBcImJvb2dlclwiIGlzIGlnbm9yZWQgdGhlbiB3ZSdkIHJlYWxseSBuZWVkIGEgcmVnZXggdG8gc2NhbiBmcm9tIHRoZVxuICAgICAgLy8gU0FNRSBwb3NpdGlvbiBmb3Igb25seTogW3N0cmluZywgbnVtYmVyXSBidXQgaWdub3JpbmcgXCJib29nZXJcIiAoaWYgaXRcbiAgICAgIC8vIHdhcyB0aGUgZmlyc3QgbWF0Y2gpLCBhIHNpbXBsZSByZXN1bWUgd291bGQgc2NhbiBhaGVhZCB3aG8ga25vd3MgaG93XG4gICAgICAvLyBmYXIgbG9va2luZyBvbmx5IGZvciBcIm51bWJlclwiLCBpZ25vcmluZyBwb3RlbnRpYWwgc3RyaW5nIG1hdGNoZXMgKG9yXG4gICAgICAvLyBmdXR1cmUgXCJib29nZXJcIiBtYXRjaGVzIHRoYXQgbWlnaHQgYmUgdmFsaWQuKVxuXG4gICAgICAvLyBTbyB3aGF0IHdlIGRvOiBXZSBleGVjdXRlIHR3byBtYXRjaGVycywgb25lIHJlc3VtaW5nIGF0IHRoZSBzYW1lXG4gICAgICAvLyBwb3NpdGlvbiwgYnV0IHRoZSBzZWNvbmQgZnVsbCBtYXRjaGVyIHN0YXJ0aW5nIGF0IHRoZSBwb3NpdGlvbiBhZnRlcjpcblxuICAgICAgLy8gICAgIC8tLS0gcmVzdW1lIGZpcnN0IHJlZ2V4IG1hdGNoIGhlcmUgKGZvciBbbnVtYmVyXSlcbiAgICAgIC8vICAgICB8Ly0tLS0gZnVsbCBtYXRjaCBoZXJlIGZvciBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvLyAgICAgdnZcbiAgICAgIC8vIC4uLi5ib29nZXIuLi4uXG5cbiAgICAgIC8vIFdoaWNoIGV2ZXIgcmVzdWx0cyBpbiBhIG1hdGNoIGZpcnN0IGlzIHRoZW4gdXNlZC4gU28gdGhpcyAzLTQgc3RlcFxuICAgICAgLy8gcHJvY2VzcyBlc3NlbnRpYWxseSBhbGxvd3MgdXMgdG8gc2F5IFwibWF0Y2ggYXQgdGhpcyBwb3NpdGlvbiwgZXhjbHVkaW5nXG4gICAgICAvLyBhIHByaW9yIHJ1bGUgdGhhdCB3YXMgaWdub3JlZFwiLlxuICAgICAgLy9cbiAgICAgIC8vIDEuIE1hdGNoIFwiYm9vZ2VyXCIgZmlyc3QsIGlnbm9yZS4gQWxzbyBwcm92ZXMgdGhhdCBbc3RyaW5nXSBkb2VzIG5vbiBtYXRjaC5cbiAgICAgIC8vIDIuIFJlc3VtZSBtYXRjaGluZyBmb3IgW251bWJlcl1cbiAgICAgIC8vIDMuIE1hdGNoIGF0IGluZGV4ICsgMSBmb3IgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy8gNC4gSWYgIzIgYW5kICMzIHJlc3VsdCBpbiBtYXRjaGVzLCB3aGljaCBjYW1lIGZpcnN0P1xuICAgICAgaWYgKHRoaXMucmVzdW1pbmdTY2FuQXRTYW1lUG9zaXRpb24oKSkge1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5pbmRleCA9PT0gdGhpcy5sYXN0SW5kZXgpIDsgZWxzZSB7IC8vIHVzZSB0aGUgc2Vjb25kIG1hdGNoZXIgcmVzdWx0XG4gICAgICAgICAgY29uc3QgbTIgPSB0aGlzLmdldE1hdGNoZXIoMCk7XG4gICAgICAgICAgbTIubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXggKyAxO1xuICAgICAgICAgIHJlc3VsdCA9IG0yLmV4ZWMocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0aGlzLnJlZ2V4SW5kZXggKz0gcmVzdWx0LnBvc2l0aW9uICsgMTtcbiAgICAgICAgaWYgKHRoaXMucmVnZXhJbmRleCA9PT0gdGhpcy5jb3VudCkge1xuICAgICAgICAgIC8vIHdyYXAtYXJvdW5kIHRvIGNvbnNpZGVyaW5nIGFsbCBtYXRjaGVzIGFnYWluXG4gICAgICAgICAgdGhpcy5jb25zaWRlckFsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbW9kZSwgYnVpbGRzIGEgaHVnZSBSZXN1bWFibGVNdWx0aVJlZ2V4IHRoYXQgY2FuIGJlIHVzZWQgdG8gd2Fsa1xuICAgKiB0aGUgY29udGVudCBhbmQgZmluZCBtYXRjaGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICAgKiBAcmV0dXJucyB7UmVzdW1hYmxlTXVsdGlSZWdleH1cbiAgICovXG4gIGZ1bmN0aW9uIGJ1aWxkTW9kZVJlZ2V4KG1vZGUpIHtcbiAgICBjb25zdCBtbSA9IG5ldyBSZXN1bWFibGVNdWx0aVJlZ2V4KCk7XG5cbiAgICBtb2RlLmNvbnRhaW5zLmZvckVhY2godGVybSA9PiBtbS5hZGRSdWxlKHRlcm0uYmVnaW4sIHsgcnVsZTogdGVybSwgdHlwZTogXCJiZWdpblwiIH0pKTtcblxuICAgIGlmIChtb2RlLnRlcm1pbmF0b3JFbmQpIHtcbiAgICAgIG1tLmFkZFJ1bGUobW9kZS50ZXJtaW5hdG9yRW5kLCB7IHR5cGU6IFwiZW5kXCIgfSk7XG4gICAgfVxuICAgIGlmIChtb2RlLmlsbGVnYWwpIHtcbiAgICAgIG1tLmFkZFJ1bGUobW9kZS5pbGxlZ2FsLCB7IHR5cGU6IFwiaWxsZWdhbFwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtbTtcbiAgfVxuXG4gIC8qKiBza2lwIHZzIGFib3J0IHZzIGlnbm9yZVxuICAgKlxuICAgKiBAc2tpcCAgIC0gVGhlIG1vZGUgaXMgc3RpbGwgZW50ZXJlZCBhbmQgZXhpdGVkIG5vcm1hbGx5IChhbmQgY29udGFpbnMgcnVsZXMgYXBwbHkpLFxuICAgKiAgICAgICAgICAgYnV0IGFsbCBjb250ZW50IGlzIGhlbGQgYW5kIGFkZGVkIHRvIHRoZSBwYXJlbnQgYnVmZmVyIHJhdGhlciB0aGFuIGJlaW5nXG4gICAqICAgICAgICAgICBvdXRwdXQgd2hlbiB0aGUgbW9kZSBlbmRzLiAgTW9zdGx5IHVzZWQgd2l0aCBgc3VibGFuZ3VhZ2VgIHRvIGJ1aWxkIHVwXG4gICAqICAgICAgICAgICBhIHNpbmdsZSBsYXJnZSBidWZmZXIgdGhhbiBjYW4gYmUgcGFyc2VkIGJ5IHN1Ymxhbmd1YWdlLlxuICAgKlxuICAgKiAgICAgICAgICAgICAtIFRoZSBtb2RlIGJlZ2luIGFuZHMgZW5kcyBub3JtYWxseS5cbiAgICogICAgICAgICAgICAgLSBDb250ZW50IG1hdGNoZWQgaXMgYWRkZWQgdG8gdGhlIHBhcmVudCBtb2RlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgLSBUaGUgcGFyc2VyIGN1cnNvciBpcyBtb3ZlZCBmb3J3YXJkIG5vcm1hbGx5LlxuICAgKlxuICAgKiBAYWJvcnQgIC0gQSBoYWNrIHBsYWNlaG9sZGVyIHVudGlsIHdlIGhhdmUgaWdub3JlLiAgQWJvcnRzIHRoZSBtb2RlIChhcyBpZiBpdFxuICAgKiAgICAgICAgICAgbmV2ZXIgbWF0Y2hlZCkgYnV0IERPRVMgTk9UIGNvbnRpbnVlIHRvIG1hdGNoIHN1YnNlcXVlbnQgYGNvbnRhaW5zYFxuICAgKiAgICAgICAgICAgbW9kZXMuICBBYm9ydCBpcyBiYWQvc3Vib3B0aW1hbCBiZWNhdXNlIGl0IGNhbiByZXN1bHQgaW4gbW9kZXNcbiAgICogICAgICAgICAgIGZhcnRoZXIgZG93biBub3QgZ2V0dGluZyBhcHBsaWVkIGJlY2F1c2UgYW4gZWFybGllciBydWxlIGVhdHMgdGhlXG4gICAqICAgICAgICAgICBjb250ZW50IGJ1dCB0aGVuIGFib3J0cy5cbiAgICpcbiAgICogICAgICAgICAgICAgLSBUaGUgbW9kZSBkb2VzIG5vdCBiZWdpbi5cbiAgICogICAgICAgICAgICAgLSBDb250ZW50IG1hdGNoZWQgYnkgYGJlZ2luYCBpcyBhZGRlZCB0byB0aGUgbW9kZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgIC0gVGhlIHBhcnNlciBjdXJzb3IgaXMgbW92ZWQgZm9yd2FyZCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQGlnbm9yZSAtIElnbm9yZXMgdGhlIG1vZGUgKGFzIGlmIGl0IG5ldmVyIG1hdGNoZWQpIGFuZCBjb250aW51ZXMgdG8gbWF0Y2ggYW55XG4gICAqICAgICAgICAgICBzdWJzZXF1ZW50IGBjb250YWluc2AgbW9kZXMuICBJZ25vcmUgaXNuJ3QgdGVjaG5pY2FsbHkgcG9zc2libGUgd2l0aFxuICAgKiAgICAgICAgICAgdGhlIGN1cnJlbnQgcGFyc2VyIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiAgICAgICAgICAgICAtIFRoZSBtb2RlIGRvZXMgbm90IGJlZ2luLlxuICAgKiAgICAgICAgICAgICAtIENvbnRlbnQgbWF0Y2hlZCBieSBgYmVnaW5gIGlzIGlnbm9yZWQuXG4gICAqICAgICAgICAgICAgIC0gVGhlIHBhcnNlciBjdXJzb3IgaXMgbm90IG1vdmVkIGZvcndhcmQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb21waWxlcyBhbiBpbmRpdmlkdWFsIG1vZGVcbiAgICpcbiAgICogVGhpcyBjYW4gcmFpc2UgYW4gZXJyb3IgaWYgdGhlIG1vZGUgY29udGFpbnMgY2VydGFpbiBkZXRlY3RhYmxlIGtub3duIGxvZ2ljXG4gICAqIGlzc3Vlcy5cbiAgICogQHBhcmFtIHtNb2RlfSBtb2RlXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlIHwgbnVsbH0gW3BhcmVudF1cbiAgICogQHJldHVybnMge0NvbXBpbGVkTW9kZSB8IG5ldmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGlsZU1vZGUobW9kZSwgcGFyZW50KSB7XG4gICAgY29uc3QgY21vZGUgPSAvKiogQHR5cGUgQ29tcGlsZWRNb2RlICovIChtb2RlKTtcbiAgICBpZiAobW9kZS5jb21waWxlZCkgcmV0dXJuIGNtb2RlO1xuXG4gICAgW1xuICAgICAgLy8gZG8gdGhpcyBlYXJseSBzbyBjb21waWxlciBleHRlbnNpb25zIGdlbmVyYWxseSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgICAvLyB0aGUgZGlzdGluY3Rpb24gYmV0d2VlbiBtYXRjaC9iZWdpblxuICAgICAgY29tcGlsZU1hdGNoXG4gICAgXS5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICBsYW5ndWFnZS5jb21waWxlckV4dGVuc2lvbnMuZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgLy8gX19iZWZvcmVCZWdpbiBpcyBjb25zaWRlcmVkIHByaXZhdGUgQVBJLCBpbnRlcm5hbCB1c2Ugb25seVxuICAgIG1vZGUuX19iZWZvcmVCZWdpbiA9IG51bGw7XG5cbiAgICBbXG4gICAgICBiZWdpbktleXdvcmRzLFxuICAgICAgLy8gZG8gdGhpcyBsYXRlciBzbyBjb21waWxlciBleHRlbnNpb25zIHRoYXQgY29tZSBlYXJsaWVyIGhhdmUgYWNjZXNzIHRvIHRoZVxuICAgICAgLy8gcmF3IGFycmF5IGlmIHRoZXkgd2FudGVkIHRvIHBlcmhhcHMgbWFuaXB1bGF0ZSBpdCwgZXRjLlxuICAgICAgY29tcGlsZUlsbGVnYWwsXG4gICAgICAvLyBkZWZhdWx0IHRvIDEgcmVsZXZhbmNlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNvbXBpbGVSZWxldmFuY2VcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIG1vZGUuY29tcGlsZWQgPSB0cnVlO1xuXG4gICAgbGV0IGtleXdvcmRQYXR0ZXJuID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG1vZGUua2V5d29yZHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGtleXdvcmRQYXR0ZXJuID0gbW9kZS5rZXl3b3Jkcy4kcGF0dGVybjtcbiAgICAgIGRlbGV0ZSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgIH1cblxuICAgIGlmIChtb2RlLmtleXdvcmRzKSB7XG4gICAgICBtb2RlLmtleXdvcmRzID0gY29tcGlsZUtleXdvcmRzKG1vZGUua2V5d29yZHMsIGxhbmd1YWdlLmNhc2VfaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIC8vIGJvdGggYXJlIG5vdCBhbGxvd2VkXG4gICAgaWYgKG1vZGUubGV4ZW1lcyAmJiBrZXl3b3JkUGF0dGVybikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJSOiBQcmVmZXIgYGtleXdvcmRzLiRwYXR0ZXJuYCB0byBgbW9kZS5sZXhlbWVzYCwgQk9USCBhcmUgbm90IGFsbG93ZWQuIChzZWUgbW9kZSByZWZlcmVuY2UpIFwiKTtcbiAgICB9XG5cbiAgICAvLyBgbW9kZS5sZXhlbWVzYCB3YXMgdGhlIG9sZCBzdGFuZGFyZCBiZWZvcmUgd2UgYWRkZWQgYW5kIG5vdyByZWNvbW1lbmRcbiAgICAvLyB1c2luZyBga2V5d29yZHMuJHBhdHRlcm5gIHRvIHBhc3MgdGhlIGtleXdvcmQgcGF0dGVyblxuICAgIGtleXdvcmRQYXR0ZXJuID0ga2V5d29yZFBhdHRlcm4gfHwgbW9kZS5sZXhlbWVzIHx8IC9cXHcrLztcbiAgICBjbW9kZS5rZXl3b3JkUGF0dGVyblJlID0gbGFuZ1JlKGtleXdvcmRQYXR0ZXJuLCB0cnVlKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmICghbW9kZS5iZWdpbikgbW9kZS5iZWdpbiA9IC9cXEJ8XFxiLztcbiAgICAgIGNtb2RlLmJlZ2luUmUgPSBsYW5nUmUobW9kZS5iZWdpbik7XG4gICAgICBpZiAobW9kZS5lbmRTYW1lQXNCZWdpbikgbW9kZS5lbmQgPSBtb2RlLmJlZ2luO1xuICAgICAgaWYgKCFtb2RlLmVuZCAmJiAhbW9kZS5lbmRzV2l0aFBhcmVudCkgbW9kZS5lbmQgPSAvXFxCfFxcYi87XG4gICAgICBpZiAobW9kZS5lbmQpIGNtb2RlLmVuZFJlID0gbGFuZ1JlKG1vZGUuZW5kKTtcbiAgICAgIGNtb2RlLnRlcm1pbmF0b3JFbmQgPSBzb3VyY2UobW9kZS5lbmQpIHx8ICcnO1xuICAgICAgaWYgKG1vZGUuZW5kc1dpdGhQYXJlbnQgJiYgcGFyZW50LnRlcm1pbmF0b3JFbmQpIHtcbiAgICAgICAgY21vZGUudGVybWluYXRvckVuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvckVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkgY21vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKC8qKiBAdHlwZSB7UmVnRXhwIHwgc3RyaW5nfSAqLyAobW9kZS5pbGxlZ2FsKSk7XG4gICAgaWYgKCFtb2RlLmNvbnRhaW5zKSBtb2RlLmNvbnRhaW5zID0gW107XG5cbiAgICBtb2RlLmNvbnRhaW5zID0gW10uY29uY2F0KC4uLm1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBleHBhbmRPckNsb25lTW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYyk7XG4gICAgfSkpO1xuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7IGNvbXBpbGVNb2RlKC8qKiBAdHlwZSBNb2RlICovIChjKSwgY21vZGUpOyB9KTtcblxuICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgY21vZGUubWF0Y2hlciA9IGJ1aWxkTW9kZVJlZ2V4KGNtb2RlKTtcbiAgICByZXR1cm4gY21vZGU7XG4gIH1cblxuICBpZiAoIWxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucykgbGFuZ3VhZ2UuY29tcGlsZXJFeHRlbnNpb25zID0gW107XG5cbiAgLy8gc2VsZiBpcyBub3QgdmFsaWQgYXQgdGhlIHRvcC1sZXZlbFxuICBpZiAobGFuZ3VhZ2UuY29udGFpbnMgJiYgbGFuZ3VhZ2UuY29udGFpbnMuaW5jbHVkZXMoJ3NlbGYnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVSUjogY29udGFpbnMgYHNlbGZgIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIGxhbmd1YWdlLiAgU2VlIGRvY3VtZW50YXRpb24uXCIpO1xuICB9XG5cbiAgLy8gd2UgbmVlZCBhIG51bGwgb2JqZWN0LCB3aGljaCBpbmhlcml0IHdpbGwgZ3VhcmFudGVlXG4gIGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgPSBpbmhlcml0KGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgfHwge30pO1xuXG4gIHJldHVybiBjb21waWxlTW9kZSgvKiogQHR5cGUgTW9kZSAqLyAobGFuZ3VhZ2UpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgbW9kZSBoYXMgYSBkZXBlbmRlbmN5IG9uIGl0J3MgcGFyZW50IG9yIG5vdFxuICpcbiAqIElmIGEgbW9kZSBkb2VzIGhhdmUgYSBwYXJlbnQgZGVwZW5kZW5jeSB0aGVuIG9mdGVuIHdlIG5lZWQgdG8gY2xvbmUgaXQgaWZcbiAqIGl0J3MgdXNlZCBpbiBtdWx0aXBsZSBwbGFjZXMgc28gdGhhdCBlYWNoIGNvcHkgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IHBhcmVudCxcbiAqIHdoZXJlLWFzIG1vZGVzIHdpdGhvdXQgYSBwYXJlbnQgY2FuIG9mdGVuIHNhZmVseSBiZSByZS11c2VkIGF0IHRoZSBib3R0b20gb2ZcbiAqIGEgbW9kZSBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge01vZGUgfCBudWxsfSBtb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBpcyB0aGVyZSBhIGRlcGVuZGVuY3kgb24gdGhlIHBhcmVudD9cbiAqICovXG5mdW5jdGlvbiBkZXBlbmRlbmN5T25QYXJlbnQobW9kZSkge1xuICBpZiAoIW1vZGUpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gbW9kZS5lbmRzV2l0aFBhcmVudCB8fCBkZXBlbmRlbmN5T25QYXJlbnQobW9kZS5zdGFydHMpO1xufVxuXG4vKipcbiAqIEV4cGFuZHMgYSBtb2RlIG9yIGNsb25lcyBpdCBpZiBuZWNlc3NhcnlcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbW9kZXMgd2l0aCBwYXJlbnRhbCBkZXBlbmRlbmNlaXMgKHNlZSBub3RlcyBvblxuICogYGRlcGVuZGVuY3lPblBhcmVudGApIGFuZCBmb3Igbm9kZXMgdGhhdCBoYXZlIGB2YXJpYW50c2AgLSB3aGljaCBtdXN0IHRoZW4gYmVcbiAqIGV4cGxvZGVkIGludG8gdGhlaXIgb3duIGluZGl2aWR1YWwgbW9kZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICogQHJldHVybnMge01vZGUgfCBNb2RlW119XG4gKiAqL1xuZnVuY3Rpb24gZXhwYW5kT3JDbG9uZU1vZGUobW9kZSkge1xuICBpZiAobW9kZS52YXJpYW50cyAmJiAhbW9kZS5jYWNoZWRWYXJpYW50cykge1xuICAgIG1vZGUuY2FjaGVkVmFyaWFudHMgPSBtb2RlLnZhcmlhbnRzLm1hcChmdW5jdGlvbih2YXJpYW50KSB7XG4gICAgICByZXR1cm4gaW5oZXJpdChtb2RlLCB7IHZhcmlhbnRzOiBudWxsIH0sIHZhcmlhbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRVhQQU5EXG4gIC8vIGlmIHdlIGhhdmUgdmFyaWFudHMgdGhlbiBlc3NlbnRpYWxseSBcInJlcGxhY2VcIiB0aGUgbW9kZSB3aXRoIHRoZSB2YXJpYW50c1xuICAvLyB0aGlzIGhhcHBlbnMgaW4gY29tcGlsZU1vZGUsIHdoZXJlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZyb21cbiAgaWYgKG1vZGUuY2FjaGVkVmFyaWFudHMpIHtcbiAgICByZXR1cm4gbW9kZS5jYWNoZWRWYXJpYW50cztcbiAgfVxuXG4gIC8vIENMT05FXG4gIC8vIGlmIHdlIGhhdmUgZGVwZW5kZW5jaWVzIG9uIHBhcmVudHMgdGhlbiB3ZSBuZWVkIGEgdW5pcXVlXG4gIC8vIGluc3RhbmNlIG9mIG91cnNlbHZlcywgc28gd2UgY2FuIGJlIHJldXNlZCB3aXRoIG1hbnlcbiAgLy8gZGlmZmVyZW50IHBhcmVudHMgd2l0aG91dCBpc3N1ZVxuICBpZiAoZGVwZW5kZW5jeU9uUGFyZW50KG1vZGUpKSB7XG4gICAgcmV0dXJuIGluaGVyaXQobW9kZSwgeyBzdGFydHM6IG1vZGUuc3RhcnRzID8gaW5oZXJpdChtb2RlLnN0YXJ0cykgOiBudWxsIH0pO1xuICB9XG5cbiAgaWYgKE9iamVjdC5pc0Zyb3plbihtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0KG1vZGUpO1xuICB9XG5cbiAgLy8gbm8gc3BlY2lhbCBkZXBlbmRlbmN5IGlzc3VlcywganVzdCByZXR1cm4gb3Vyc2VsdmVzXG4gIHJldHVybiBtb2RlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMTAuNS4wXCI7XG5cbi8vIEB0cy1ub2NoZWNrXG5cbmZ1bmN0aW9uIGhhc1ZhbHVlT3JFbXB0eUF0dHJpYnV0ZSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJcIik7XG59XG5cbmZ1bmN0aW9uIEJ1aWxkVnVlUGx1Z2luKGhsanMpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0ge1xuICAgIHByb3BzOiBbXCJsYW5ndWFnZVwiLCBcImNvZGVcIiwgXCJhdXRvZGV0ZWN0XCJdLFxuICAgIGRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZTogXCJcIixcbiAgICAgICAgdW5rbm93bkxhbmd1YWdlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjbGFzc05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVua25vd25MYW5ndWFnZSkgcmV0dXJuIFwiXCI7XG5cbiAgICAgICAgcmV0dXJuIFwiaGxqcyBcIiArIHRoaXMuZGV0ZWN0ZWRMYW5ndWFnZTtcbiAgICAgIH0sXG4gICAgICBoaWdobGlnaHRlZCgpIHtcbiAgICAgICAgLy8gbm8gaWRlYSB3aGF0IGxhbmd1YWdlIHRvIHVzZSwgcmV0dXJuIHJhdyBjb2RlXG4gICAgICAgIGlmICghdGhpcy5hdXRvRGV0ZWN0ICYmICFobGpzLmdldExhbmd1YWdlKHRoaXMubGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgbGFuZ3VhZ2UgXCIke3RoaXMubGFuZ3VhZ2V9XCIgeW91IHNwZWNpZmllZCBjb3VsZCBub3QgYmUgZm91bmQuYCk7XG4gICAgICAgICAgdGhpcy51bmtub3duTGFuZ3VhZ2UgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBlc2NhcGVIVE1MKHRoaXMuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZXRlY3QpIHtcbiAgICAgICAgICByZXN1bHQgPSBobGpzLmhpZ2hsaWdodEF1dG8odGhpcy5jb2RlKTtcbiAgICAgICAgICB0aGlzLmRldGVjdGVkTGFuZ3VhZ2UgPSByZXN1bHQubGFuZ3VhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gaGxqcy5oaWdobGlnaHQodGhpcy5sYW5ndWFnZSwgdGhpcy5jb2RlLCB0aGlzLmlnbm9yZUlsbGVnYWxzKTtcbiAgICAgICAgICB0aGlzLmRldGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLmxhbmd1YWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICB9LFxuICAgICAgYXV0b0RldGVjdCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmxhbmd1YWdlIHx8IGhhc1ZhbHVlT3JFbXB0eUF0dHJpYnV0ZSh0aGlzLmF1dG9kZXRlY3QpO1xuICAgICAgfSxcbiAgICAgIGlnbm9yZUlsbGVnYWxzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIHRoaXMgYXZvaWRzIG5lZWRpbmcgdG8gdXNlIGEgd2hvbGUgVnVlIGNvbXBpbGF0aW9uIHBpcGVsaW5lIGp1c3RcbiAgICAvLyB0byBidWlsZCBIaWdobGlnaHQuanNcbiAgICByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge30sIFtcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgICAgIGNsYXNzOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IHRoaXMuaGlnaGxpZ2h0ZWQgfVxuICAgICAgICB9KVxuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIHRlbXBsYXRlOiBgPHByZT48Y29kZSA6Y2xhc3M9XCJjbGFzc05hbWVcIiB2LWh0bWw9XCJoaWdobGlnaHRlZFwiPjwvY29kZT48L3ByZT5gXG4gIH07XG5cbiAgY29uc3QgVnVlUGx1Z2luID0ge1xuICAgIGluc3RhbGwoVnVlKSB7XG4gICAgICBWdWUuY29tcG9uZW50KCdoaWdobGlnaHRqcycsIENvbXBvbmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IENvbXBvbmVudCwgVnVlUGx1Z2luIH07XG59XG5cbi8qIHBsdWdpbiBpdHNlbGYgKi9cblxuLyoqIEB0eXBlIHtITEpTUGx1Z2lufSAqL1xuY29uc3QgbWVyZ2VIVE1MUGx1Z2luID0ge1xuICBcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCI6ICh7IGJsb2NrLCByZXN1bHQsIHRleHQgfSkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RyZWFtID0gbm9kZVN0cmVhbShibG9jayk7XG4gICAgaWYgKCFvcmlnaW5hbFN0cmVhbS5sZW5ndGgpIHJldHVybjtcblxuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXN1bHROb2RlLmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICByZXN1bHQudmFsdWUgPSBtZXJnZVN0cmVhbXMob3JpZ2luYWxTdHJlYW0sIG5vZGVTdHJlYW0ocmVzdWx0Tm9kZSksIHRleHQpO1xuICB9XG59O1xuXG4vKiBTdHJlYW0gbWVyZ2luZyBzdXBwb3J0IGZ1bmN0aW9ucyAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEV2ZW50XG4gKiBAcHJvcGVydHkgeydzdGFydCd8J3N0b3AnfSBldmVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtOb2RlfSBub2RlXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gdGFnKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gbm9kZVN0cmVhbShub2RlKSB7XG4gIC8qKiBAdHlwZSBFdmVudFtdICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAoZnVuY3Rpb24gX25vZGVTdHJlYW0obm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gX25vZGVTdHJlYW0oY2hpbGQsIG9mZnNldCk7XG4gICAgICAgIC8vIFByZXZlbnQgdm9pZCBlbGVtZW50cyBmcm9tIGhhdmluZyBhbiBlbmQgdGFnIHRoYXQgd291bGQgYWN0dWFsbHlcbiAgICAgICAgLy8gZG91YmxlIHRoZW0gaW4gdGhlIG91dHB1dC4gVGhlcmUgYXJlIG1vcmUgdm9pZCBlbGVtZW50cyBpbiBIVE1MXG4gICAgICAgIC8vIGJ1dCB3ZSBsaXN0IG9ubHkgdGhvc2UgcmVhbGlzdGljYWxseSBleHBlY3RlZCBpbiBjb2RlIGRpc3BsYXkuXG4gICAgICAgIGlmICghdGFnKGNoaWxkKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0LykpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBldmVudDogJ3N0b3AnLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0pKG5vZGUsIDApO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5hbCAtIHRoZSBvcmlnaW5hbCBzdHJlYW1cbiAqIEBwYXJhbSB7YW55fSBoaWdobGlnaHRlZCAtIHN0cmVhbSBvZiB0aGUgaGlnaGxpZ2h0ZWQgc291cmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgb3JpZ2luYWwgc291cmNlIGl0c2VsZlxuICovXG5mdW5jdGlvbiBtZXJnZVN0cmVhbXMob3JpZ2luYWwsIGhpZ2hsaWdodGVkLCB2YWx1ZSkge1xuICBsZXQgcHJvY2Vzc2VkID0gMDtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBjb25zdCBub2RlU3RhY2sgPSBbXTtcblxuICBmdW5jdGlvbiBzZWxlY3RTdHJlYW0oKSB7XG4gICAgaWYgKCFvcmlnaW5hbC5sZW5ndGggfHwgIWhpZ2hsaWdodGVkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsLmxlbmd0aCA/IG9yaWdpbmFsIDogaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbFswXS5vZmZzZXQgIT09IGhpZ2hsaWdodGVkWzBdLm9mZnNldCkge1xuICAgICAgcmV0dXJuIChvcmlnaW5hbFswXS5vZmZzZXQgPCBoaWdobGlnaHRlZFswXS5vZmZzZXQpID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICAvKlxuICAgIFRvIGF2b2lkIHN0YXJ0aW5nIHRoZSBzdHJlYW0ganVzdCBiZWZvcmUgaXQgc2hvdWxkIHN0b3AgdGhlIG9yZGVyIGlzXG4gICAgZW5zdXJlZCB0aGF0IG9yaWdpbmFsIGFsd2F5cyBzdGFydHMgZmlyc3QgYW5kIGNsb3NlcyBsYXN0OlxuXG4gICAgaWYgKGV2ZW50MSA9PSAnc3RhcnQnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgIGlmIChldmVudDEgPT0gJ3N0YXJ0JyAmJiBldmVudDIgPT0gJ3N0b3AnKVxuICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkO1xuICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RhcnQnKVxuICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgIGlmIChldmVudDEgPT0gJ3N0b3AnICYmIGV2ZW50MiA9PSAnc3RvcCcpXG4gICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQ7XG5cbiAgICAuLi4gd2hpY2ggaXMgY29sbGFwc2VkIHRvOlxuICAgICovXG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkWzBdLmV2ZW50ID09PSAnc3RhcnQnID8gb3JpZ2luYWwgOiBoaWdobGlnaHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIG9wZW4obm9kZSkge1xuICAgIC8qKiBAcGFyYW0ge0F0dHJ9IGF0dHIgKi9cbiAgICBmdW5jdGlvbiBhdHRyaWJ1dGVTdHJpbmcoYXR0cikge1xuICAgICAgcmV0dXJuICcgJyArIGF0dHIubm9kZU5hbWUgKyAnPVwiJyArIGVzY2FwZUhUTUwoYXR0ci52YWx1ZSkgKyAnXCInO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmVzdWx0ICs9ICc8JyArIHRhZyhub2RlKSArIFtdLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcywgYXR0cmlidXRlU3RyaW5nKS5qb2luKCcnKSArICc+JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGNsb3NlKG5vZGUpIHtcbiAgICByZXN1bHQgKz0gJzwvJyArIHRhZyhub2RlKSArICc+JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyKGV2ZW50KSB7XG4gICAgKGV2ZW50LmV2ZW50ID09PSAnc3RhcnQnID8gb3BlbiA6IGNsb3NlKShldmVudC5ub2RlKTtcbiAgfVxuXG4gIHdoaWxlIChvcmlnaW5hbC5sZW5ndGggfHwgaGlnaGxpZ2h0ZWQubGVuZ3RoKSB7XG4gICAgbGV0IHN0cmVhbSA9IHNlbGVjdFN0cmVhbSgpO1xuICAgIHJlc3VsdCArPSBlc2NhcGVIVE1MKHZhbHVlLnN1YnN0cmluZyhwcm9jZXNzZWQsIHN0cmVhbVswXS5vZmZzZXQpKTtcbiAgICBwcm9jZXNzZWQgPSBzdHJlYW1bMF0ub2Zmc2V0O1xuICAgIGlmIChzdHJlYW0gPT09IG9yaWdpbmFsKSB7XG4gICAgICAvKlxuICAgICAgT24gYW55IG9wZW5pbmcgb3IgY2xvc2luZyB0YWcgb2YgdGhlIG9yaWdpbmFsIG1hcmt1cCB3ZSBmaXJzdCBjbG9zZVxuICAgICAgdGhlIGVudGlyZSBoaWdobGlnaHRlZCBub2RlIHN0YWNrLCB0aGVuIHJlbmRlciB0aGUgb3JpZ2luYWwgdGFnIGFsb25nXG4gICAgICB3aXRoIGFsbCB0aGUgZm9sbG93aW5nIG9yaWdpbmFsIHRhZ3MgYXQgdGhlIHNhbWUgb2Zmc2V0IGFuZCB0aGVuXG4gICAgICByZW9wZW4gYWxsIHRoZSB0YWdzIG9uIHRoZSBoaWdobGlnaHRlZCBzdGFjay5cbiAgICAgICovXG4gICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2goY2xvc2UpO1xuICAgICAgZG8ge1xuICAgICAgICByZW5kZXIoc3RyZWFtLnNwbGljZSgwLCAxKVswXSk7XG4gICAgICAgIHN0cmVhbSA9IHNlbGVjdFN0cmVhbSgpO1xuICAgICAgfSB3aGlsZSAoc3RyZWFtID09PSBvcmlnaW5hbCAmJiBzdHJlYW0ubGVuZ3RoICYmIHN0cmVhbVswXS5vZmZzZXQgPT09IHByb2Nlc3NlZCk7XG4gICAgICBub2RlU3RhY2sucmV2ZXJzZSgpLmZvckVhY2gob3Blbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdHJlYW1bMF0uZXZlbnQgPT09ICdzdGFydCcpIHtcbiAgICAgICAgbm9kZVN0YWNrLnB1c2goc3RyZWFtWzBdLm5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmVuZGVyKHN0cmVhbS5zcGxpY2UoMCwgMSlbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSFRNTCh2YWx1ZS5zdWJzdHIocHJvY2Vzc2VkKSk7XG59XG5cbi8qXG5cbkZvciB0aGUgcmVhc29uaW5nIGJlaGluZCB0aGlzIHBsZWFzZSBzZWU6XG5odHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yODgwI2lzc3VlY29tbWVudC03NDcyNzU0MTlcblxuKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5jb25zdCBlcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge2FueX0gYXJnc1xuICovXG5jb25zdCB3YXJuID0gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5sb2coYFdBUk46ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGRlcHJlY2F0ZWQgPSAodmVyc2lvbiwgbWVzc2FnZSkgPT4ge1xuICBjb25zb2xlLmxvZyhgRGVwcmVjYXRlZCBhcyBvZiAke3ZlcnNpb259LiAke21lc3NhZ2V9YCk7XG59O1xuXG4vKlxuU3ludGF4IGhpZ2hsaWdodGluZyB3aXRoIGxhbmd1YWdlIGF1dG9kZXRlY3Rpb24uXG5odHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiovXG5cbmNvbnN0IGVzY2FwZSQxID0gZXNjYXBlSFRNTDtcbmNvbnN0IGluaGVyaXQkMSA9IGluaGVyaXQ7XG5jb25zdCBOT19NQVRDSCA9IFN5bWJvbChcIm5vbWF0Y2hcIik7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGhsanMgLSBvYmplY3QgdGhhdCBpcyBleHRlbmRlZCAobGVnYWN5KVxuICogQHJldHVybnMge0hMSlNBcGl9XG4gKi9cbmNvbnN0IEhMSlMgPSBmdW5jdGlvbihobGpzKSB7XG4gIC8vIEdsb2JhbCBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCB3aXRoaW4gdGhlIGhpZ2hsaWdodC5qcyBsaWJyYXJ5LlxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIExhbmd1YWdlPn0gKi9cbiAgY29uc3QgbGFuZ3VhZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICBjb25zdCBhbGlhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLyoqIEB0eXBlIHtITEpTUGx1Z2luW119ICovXG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcblxuICAvLyBzYWZlL3Byb2R1Y3Rpb24gbW9kZSAtIHN3YWxsb3dzIG1vcmUgZXJyb3JzLCB0cmllcyB0byBrZWVwIHJ1bm5pbmdcbiAgLy8gZXZlbiBpZiBhIHNpbmdsZSBzeW50YXggb3IgcGFyc2UgaGl0cyBhIGZhdGFsIGVycm9yXG4gIGxldCBTQUZFX01PREUgPSB0cnVlO1xuICBjb25zdCBmaXhNYXJrdXBSZSA9IC8oXig8W14+XSs+fFxcdHwpK3xcXG4pL2dtO1xuICBjb25zdCBMQU5HVUFHRV9OT1RfRk9VTkQgPSBcIkNvdWxkIG5vdCBmaW5kIHRoZSBsYW5ndWFnZSAne30nLCBkaWQgeW91IGZvcmdldCB0byBsb2FkL2luY2x1ZGUgYSBsYW5ndWFnZSBtb2R1bGU/XCI7XG4gIC8qKiBAdHlwZSB7TGFuZ3VhZ2V9ICovXG4gIGNvbnN0IFBMQUlOVEVYVF9MQU5HVUFHRSA9IHsgZGlzYWJsZUF1dG9kZXRlY3Q6IHRydWUsIG5hbWU6ICdQbGFpbiB0ZXh0JywgY29udGFpbnM6IFtdIH07XG5cbiAgLy8gR2xvYmFsIG9wdGlvbnMgdXNlZCB3aGVuIHdpdGhpbiBleHRlcm5hbCBBUElzLiBUaGlzIGlzIG1vZGlmaWVkIHdoZW5cbiAgLy8gY2FsbGluZyB0aGUgYGhsanMuY29uZmlndXJlYCBmdW5jdGlvbi5cbiAgLyoqIEB0eXBlIEhMSlNPcHRpb25zICovXG4gIGxldCBvcHRpb25zID0ge1xuICAgIG5vSGlnaGxpZ2h0UmU6IC9eKG5vLT9oaWdobGlnaHQpJC9pLFxuICAgIGxhbmd1YWdlRGV0ZWN0UmU6IC9cXGJsYW5nKD86dWFnZSk/LShbXFx3LV0rKVxcYi9pLFxuICAgIGNsYXNzUHJlZml4OiAnaGxqcy0nLFxuICAgIHRhYlJlcGxhY2U6IG51bGwsXG4gICAgdXNlQlI6IGZhbHNlLFxuICAgIGxhbmd1YWdlczogbnVsbCxcbiAgICAvLyBiZXRhIGNvbmZpZ3VyYXRpb24gb3B0aW9ucywgc3ViamVjdCB0byBjaGFuZ2UsIHdlbGNvbWUgdG8gZGlzY3Vzc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzEwODZcbiAgICBfX2VtaXR0ZXI6IFRva2VuVHJlZUVtaXR0ZXJcbiAgfTtcblxuICAvKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG4gIC8qKlxuICAgKiBUZXN0cyBhIGxhbmd1YWdlIG5hbWUgdG8gc2VlIGlmIGhpZ2hsaWdodGluZyBzaG91bGQgYmUgc2tpcHBlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2VOYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubm9IaWdobGlnaHRSZS50ZXN0KGxhbmd1YWdlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBibG9jayAtIHRoZSBIVE1MIGVsZW1lbnQgdG8gZGV0ZXJtaW5lIGxhbmd1YWdlIGZvclxuICAgKi9cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIGxldCBjbGFzc2VzID0gYmxvY2suY2xhc3NOYW1lICsgJyAnO1xuXG4gICAgY2xhc3NlcyArPSBibG9jay5wYXJlbnROb2RlID8gYmxvY2sucGFyZW50Tm9kZS5jbGFzc05hbWUgOiAnJztcblxuICAgIC8vIGxhbmd1YWdlLSogdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5vbi1wcmVmaXhlZCBjbGFzcyBuYW1lcy5cbiAgICBjb25zdCBtYXRjaCA9IG9wdGlvbnMubGFuZ3VhZ2VEZXRlY3RSZS5leGVjKGNsYXNzZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShtYXRjaFsxXSk7XG4gICAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICAgIHdhcm4oTEFOR1VBR0VfTk9UX0ZPVU5ELnJlcGxhY2UoXCJ7fVwiLCBtYXRjaFsxXSkpO1xuICAgICAgICB3YXJuKFwiRmFsbGluZyBiYWNrIHRvIG5vLWhpZ2hsaWdodCBtb2RlIGZvciB0aGlzIGJsb2NrLlwiLCBibG9jayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFuZ3VhZ2UgPyBtYXRjaFsxXSA6ICduby1oaWdobGlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZpbmQoKF9jbGFzcykgPT4gc2hvdWxkTm90SGlnaGxpZ2h0KF9jbGFzcykgfHwgZ2V0TGFuZ3VhZ2UoX2NsYXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBoaWdobGlnaHRpbmcgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWUgLSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBoaWdobGlnaHRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqXG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IFJlc3VsdCAtIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGFuZ3VhZ2UgLSB0aGUgbGFuZ3VhZ2UgbmFtZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVsZXZhbmNlIC0gdGhlIHJlbGV2YW5jZSBzY29yZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWUgLSB0aGUgaGlnaGxpZ2h0ZWQgSFRNTCBjb2RlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIC0gdGhlIG9yaWdpbmFsIHJhdyBjb2RlXG4gICAqIEBwcm9wZXJ0eSB7Q29tcGlsZWRNb2RlfSB0b3AgLSB0b3Agb2YgdGhlIGN1cnJlbnQgbW9kZSBzdGFja1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlsbGVnYWwgLSBpbmRpY2F0ZXMgd2hldGhlciBhbnkgaWxsZWdhbCBtYXRjaGVzIHdlcmUgZm91bmRcbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0KGxhbmd1YWdlTmFtZSwgY29kZSwgaWdub3JlSWxsZWdhbHMsIGNvbnRpbnVhdGlvbikge1xuICAgIC8qKiBAdHlwZSB7QmVmb3JlSGlnaGxpZ2h0Q29udGV4dH0gKi9cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29kZSxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWVcbiAgICB9O1xuICAgIC8vIHRoZSBwbHVnaW4gY2FuIGNoYW5nZSB0aGUgZGVzaXJlZCBsYW5ndWFnZSBvciB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZFxuICAgIC8vIGp1c3QgYmUgY2hhbmdpbmcgdGhlIG9iamVjdCBpdCB3YXMgcGFzc2VkXG4gICAgZmlyZShcImJlZm9yZTpoaWdobGlnaHRcIiwgY29udGV4dCk7XG5cbiAgICAvLyBhIGJlZm9yZSBwbHVnaW4gY2FuIHVzdXJwIHRoZSByZXN1bHQgY29tcGxldGVseSBieSBwcm92aWRpbmcgaXQncyBvd25cbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRvbid0IGV2ZW4gbmVlZCB0byBjYWxsIGhpZ2hsaWdodFxuICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQucmVzdWx0ID9cbiAgICAgIGNvbnRleHQucmVzdWx0IDpcbiAgICAgIF9oaWdobGlnaHQoY29udGV4dC5sYW5ndWFnZSwgY29udGV4dC5jb2RlLCBpZ25vcmVJbGxlZ2FscywgY29udGludWF0aW9uKTtcblxuICAgIHJlc3VsdC5jb2RlID0gY29udGV4dC5jb2RlO1xuICAgIC8vIHRoZSBwbHVnaW4gY2FuIGNoYW5nZSBhbnl0aGluZyBpbiByZXN1bHQgdG8gc3VpdGUgaXRcbiAgICBmaXJlKFwiYWZ0ZXI6aGlnaGxpZ2h0XCIsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIHByaXZhdGUgaGlnaGxpZ2h0IHRoYXQncyB1c2VkIGludGVybmFsbHkgYW5kIGRvZXMgbm90IGZpcmUgY2FsbGJhY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWUgLSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBoaWdobGlnaHRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSB0aGUgY29kZSB0byBoaWdobGlnaHRcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IFtjb250aW51YXRpb25dIC0gY3VycmVudCBjb250aW51YXRpb24gbW9kZSwgaWYgYW55XG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IC0gcmVzdWx0IG9mIHRoZSBoaWdobGlnaHQgb3BlcmF0aW9uXG4gICovXG4gIGZ1bmN0aW9uIF9oaWdobGlnaHQobGFuZ3VhZ2VOYW1lLCBjb2RlLCBpZ25vcmVJbGxlZ2FscywgY29udGludWF0aW9uKSB7XG4gICAgY29uc3QgY29kZVRvSGlnaGxpZ2h0ID0gY29kZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBrZXl3b3JkIGRhdGEgaWYgYSBtYXRjaCBpcyBhIGtleXdvcmRcbiAgICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZSAtIGN1cnJlbnQgbW9kZVxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2ggLSByZWdleHAgbWF0Y2ggZGF0YVxuICAgICAqIEByZXR1cm5zIHtLZXl3b3JkRGF0YSB8IGZhbHNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXdvcmREYXRhKG1vZGUsIG1hdGNoKSB7XG4gICAgICBjb25zdCBtYXRjaFRleHQgPSBsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSA6IG1hdGNoWzBdO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2RlLmtleXdvcmRzLCBtYXRjaFRleHQpICYmIG1vZGUua2V5d29yZHNbbWF0Y2hUZXh0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzS2V5d29yZHMoKSB7XG4gICAgICBpZiAoIXRvcC5rZXl3b3Jkcykge1xuICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICB0b3Aua2V5d29yZFBhdHRlcm5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgbGV0IG1hdGNoID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUuZXhlYyhtb2RlQnVmZmVyKTtcbiAgICAgIGxldCBidWYgPSBcIlwiO1xuXG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgYnVmICs9IG1vZGVCdWZmZXIuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0ga2V5d29yZERhdGEodG9wLCBtYXRjaCk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgY29uc3QgW2tpbmQsIGtleXdvcmRSZWxldmFuY2VdID0gZGF0YTtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQoYnVmKTtcbiAgICAgICAgICBidWYgPSBcIlwiO1xuXG4gICAgICAgICAgcmVsZXZhbmNlICs9IGtleXdvcmRSZWxldmFuY2U7XG4gICAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW2tpbmRdIHx8IGtpbmQ7XG4gICAgICAgICAgZW1pdHRlci5hZGRLZXl3b3JkKG1hdGNoWzBdLCBjc3NDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmICs9IG1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmxhc3RJbmRleDtcbiAgICAgICAgbWF0Y2ggPSB0b3Aua2V5d29yZFBhdHRlcm5SZS5leGVjKG1vZGVCdWZmZXIpO1xuICAgICAgfVxuICAgICAgYnVmICs9IG1vZGVCdWZmZXIuc3Vic3RyKGxhc3RJbmRleCk7XG4gICAgICBlbWl0dGVyLmFkZFRleHQoYnVmKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU3ViTGFuZ3VhZ2UoKSB7XG4gICAgICBpZiAobW9kZUJ1ZmZlciA9PT0gXCJcIikgcmV0dXJuO1xuICAgICAgLyoqIEB0eXBlIEhpZ2hsaWdodFJlc3VsdCAqL1xuICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9wLnN1Ykxhbmd1YWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWxhbmd1YWdlc1t0b3Auc3ViTGFuZ3VhZ2VdKSB7XG4gICAgICAgICAgZW1pdHRlci5hZGRUZXh0KG1vZGVCdWZmZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBfaGlnaGxpZ2h0KHRvcC5zdWJMYW5ndWFnZSwgbW9kZUJ1ZmZlciwgdHJ1ZSwgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdKTtcbiAgICAgICAgY29udGludWF0aW9uc1t0b3Auc3ViTGFuZ3VhZ2VdID0gLyoqIEB0eXBlIHtDb21waWxlZE1vZGV9ICovIChyZXN1bHQudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLmFkZFN1Ymxhbmd1YWdlKHJlc3VsdC5lbWl0dGVyLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICBpZiAodG9wLnN1Ykxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc1N1Ykxhbmd1YWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzS2V5d29yZHMoKTtcbiAgICAgIH1cbiAgICAgIG1vZGVCdWZmZXIgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vZGV9IG1vZGUgLSBuZXcgbW9kZSB0byBzdGFydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0TmV3TW9kZShtb2RlKSB7XG4gICAgICBpZiAobW9kZS5jbGFzc05hbWUpIHtcbiAgICAgICAgZW1pdHRlci5vcGVuTm9kZShsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW21vZGUuY2xhc3NOYW1lXSB8fCBtb2RlLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHsgcGFyZW50OiB7IHZhbHVlOiB0b3AgfSB9KTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfSBtb2RlIC0gdGhlIG1vZGUgdG8gcG90ZW50aWFsbHkgZW5kXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBsYXRlc3QgbWF0Y2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hQbHVzUmVtYWluZGVyIC0gbWF0Y2ggcGx1cyByZW1haW5kZXIgb2YgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCB2b2lkfSAtIHRoZSBuZXh0IG1vZGUsIG9yIGlmIHZvaWQgY29udGludWUgb24gaW4gY3VycmVudCBtb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gc3RhcnRzV2l0aChtb2RlLmVuZFJlLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZiAobW9kZVtcIm9uOmVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobW9kZSk7XG4gICAgICAgICAgbW9kZVtcIm9uOmVuZFwiXShtYXRjaCwgcmVzcCk7XG4gICAgICAgICAgaWYgKHJlc3AuaWdub3JlKSBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIHdoaWxlIChtb2RlLmVuZHNQYXJlbnQgJiYgbW9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIG1vZGUgPSBtb2RlLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV2ZW4gaWYgb246ZW5kIGZpcmVzIGFuIGBpZ25vcmVgIGl0J3Mgc3RpbGwgcG9zc2libGVcbiAgICAgIC8vIHRoYXQgd2UgbWlnaHQgdHJpZ2dlciB0aGUgZW5kIG5vZGUgYmVjYXVzZSBvZiBhIHBhcmVudCBtb2RlXG4gICAgICBpZiAobW9kZS5lbmRzV2l0aFBhcmVudCkge1xuICAgICAgICByZXR1cm4gZW5kT2ZNb2RlKG1vZGUucGFyZW50LCBtYXRjaCwgbWF0Y2hQbHVzUmVtYWluZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbWF0Y2hpbmcgYnV0IHRoZW4gaWdub3JpbmcgYSBzZXF1ZW5jZSBvZiB0ZXh0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV4ZW1lIC0gc3RyaW5nIGNvbnRhaW5pbmcgZnVsbCBtYXRjaCB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9JZ25vcmUobGV4ZW1lKSB7XG4gICAgICBpZiAodG9wLm1hdGNoZXIucmVnZXhJbmRleCA9PT0gMCkge1xuICAgICAgICAvLyBubyBtb3JlIHJlZ2V4cyB0byBwb3RlbnRpYWxseSBtYXRjaCBoZXJlLCBzbyB3ZSBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCBvbmVcbiAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWVbMF07XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBtb3ZlIHRoZSBjdXJzb3IsIHdlIHN0aWxsIGhhdmUgYWRkaXRpb25hbCByZWdleGVzIHRvIHRyeSBhbmRcbiAgICAgICAgLy8gbWF0Y2ggYXQgdGhpcyB2ZXJ5IHNwb3RcbiAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG5ldyBwb3RlbnRpYWwgbW9kZSBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG93IGZhciB0byBhZHZhbmNlIHRoZSBwYXJzZSBjdXJzb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0JlZ2luTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IG1hdGNoLnJ1bGU7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobmV3TW9kZSk7XG4gICAgICAvLyBmaXJzdCBpbnRlcm5hbCBiZWZvcmUgY2FsbGJhY2tzLCB0aGVuIHRoZSBwdWJsaWMgb25lc1xuICAgICAgY29uc3QgYmVmb3JlQ2FsbGJhY2tzID0gW25ld01vZGUuX19iZWZvcmVCZWdpbiwgbmV3TW9kZVtcIm9uOmJlZ2luXCJdXTtcbiAgICAgIGZvciAoY29uc3QgY2Igb2YgYmVmb3JlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghY2IpIGNvbnRpbnVlO1xuICAgICAgICBjYihtYXRjaCwgcmVzcCk7XG4gICAgICAgIGlmIChyZXNwLmlnbm9yZSkgcmV0dXJuIGRvSWdub3JlKGxleGVtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdNb2RlICYmIG5ld01vZGUuZW5kU2FtZUFzQmVnaW4pIHtcbiAgICAgICAgbmV3TW9kZS5lbmRSZSA9IGVzY2FwZShsZXhlbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3TW9kZS5za2lwKSB7XG4gICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5ld01vZGUuZXhjbHVkZUJlZ2luKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBpZiAoIW5ld01vZGUucmV0dXJuQmVnaW4gJiYgIW5ld01vZGUuZXhjbHVkZUJlZ2luKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhcnROZXdNb2RlKG5ld01vZGUpO1xuICAgICAgLy8gaWYgKG1vZGVbXCJhZnRlcjpiZWdpblwiXSkge1xuICAgICAgLy8gICBsZXQgcmVzcCA9IG5ldyBSZXNwb25zZShtb2RlKTtcbiAgICAgIC8vICAgbW9kZVtcImFmdGVyOmJlZ2luXCJdKG1hdGNoLCByZXNwKTtcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBuZXdNb2RlLnJldHVybkJlZ2luID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBwb3RlbnRpYWwgZW5kIG9mIG1vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2ggLSB0aGUgY3VycmVudCBtYXRjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvRW5kTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbWF0Y2hQbHVzUmVtYWluZGVyID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cihtYXRjaC5pbmRleCk7XG5cbiAgICAgIGNvbnN0IGVuZE1vZGUgPSBlbmRPZk1vZGUodG9wLCBtYXRjaCwgbWF0Y2hQbHVzUmVtYWluZGVyKTtcbiAgICAgIGlmICghZW5kTW9kZSkgeyByZXR1cm4gTk9fTUFUQ0g7IH1cblxuICAgICAgY29uc3Qgb3JpZ2luID0gdG9wO1xuICAgICAgaWYgKG9yaWdpbi5za2lwKSB7XG4gICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEob3JpZ2luLnJldHVybkVuZCB8fCBvcmlnaW4uZXhjbHVkZUVuZCkpIHtcbiAgICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGlmIChvcmlnaW4uZXhjbHVkZUVuZCkge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHRvcC5jbGFzc05hbWUpIHtcbiAgICAgICAgICBlbWl0dGVyLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wLnNraXAgJiYgIXRvcC5zdWJMYW5ndWFnZSkge1xuICAgICAgICAgIHJlbGV2YW5jZSArPSB0b3AucmVsZXZhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICB9IHdoaWxlICh0b3AgIT09IGVuZE1vZGUucGFyZW50KTtcbiAgICAgIGlmIChlbmRNb2RlLnN0YXJ0cykge1xuICAgICAgICBpZiAoZW5kTW9kZS5lbmRTYW1lQXNCZWdpbikge1xuICAgICAgICAgIGVuZE1vZGUuc3RhcnRzLmVuZFJlID0gZW5kTW9kZS5lbmRSZTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydE5ld01vZGUoZW5kTW9kZS5zdGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbi5yZXR1cm5FbmQgPyAwIDogbGV4ZW1lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQ29udGludWF0aW9ucygpIHtcbiAgICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0b3A7IGN1cnJlbnQgIT09IGxhbmd1YWdlOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgbGlzdC51bnNoaWZ0KGN1cnJlbnQuY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4gZW1pdHRlci5vcGVuTm9kZShpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHt7dHlwZT86IE1hdGNoVHlwZSwgaW5kZXg/OiBudW1iZXIsIHJ1bGU/OiBNb2RlfX19ICovXG4gICAgbGV0IGxhc3RNYXRjaCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIFByb2Nlc3MgYW4gaW5kaXZpZHVhbCBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRCZWZvcmVNYXRjaCAtIHRleHQgcHJlY2VlZGluZyB0aGUgbWF0Y2ggKHNpbmNlIHRoZSBsYXN0IG1hdGNoKVxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRNYXRjaH0gW21hdGNoXSAtIHRoZSBtYXRjaCBpdHNlbGZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGV4ZW1lKHRleHRCZWZvcmVNYXRjaCwgbWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoICYmIG1hdGNoWzBdO1xuXG4gICAgICAvLyBhZGQgbm9uLW1hdGNoZWQgdGV4dCB0byB0aGUgY3VycmVudCBtb2RlIGJ1ZmZlclxuICAgICAgbW9kZUJ1ZmZlciArPSB0ZXh0QmVmb3JlTWF0Y2g7XG5cbiAgICAgIGlmIChsZXhlbWUgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSd2ZSBmb3VuZCBhIDAgd2lkdGggbWF0Y2ggYW5kIHdlJ3JlIHN0dWNrLCBzbyB3ZSBuZWVkIHRvIGFkdmFuY2VcbiAgICAgIC8vIHRoaXMgaGFwcGVucyB3aGVuIHdlIGhhdmUgYmFkbHkgYmVoYXZlZCBydWxlcyB0aGF0IGhhdmUgb3B0aW9uYWwgbWF0Y2hlcnMgdG8gdGhlIGRlZ3JlZSB0aGF0XG4gICAgICAvLyBzb21ldGltZXMgdGhleSBjYW4gZW5kIHVwIG1hdGNoaW5nIG5vdGhpbmcgYXQgYWxsXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzIxNDBcbiAgICAgIGlmIChsYXN0TWF0Y2gudHlwZSA9PT0gXCJiZWdpblwiICYmIG1hdGNoLnR5cGUgPT09IFwiZW5kXCIgJiYgbGFzdE1hdGNoLmluZGV4ID09PSBtYXRjaC5pbmRleCAmJiBsZXhlbWUgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gc3BpdCB0aGUgXCJza2lwcGVkXCIgY2hhcmFjdGVyIHRoYXQgb3VyIHJlZ2V4IGNob2tlZCBvbiBiYWNrIGludG8gdGhlIG91dHB1dCBzZXF1ZW5jZVxuICAgICAgICBtb2RlQnVmZmVyICs9IGNvZGVUb0hpZ2hsaWdodC5zbGljZShtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyAxKTtcbiAgICAgICAgaWYgKCFTQUZFX01PREUpIHtcbiAgICAgICAgICAvKiogQHR5cGUge0Fubm90YXRlZEVycm9yfSAqL1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignMCB3aWR0aCBtYXRjaCByZWdleCcpO1xuICAgICAgICAgIGVyci5sYW5ndWFnZU5hbWUgPSBsYW5ndWFnZU5hbWU7XG4gICAgICAgICAgZXJyLmJhZFJ1bGUgPSBsYXN0TWF0Y2gucnVsZTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBsYXN0TWF0Y2ggPSBtYXRjaDtcblxuICAgICAgaWYgKG1hdGNoLnR5cGUgPT09IFwiYmVnaW5cIikge1xuICAgICAgICByZXR1cm4gZG9CZWdpbk1hdGNoKG1hdGNoKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSA9PT0gXCJpbGxlZ2FsXCIgJiYgIWlnbm9yZUlsbGVnYWxzKSB7XG4gICAgICAgIC8vIGlsbGVnYWwgbWF0Y2gsIHdlIGRvIG5vdCBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgIC8qKiBAdHlwZSB7QW5ub3RhdGVkRXJyb3J9ICovXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSWxsZWdhbCBsZXhlbWUgXCInICsgbGV4ZW1lICsgJ1wiIGZvciBtb2RlIFwiJyArICh0b3AuY2xhc3NOYW1lIHx8ICc8dW5uYW1lZD4nKSArICdcIicpO1xuICAgICAgICBlcnIubW9kZSA9IHRvcDtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC50eXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGRvRW5kTWF0Y2gobWF0Y2gpO1xuICAgICAgICBpZiAocHJvY2Vzc2VkICE9PSBOT19NQVRDSCkge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZWRnZSBjYXNlIGZvciB3aGVuIGlsbGVnYWwgbWF0Y2hlcyAkIChlbmQgb2YgbGluZSkgd2hpY2ggaXMgdGVjaG5pY2FsbHlcbiAgICAgIC8vIGEgMCB3aWR0aCBtYXRjaCBidXQgbm90IGEgYmVnaW4vZW5kIG1hdGNoIHNvIGl0J3Mgbm90IGNhdWdodCBieSB0aGVcbiAgICAgIC8vIGZpcnN0IGhhbmRsZXIgKHdoZW4gaWdub3JlSWxsZWdhbHMgaXMgdHJ1ZSlcbiAgICAgIGlmIChtYXRjaC50eXBlID09PSBcImlsbGVnYWxcIiAmJiBsZXhlbWUgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gYWR2YW5jZSBzbyB3ZSBhcmVuJ3Qgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5maW5pdGUgbG9vcHMgYXJlIEJBRCwgdGhpcyBpcyBhIGxhc3QgZGl0Y2ggY2F0Y2ggYWxsLiBpZiB3ZSBoYXZlIGFcbiAgICAgIC8vIGRlY2VudCBudW1iZXIgb2YgaXRlcmF0aW9ucyB5ZXQgb3VyIGluZGV4IChjdXJzb3IgcG9zaXRpb24gaW4gb3VyXG4gICAgICAvLyBwYXJzaW5nKSBzdGlsbCAzeCBiZWhpbmQgb3VyIGluZGV4IHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmdcbiAgICAgIC8vIHNvIHdlIGJhaWxcbiAgICAgIGlmIChpdGVyYXRpb25zID4gMTAwMDAwICYmIGl0ZXJhdGlvbnMgPiBtYXRjaC5pbmRleCAqIDMpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdwb3RlbnRpYWwgaW5maW5pdGUgbG9vcCwgd2F5IG1vcmUgaXRlcmF0aW9ucyB0aGFuIG1hdGNoZXMnKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgV2h5IG1pZ2h0IGJlIGZpbmQgb3Vyc2VsdmVzIGhlcmU/ICBPbmx5IG9uZSBvY2Nhc2lvbiBub3cuICBBbiBlbmQgbWF0Y2ggdGhhdCB3YXNcbiAgICAgIHRyaWdnZXJlZCBidXQgY291bGQgbm90IGJlIGNvbXBsZXRlZC4gIFdoZW4gbWlnaHQgdGhpcyBoYXBwZW4/ICBXaGVuIGFuIGBlbmRTYW1lYXNCZWdpbmBcbiAgICAgIHJ1bGUgc2V0cyB0aGUgZW5kIHJ1bGUgdG8gYSBzcGVjaWZpYyBtYXRjaC4gIFNpbmNlIHRoZSBvdmVyYWxsIG1vZGUgdGVybWluYXRpb24gcnVsZSB0aGF0J3NcbiAgICAgIGJlaW5nIHVzZWQgdG8gc2NhbiB0aGUgdGV4dCBpc24ndCByZWNvbXBpbGVkIHRoYXQgbWVhbnMgdGhhdCBhbnkgbWF0Y2ggdGhhdCBMT09LUyBsaWtlXG4gICAgICB0aGUgZW5kIChidXQgaXMgbm90LCBiZWNhdXNlIGl0IGlzIG5vdCBhbiBleGFjdCBtYXRjaCB0byB0aGUgYmVnaW5uaW5nKSB3aWxsXG4gICAgICBlbmQgdXAgaGVyZS4gIEEgZGVmaW5pdGUgZW5kIG1hdGNoLCBidXQgd2hlbiBgZG9FbmRNYXRjaGAgdHJpZXMgdG8gXCJyZWFwcGx5XCJcbiAgICAgIHRoZSBlbmQgcnVsZSBhbmQgZmFpbHMgdG8gbWF0Y2gsIHdlIHdpbmQgdXAgaGVyZSwgYW5kIGp1c3Qgc2lsZW50bHkgaWdub3JlIHRoZSBlbmQuXG5cbiAgICAgIFRoaXMgY2F1c2VzIG5vIHJlYWwgaGFybSBvdGhlciB0aGFuIHN0b3BwaW5nIGEgZmV3IHRpbWVzIHRvbyBtYW55LlxuICAgICAgKi9cblxuICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICByZXR1cm4gbGV4ZW1lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKGxhbmd1YWdlTmFtZSk7XG4gICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgZXJyb3IoTEFOR1VBR0VfTk9UX0ZPVU5ELnJlcGxhY2UoXCJ7fVwiLCBsYW5ndWFnZU5hbWUpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZTogXCInICsgbGFuZ3VhZ2VOYW1lICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWQgPSBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UsIHsgcGx1Z2lucyB9KTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgLyoqIEB0eXBlIHtDb21waWxlZE1vZGV9ICovXG4gICAgbGV0IHRvcCA9IGNvbnRpbnVhdGlvbiB8fCBtZDtcbiAgICAvKiogQHR5cGUgUmVjb3JkPHN0cmluZyxDb21waWxlZE1vZGU+ICovXG4gICAgY29uc3QgY29udGludWF0aW9ucyA9IHt9OyAvLyBrZWVwIGNvbnRpbnVhdGlvbnMgZm9yIHN1Yi1sYW5ndWFnZXNcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IG9wdGlvbnMuX19lbWl0dGVyKG9wdGlvbnMpO1xuICAgIHByb2Nlc3NDb250aW51YXRpb25zKCk7XG4gICAgbGV0IG1vZGVCdWZmZXIgPSAnJztcbiAgICBsZXQgcmVsZXZhbmNlID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBsZXQgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChyZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAvLyBvbmx5IHJlZ2V4ZXMgbm90IG1hdGNoZWQgcHJldmlvdXNseSB3aWxsIG5vdyBiZVxuICAgICAgICAgIC8vIGNvbnNpZGVyZWQgZm9yIGEgcG90ZW50aWFsIG1hdGNoXG4gICAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AubWF0Y2hlci5sYXN0SW5kZXggPSBpbmRleDtcblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRvcC5tYXRjaGVyLmV4ZWMoY29kZVRvSGlnaGxpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaFwiLCBtYXRjaFswXSwgbWF0Y2gucnVsZSAmJiBtYXRjaC5ydWxlLmJlZ2luKVxuXG4gICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb3VudCA9IHByb2Nlc3NMZXhlbWUoYmVmb3JlTWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleCArIHByb2Nlc3NlZENvdW50O1xuICAgICAgfVxuICAgICAgcHJvY2Vzc0xleGVtZShjb2RlVG9IaWdobGlnaHQuc3Vic3RyKGluZGV4KSk7XG4gICAgICBlbWl0dGVyLmNsb3NlQWxsTm9kZXMoKTtcbiAgICAgIGVtaXR0ZXIuZmluYWxpemUoKTtcbiAgICAgIHJlc3VsdCA9IGVtaXR0ZXIudG9IVE1MKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGV2YW5jZTogcmVsZXZhbmNlLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgICAgICBpbGxlZ2FsOiBmYWxzZSxcbiAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgdG9wOiB0b3BcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0lsbGVnYWwnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlsbGVnYWw6IHRydWUsXG4gICAgICAgICAgaWxsZWdhbEJ5OiB7XG4gICAgICAgICAgICBtc2c6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgY29udGV4dDogY29kZVRvSGlnaGxpZ2h0LnNsaWNlKGluZGV4IC0gMTAwLCBpbmRleCArIDEwMCksXG4gICAgICAgICAgICBtb2RlOiBlcnIubW9kZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc29mYXI6IHJlc3VsdCxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZSQxKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgZW1pdHRlcjogZW1pdHRlclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChTQUZFX01PREUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbGxlZ2FsOiBmYWxzZSxcbiAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZSQxKGNvZGVUb0hpZ2hsaWdodCksXG4gICAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGVycm9yUmFpc2VkOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHZhbGlkIGhpZ2hsaWdodCByZXN1bHQsIHdpdGhvdXQgYWN0dWFsbHkgZG9pbmcgYW55IGFjdHVhbCB3b3JrLFxuICAgKiBhdXRvIGhpZ2hsaWdodCBzdGFydHMgd2l0aCB0aGlzIGFuZCBpdCdzIHBvc3NpYmxlIGZvciBzbWFsbCBzbmlwcGV0cyB0aGF0XG4gICAqIGF1dG8tZGV0ZWN0aW9uIG1heSBub3QgZmluZCBhIGJldHRlciBtYXRjaFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgKiBAcmV0dXJucyB7SGlnaGxpZ2h0UmVzdWx0fVxuICAgKi9cbiAgZnVuY3Rpb24ganVzdFRleHRIaWdobGlnaHRSZXN1bHQoY29kZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIGVtaXR0ZXI6IG5ldyBvcHRpb25zLl9fZW1pdHRlcihvcHRpb25zKSxcbiAgICAgIHZhbHVlOiBlc2NhcGUkMShjb2RlKSxcbiAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgdG9wOiBQTEFJTlRFWFRfTEFOR1VBR0VcbiAgICB9O1xuICAgIHJlc3VsdC5lbWl0dGVyLmFkZFRleHQoY29kZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kX2Jlc3QgKG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBmb3Igc2Vjb25kLWJlc3QgaGV1cmlzdGljYWxseVxuICAgIGRldGVjdGVkIGxhbmd1YWdlLCBtYXkgYmUgYWJzZW50KVxuXG4gICAgQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtsYW5ndWFnZVN1YnNldF1cbiAgICBAcmV0dXJucyB7QXV0b0hpZ2hsaWdodFJlc3VsdH1cbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QXV0byhjb2RlLCBsYW5ndWFnZVN1YnNldCkge1xuICAgIGxhbmd1YWdlU3Vic2V0ID0gbGFuZ3VhZ2VTdWJzZXQgfHwgb3B0aW9ucy5sYW5ndWFnZXMgfHwgT2JqZWN0LmtleXMobGFuZ3VhZ2VzKTtcbiAgICBjb25zdCBwbGFpbnRleHQgPSBqdXN0VGV4dEhpZ2hsaWdodFJlc3VsdChjb2RlKTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBsYW5ndWFnZVN1YnNldC5maWx0ZXIoZ2V0TGFuZ3VhZ2UpLmZpbHRlcihhdXRvRGV0ZWN0aW9uKS5tYXAobmFtZSA9PlxuICAgICAgX2hpZ2hsaWdodChuYW1lLCBjb2RlLCBmYWxzZSlcbiAgICApO1xuICAgIHJlc3VsdHMudW5zaGlmdChwbGFpbnRleHQpOyAvLyBwbGFpbnRleHQgaXMgYWx3YXlzIGFuIG9wdGlvblxuXG4gICAgY29uc3Qgc29ydGVkID0gcmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAvLyBzb3J0IGJhc2Ugb24gcmVsZXZhbmNlXG4gICAgICBpZiAoYS5yZWxldmFuY2UgIT09IGIucmVsZXZhbmNlKSByZXR1cm4gYi5yZWxldmFuY2UgLSBhLnJlbGV2YW5jZTtcblxuICAgICAgLy8gYWx3YXlzIGF3YXJkIHRoZSB0aWUgdG8gdGhlIGJhc2UgbGFuZ3VhZ2VcbiAgICAgIC8vIGllIGlmIEMrKyBhbmQgQXJkdWlubyBhcmUgdGllZCwgaXQncyBtb3JlIGxpa2VseSB0byBiZSBDKytcbiAgICAgIGlmIChhLmxhbmd1YWdlICYmIGIubGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKGdldExhbmd1YWdlKGEubGFuZ3VhZ2UpLnN1cGVyc2V0T2YgPT09IGIubGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChnZXRMYW5ndWFnZShiLmxhbmd1YWdlKS5zdXBlcnNldE9mID09PSBhLmxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSBzYXkgdGhleSBhcmUgZXF1YWwsIHdoaWNoIGhhcyB0aGUgZWZmZWN0IG9mIHNvcnRpbmcgb25cbiAgICAgIC8vIHJlbGV2YW5jZSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBvcmRlcmluZyAtIHdoaWNoIGlzIGhvdyB0aWVzXG4gICAgICAvLyBoYXZlIGhpc3RvcmljYWxseSBiZWVuIHNldHRsZWQsIGllIHRoZSBsYW5ndWFnZSB0aGF0IGNvbWVzIGZpcnN0IGFsd2F5c1xuICAgICAgLy8gd2lucyBpbiB0aGUgY2FzZSBvZiBhIHRpZVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICBjb25zdCBbYmVzdCwgc2Vjb25kQmVzdF0gPSBzb3J0ZWQ7XG5cbiAgICAvKiogQHR5cGUge0F1dG9IaWdobGlnaHRSZXN1bHR9ICovXG4gICAgY29uc3QgcmVzdWx0ID0gYmVzdDtcbiAgICByZXN1bHQuc2Vjb25kX2Jlc3QgPSBzZWNvbmRCZXN0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICBQb3N0LXByb2Nlc3Npbmcgb2YgdGhlIGhpZ2hsaWdodGVkIG1hcmt1cDpcblxuICAtIHJlcGxhY2UgVEFCcyB3aXRoIHNvbWV0aGluZyBtb3JlIHVzZWZ1bFxuICAtIHJlcGxhY2UgcmVhbCBsaW5lLWJyZWFrcyB3aXRoICc8YnI+JyBmb3Igbm9uLXByZSBjb250YWluZXJzXG5cbiAgICBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIGZ1bmN0aW9uIGZpeE1hcmt1cChodG1sKSB7XG4gICAgaWYgKCEob3B0aW9ucy50YWJSZXBsYWNlIHx8IG9wdGlvbnMudXNlQlIpKSB7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGZpeE1hcmt1cFJlLCBtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2ggPT09ICdcXG4nKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnVzZUJSID8gJzxicj4nIDogbWF0Y2g7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFiUmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gbWF0Y2gucmVwbGFjZSgvXFx0L2csIG9wdGlvbnMudGFiUmVwbGFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5ldyBjbGFzcyBuYW1lIGZvciBibG9jayBnaXZlbiB0aGUgbGFuZ3VhZ2UgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3VycmVudExhbmddXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzdWx0TGFuZ11cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBjdXJyZW50TGFuZywgcmVzdWx0TGFuZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gY3VycmVudExhbmcgPyBhbGlhc2VzW2N1cnJlbnRMYW5nXSA6IHJlc3VsdExhbmc7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJobGpzXCIpO1xuICAgIGlmIChsYW5ndWFnZSkgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7SExKU1BsdWdpbn0gKi9cbiAgY29uc3QgYnJQbHVnaW4gPSB7XG4gICAgXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIjogKHsgYmxvY2sgfSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudXNlQlIpIHtcbiAgICAgICAgYmxvY2suaW5uZXJIVE1MID0gYmxvY2suaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLCAnJykucmVwbGFjZSgvPGJyWyAvXSo+L2csICdcXG4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiYWZ0ZXI6aGlnaGxpZ2h0QmxvY2tcIjogKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnVzZUJSKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJlc3VsdC52YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnI+XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBUQUJfUkVQTEFDRV9SRSA9IC9eKDxbXj5dKz58XFx0KSsvZ207XG4gIC8qKiBAdHlwZSB7SExKU1BsdWdpbn0gKi9cbiAgY29uc3QgdGFiUmVwbGFjZVBsdWdpbiA9IHtcbiAgICBcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCI6ICh7IHJlc3VsdCB9KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50YWJSZXBsYWNlKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJlc3VsdC52YWx1ZS5yZXBsYWNlKFRBQl9SRVBMQUNFX1JFLCAobSkgPT5cbiAgICAgICAgICBtLnJlcGxhY2UoL1xcdC9nLCBvcHRpb25zLnRhYlJlcGxhY2UpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGhpZ2hsaWdodGluZyB0byBhIERPTSBub2RlIGNvbnRhaW5pbmcgY29kZS4gQWNjZXB0cyBhIERPTSBub2RlIGFuZFxuICAgKiB0d28gb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgZml4TWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge0hpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IGVsZW1lbnQgLSB0aGUgSFRNTCBlbGVtZW50IHRvIGhpZ2hsaWdodFxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRCbG9jayhlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIEhUTUxFbGVtZW50ICovXG4gICAgbGV0IG5vZGUgPSBudWxsO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gYmxvY2tMYW5ndWFnZShlbGVtZW50KTtcblxuICAgIGlmIChzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2UpKSByZXR1cm47XG5cbiAgICBmaXJlKFwiYmVmb3JlOmhpZ2hsaWdodEJsb2NrXCIsXG4gICAgICB7IGJsb2NrOiBlbGVtZW50LCBsYW5ndWFnZTogbGFuZ3VhZ2UgfSk7XG5cbiAgICBub2RlID0gZWxlbWVudDtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICBjb25zdCByZXN1bHQgPSBsYW5ndWFnZSA/IGhpZ2hsaWdodChsYW5ndWFnZSwgdGV4dCwgdHJ1ZSkgOiBoaWdobGlnaHRBdXRvKHRleHQpO1xuXG4gICAgZmlyZShcImFmdGVyOmhpZ2hsaWdodEJsb2NrXCIsIHsgYmxvY2s6IGVsZW1lbnQsIHJlc3VsdCwgdGV4dCB9KTtcblxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gcmVzdWx0LnZhbHVlO1xuICAgIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBsYW5ndWFnZSwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICBlbGVtZW50LnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2ZXJzaW9uIDExLjBcbiAgICAgIHJlOiByZXN1bHQucmVsZXZhbmNlLFxuICAgICAgcmVsYXZhbmNlOiByZXN1bHQucmVsZXZhbmNlXG4gICAgfTtcbiAgICBpZiAocmVzdWx0LnNlY29uZF9iZXN0KSB7XG4gICAgICBlbGVtZW50LnNlY29uZF9iZXN0ID0ge1xuICAgICAgICBsYW5ndWFnZTogcmVzdWx0LnNlY29uZF9iZXN0Lmxhbmd1YWdlLFxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2ZXJzaW9uIDExLjBcbiAgICAgICAgcmU6IHJlc3VsdC5zZWNvbmRfYmVzdC5yZWxldmFuY2UsXG4gICAgICAgIHJlbGF2YW5jZTogcmVzdWx0LnNlY29uZF9iZXN0LnJlbGV2YW5jZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBoaWdobGlnaHQuanMgZ2xvYmFsIG9wdGlvbnMgd2l0aCB0aGUgcGFzc2VkIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPEhMSlNPcHRpb25zPn0gdXNlck9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyT3B0aW9ucykge1xuICAgIGlmICh1c2VyT3B0aW9ucy51c2VCUikge1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjMuMFwiLCBcIid1c2VCUicgd2lsbCBiZSByZW1vdmVkIGVudGlyZWx5IGluIHYxMS4wXCIpO1xuICAgICAgZGVwcmVjYXRlZChcIjEwLjMuMFwiLCBcIlBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjU1OVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IGluaGVyaXQkMShvcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSGlnaGxpZ2h0cyB0byBhbGwgPHByZT48Y29kZT4gYmxvY2tzIG9uIGEgcGFnZVxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb24gJiB7Y2FsbGVkPzogYm9vbGVhbn19XG4gICAqL1xuICBjb25zdCBpbml0SGlnaGxpZ2h0aW5nID0gKCkgPT4ge1xuICAgIGlmIChpbml0SGlnaGxpZ2h0aW5nLmNhbGxlZCkgcmV0dXJuO1xuICAgIGluaXRIaWdobGlnaHRpbmcuY2FsbGVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgYmxvY2tzLmZvckVhY2goaGlnaGxpZ2h0QmxvY2spO1xuICB9O1xuXG4gIC8vIEhpZ2xpZ2h0cyBhbGwgd2hlbiBET01Db250ZW50TG9hZGVkIGZpcmVzXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaW5pdEhpZ2hsaWdodGluZywgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbGFuZ3VhZ2UgZ3JhbW1hciBtb2R1bGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlTmFtZVxuICAgKiBAcGFyYW0ge0xhbmd1YWdlRm59IGxhbmd1YWdlRGVmaW5pdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMYW5ndWFnZShsYW5ndWFnZU5hbWUsIGxhbmd1YWdlRGVmaW5pdGlvbikge1xuICAgIGxldCBsYW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgbGFuZyA9IGxhbmd1YWdlRGVmaW5pdGlvbihobGpzKTtcbiAgICB9IGNhdGNoIChlcnJvciQxKSB7XG4gICAgICBlcnJvcihcIkxhbmd1YWdlIGRlZmluaXRpb24gZm9yICd7fScgY291bGQgbm90IGJlIHJlZ2lzdGVyZWQuXCIucmVwbGFjZShcInt9XCIsIGxhbmd1YWdlTmFtZSkpO1xuICAgICAgLy8gaGFyZCBvciBzb2Z0IGVycm9yXG4gICAgICBpZiAoIVNBRkVfTU9ERSkgeyB0aHJvdyBlcnJvciQxOyB9IGVsc2UgeyBlcnJvcihlcnJvciQxKTsgfVxuICAgICAgLy8gbGFuZ3VhZ2VzIHRoYXQgaGF2ZSBzZXJpb3VzIGVycm9ycyBhcmUgcmVwbGFjZWQgd2l0aCBlc3NlbnRpYWxseSBhXG4gICAgICAvLyBcInBsYWludGV4dFwiIHN0YW5kLWluIHNvIHRoYXQgdGhlIGNvZGUgYmxvY2tzIHdpbGwgc3RpbGwgZ2V0IG5vcm1hbFxuICAgICAgLy8gY3NzIGNsYXNzZXMgYXBwbGllZCB0byB0aGVtIC0gYW5kIG9uZSBiYWQgbGFuZ3VhZ2Ugd29uJ3QgYnJlYWsgdGhlXG4gICAgICAvLyBlbnRpcmUgaGlnaGxpZ2h0ZXJcbiAgICAgIGxhbmcgPSBQTEFJTlRFWFRfTEFOR1VBR0U7XG4gICAgfVxuICAgIC8vIGdpdmUgaXQgYSB0ZW1wb3JhcnkgbmFtZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lIGluIHRoZSBtZXRhLWRhdGFcbiAgICBpZiAoIWxhbmcubmFtZSkgbGFuZy5uYW1lID0gbGFuZ3VhZ2VOYW1lO1xuICAgIGxhbmd1YWdlc1tsYW5ndWFnZU5hbWVdID0gbGFuZztcbiAgICBsYW5nLnJhd0RlZmluaXRpb24gPSBsYW5ndWFnZURlZmluaXRpb24uYmluZChudWxsLCBobGpzKTtcblxuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIHJlZ2lzdGVyQWxpYXNlcyhsYW5nLmFsaWFzZXMsIHsgbGFuZ3VhZ2VOYW1lIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IExpc3Qgb2YgbGFuZ3VhZ2UgaW50ZXJuYWwgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gIH1cblxuICAvKipcbiAgICBpbnRlbmRlZCB1c2FnZTogV2hlbiBvbmUgbGFuZ3VhZ2UgdHJ1bHkgcmVxdWlyZXMgYW5vdGhlclxuXG4gICAgVW5saWtlIGBnZXRMYW5ndWFnZWAsIHRoaXMgd2lsbCB0aHJvdyB3aGVuIHRoZSByZXF1ZXN0ZWQgbGFuZ3VhZ2VcbiAgICBpcyBub3QgYXZhaWxhYmxlLlxuXG4gICAgQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byBmZXRjaC9yZXF1aXJlXG4gICAgQHJldHVybnMge0xhbmd1YWdlIHwgbmV2ZXJ9XG4gICovXG4gIGZ1bmN0aW9uIHJlcXVpcmVMYW5ndWFnZShuYW1lKSB7XG4gICAgZGVwcmVjYXRlZChcIjEwLjQuMFwiLCBcInJlcXVpcmVMYW5ndWFnZSB3aWxsIGJlIHJlbW92ZWQgZW50aXJlbHkgaW4gdjExLlwiKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNC4wXCIsIFwiUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL3B1bGwvMjg0NFwiKTtcblxuICAgIGNvbnN0IGxhbmcgPSBnZXRMYW5ndWFnZShuYW1lKTtcbiAgICBpZiAobGFuZykgeyByZXR1cm4gbGFuZzsgfVxuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdUaGUgXFwne31cXCcgbGFuZ3VhZ2UgaXMgcmVxdWlyZWQsIGJ1dCBub3QgbG9hZGVkLicucmVwbGFjZSgne30nLCBuYW1lKSk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMge0xhbmd1YWdlIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UobmFtZSkge1xuICAgIG5hbWUgPSAobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VzW25hbWVdIHx8IGxhbmd1YWdlc1thbGlhc2VzW25hbWVdXTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gYWxpYXNMaXN0IC0gc2luZ2xlIGFsaWFzIG9yIGxpc3Qgb2YgYWxpYXNlc1xuICAgKiBAcGFyYW0ge3tsYW5ndWFnZU5hbWU6IHN0cmluZ319IG9wdHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQWxpYXNlcyhhbGlhc0xpc3QsIHsgbGFuZ3VhZ2VOYW1lIH0pIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzTGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFsaWFzTGlzdCA9IFthbGlhc0xpc3RdO1xuICAgIH1cbiAgICBhbGlhc0xpc3QuZm9yRWFjaChhbGlhcyA9PiB7IGFsaWFzZXNbYWxpYXNdID0gbGFuZ3VhZ2VOYW1lOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gbGFuZ3VhZ2UgaGFzIGF1dG8tZGV0ZWN0aW9uIGVuYWJsZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZVxuICAgKi9cbiAgZnVuY3Rpb24gYXV0b0RldGVjdGlvbihuYW1lKSB7XG4gICAgY29uc3QgbGFuZyA9IGdldExhbmd1YWdlKG5hbWUpO1xuICAgIHJldHVybiBsYW5nICYmICFsYW5nLmRpc2FibGVBdXRvZGV0ZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtQbHVnaW5FdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHthbnl9IGFyZ3NcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnQsIGFyZ3MpIHtcbiAgICBjb25zdCBjYiA9IGV2ZW50O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgIGlmIChwbHVnaW5bY2JdKSB7XG4gICAgICAgIHBsdWdpbltjYl0oYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgTm90ZTogZml4TWFya3VwIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBlbnRpcmVseSBpbiB2MTFcblxuICBAcGFyYW0ge3N0cmluZ30gYXJnXG4gIEByZXR1cm5zIHtzdHJpbmd9XG4gICovXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZUZpeE1hcmt1cChhcmcpIHtcbiAgICBkZXByZWNhdGVkKFwiMTAuMi4wXCIsIFwiZml4TWFya3VwIHdpbGwgYmUgcmVtb3ZlZCBlbnRpcmVseSBpbiB2MTEuMFwiKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuMi4wXCIsIFwiUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yNTM0XCIpO1xuXG4gICAgcmV0dXJuIGZpeE1hcmt1cChhcmcpO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGRlZmluaXRpb24gKi9cbiAgT2JqZWN0LmFzc2lnbihobGpzLCB7XG4gICAgaGlnaGxpZ2h0LFxuICAgIGhpZ2hsaWdodEF1dG8sXG4gICAgZml4TWFya3VwOiBkZXByZWNhdGVGaXhNYXJrdXAsXG4gICAgaGlnaGxpZ2h0QmxvY2ssXG4gICAgY29uZmlndXJlLFxuICAgIGluaXRIaWdobGlnaHRpbmcsXG4gICAgaW5pdEhpZ2hsaWdodGluZ09uTG9hZCxcbiAgICByZWdpc3Rlckxhbmd1YWdlLFxuICAgIGxpc3RMYW5ndWFnZXMsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgcmVnaXN0ZXJBbGlhc2VzLFxuICAgIHJlcXVpcmVMYW5ndWFnZSxcbiAgICBhdXRvRGV0ZWN0aW9uLFxuICAgIGluaGVyaXQ6IGluaGVyaXQkMSxcbiAgICBhZGRQbHVnaW4sXG4gICAgLy8gcGx1Z2lucyBmb3IgZnJhbWV3b3Jrc1xuICAgIHZ1ZVBsdWdpbjogQnVpbGRWdWVQbHVnaW4oaGxqcykuVnVlUGx1Z2luXG4gIH0pO1xuXG4gIGhsanMuZGVidWdNb2RlID0gZnVuY3Rpb24oKSB7IFNBRkVfTU9ERSA9IGZhbHNlOyB9O1xuICBobGpzLnNhZmVNb2RlID0gZnVuY3Rpb24oKSB7IFNBRkVfTU9ERSA9IHRydWU7IH07XG4gIGhsanMudmVyc2lvblN0cmluZyA9IHZlcnNpb247XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gTU9ERVMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBNT0RFU1trZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBkZWVwRnJlZXplRXM2KE1PREVTW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGFsbCB0aGUgbW9kZXMvcmVnZXhzIGludG8gb3VyIG1haW4gb2JqZWN0XG4gIE9iamVjdC5hc3NpZ24oaGxqcywgTU9ERVMpO1xuXG4gIC8vIGJ1aWx0LWluIHBsdWdpbnMsIGxpa2VseSB0byBiZSBtb3ZlZCBvdXQgb2YgY29yZSBpbiB0aGUgZnV0dXJlXG4gIGhsanMuYWRkUGx1Z2luKGJyUGx1Z2luKTsgLy8gc2xhdGVkIHRvIGJlIHJlbW92ZWQgaW4gdjExXG4gIGhsanMuYWRkUGx1Z2luKG1lcmdlSFRNTFBsdWdpbik7XG4gIGhsanMuYWRkUGx1Z2luKHRhYlJlcGxhY2VQbHVnaW4pO1xuICByZXR1cm4gaGxqcztcbn07XG5cbi8vIGV4cG9ydCBhbiBcImluc3RhbmNlXCIgb2YgdGhlIGhpZ2hsaWdodGVyXG52YXIgaGlnaGxpZ2h0ID0gSExKUyh7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaGlnaGxpZ2h0O1xuIl0sIm5hbWVzIjpbImRlZXBGcmVlemUiLCJvYmoiLCJNYXAiLCJjbGVhciIsImRlbGV0ZSIsInNldCIsIkVycm9yIiwiU2V0IiwiYWRkIiwiT2JqZWN0IiwiZnJlZXplIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJuYW1lIiwicHJvcCIsImlzRnJvemVuIiwiZGVlcEZyZWV6ZUVzNiIsIl9kZWZhdWx0IiwiZGVmYXVsdCIsIlJlc3BvbnNlIiwiY29uc3RydWN0b3IiLCJtb2RlIiwiZGF0YSIsInVuZGVmaW5lZCIsImlnbm9yZU1hdGNoIiwiaWdub3JlIiwiZXNjYXBlSFRNTCIsInZhbHVlIiwicmVwbGFjZSIsImluaGVyaXQiLCJvcmlnaW5hbCIsIm9iamVjdHMiLCJyZXN1bHQiLCJjcmVhdGUiLCJrZXkiLCJTUEFOX0NMT1NFIiwiZW1pdHNXcmFwcGluZ1RhZ3MiLCJub2RlIiwia2luZCIsIkhUTUxSZW5kZXJlciIsInBhcnNlVHJlZSIsIm9wdGlvbnMiLCJidWZmZXIiLCJjbGFzc1ByZWZpeCIsIndhbGsiLCJhZGRUZXh0IiwidGV4dCIsIm9wZW5Ob2RlIiwiY2xhc3NOYW1lIiwic3VibGFuZ3VhZ2UiLCJzcGFuIiwiY2xvc2VOb2RlIiwiVG9rZW5UcmVlIiwicm9vdE5vZGUiLCJjaGlsZHJlbiIsInN0YWNrIiwidG9wIiwibGVuZ3RoIiwicm9vdCIsInB1c2giLCJwb3AiLCJjbG9zZUFsbE5vZGVzIiwidG9KU09OIiwiSlNPTiIsInN0cmluZ2lmeSIsImJ1aWxkZXIiLCJfd2FsayIsImNoaWxkIiwiX2NvbGxhcHNlIiwiZXZlcnkiLCJlbCIsImpvaW4iLCJUb2tlblRyZWVFbWl0dGVyIiwiYWRkS2V5d29yZCIsImFkZFN1Ymxhbmd1YWdlIiwiZW1pdHRlciIsInRvSFRNTCIsInJlbmRlcmVyIiwiZmluYWxpemUiLCJlc2NhcGUiLCJSZWdFeHAiLCJzb3VyY2UiLCJyZSIsImNvbmNhdCIsImFyZ3MiLCJqb2luZWQiLCJtYXAiLCJ4IiwiZWl0aGVyIiwiY291bnRNYXRjaEdyb3VwcyIsInRvU3RyaW5nIiwiZXhlYyIsInN0YXJ0c1dpdGgiLCJsZXhlbWUiLCJtYXRjaCIsImluZGV4IiwicmVnZXhwcyIsInNlcGFyYXRvciIsImJhY2tyZWZlcmVuY2VSZSIsIm51bUNhcHR1cmVzIiwicmV0IiwiaSIsIm9mZnNldCIsInN1YnN0cmluZyIsIlN0cmluZyIsIk51bWJlciIsIklERU5UX1JFIiwiVU5ERVJTQ09SRV9JREVOVF9SRSIsIk5VTUJFUl9SRSIsIkNfTlVNQkVSX1JFIiwiQklOQVJZX05VTUJFUl9SRSIsIlJFX1NUQVJURVJTX1JFIiwiU0hFQkFORyIsIm9wdHMiLCJiZWdpblNoZWJhbmciLCJiaW5hcnkiLCJiZWdpbiIsImVuZCIsInJlbGV2YW5jZSIsIm0iLCJyZXNwIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkFQT1NfU1RSSU5HX01PREUiLCJpbGxlZ2FsIiwiY29udGFpbnMiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlBIUkFTQUxfV09SRFNfTU9ERSIsIkNPTU1FTlQiLCJtb2RlT3B0aW9ucyIsIkNfTElORV9DT01NRU5UX01PREUiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkhBU0hfQ09NTUVOVF9NT0RFIiwiTlVNQkVSX01PREUiLCJDX05VTUJFUl9NT0RFIiwiQklOQVJZX05VTUJFUl9NT0RFIiwiQ1NTX05VTUJFUl9NT0RFIiwiUkVHRVhQX01PREUiLCJUSVRMRV9NT0RFIiwiVU5ERVJTQ09SRV9USVRMRV9NT0RFIiwiTUVUSE9EX0dVQVJEIiwiRU5EX1NBTUVfQVNfQkVHSU4iLCJhc3NpZ24iLCJfYmVnaW5NYXRjaCIsIk1PREVTIiwiX19wcm90b19fIiwic2tpcElmaGFzUHJlY2VkaW5nRG90IiwicmVzcG9uc2UiLCJiZWZvcmUiLCJpbnB1dCIsImJlZ2luS2V5d29yZHMiLCJwYXJlbnQiLCJzcGxpdCIsIl9fYmVmb3JlQmVnaW4iLCJrZXl3b3JkcyIsImNvbXBpbGVJbGxlZ2FsIiwiX3BhcmVudCIsIkFycmF5IiwiaXNBcnJheSIsImNvbXBpbGVNYXRjaCIsImNvbXBpbGVSZWxldmFuY2UiLCJDT01NT05fS0VZV09SRFMiLCJjb21waWxlS2V5d29yZHMiLCJyYXdLZXl3b3JkcyIsImNhc2VJbnNlbnNpdGl2ZSIsImNvbXBpbGVkS2V5d29yZHMiLCJzcGxpdEFuZENvbXBpbGUiLCJrZXlzIiwia2V5d29yZExpc3QiLCJ0b0xvd2VyQ2FzZSIsImtleXdvcmQiLCJwYWlyIiwic2NvcmVGb3JLZXl3b3JkIiwicHJvdmlkZWRTY29yZSIsImNvbW1vbktleXdvcmQiLCJpbmNsdWRlcyIsImNvbXBpbGVMYW5ndWFnZSIsImxhbmd1YWdlIiwicGx1Z2lucyIsImxhbmdSZSIsImdsb2JhbCIsImNhc2VfaW5zZW5zaXRpdmUiLCJNdWx0aVJlZ2V4IiwibWF0Y2hJbmRleGVzIiwicmVnZXhlcyIsIm1hdGNoQXQiLCJwb3NpdGlvbiIsImFkZFJ1bGUiLCJjb21waWxlIiwidGVybWluYXRvcnMiLCJtYXRjaGVyUmUiLCJsYXN0SW5kZXgiLCJzIiwiZmluZEluZGV4IiwibWF0Y2hEYXRhIiwic3BsaWNlIiwiUmVzdW1hYmxlTXVsdGlSZWdleCIsInJ1bGVzIiwibXVsdGlSZWdleGVzIiwiY291bnQiLCJyZWdleEluZGV4IiwiZ2V0TWF0Y2hlciIsIm1hdGNoZXIiLCJzbGljZSIsInJlc3VtaW5nU2NhbkF0U2FtZVBvc2l0aW9uIiwiY29uc2lkZXJBbGwiLCJ0eXBlIiwibTIiLCJidWlsZE1vZGVSZWdleCIsIm1tIiwidGVybSIsInJ1bGUiLCJ0ZXJtaW5hdG9yRW5kIiwiY29tcGlsZU1vZGUiLCJjbW9kZSIsImNvbXBpbGVkIiwiZXh0IiwiY29tcGlsZXJFeHRlbnNpb25zIiwia2V5d29yZFBhdHRlcm4iLCIkcGF0dGVybiIsImxleGVtZXMiLCJrZXl3b3JkUGF0dGVyblJlIiwiYmVnaW5SZSIsImVuZFNhbWVBc0JlZ2luIiwiZW5kc1dpdGhQYXJlbnQiLCJlbmRSZSIsImlsbGVnYWxSZSIsImMiLCJleHBhbmRPckNsb25lTW9kZSIsInN0YXJ0cyIsImNsYXNzTmFtZUFsaWFzZXMiLCJkZXBlbmRlbmN5T25QYXJlbnQiLCJ2YXJpYW50cyIsImNhY2hlZFZhcmlhbnRzIiwidmFyaWFudCIsInZlcnNpb24iLCJoYXNWYWx1ZU9yRW1wdHlBdHRyaWJ1dGUiLCJCb29sZWFuIiwiQnVpbGRWdWVQbHVnaW4iLCJobGpzIiwiQ29tcG9uZW50IiwicHJvcHMiLCJkZXRlY3RlZExhbmd1YWdlIiwidW5rbm93bkxhbmd1YWdlIiwiY29tcHV0ZWQiLCJoaWdobGlnaHRlZCIsImF1dG9EZXRlY3QiLCJnZXRMYW5ndWFnZSIsImNvbnNvbGUiLCJ3YXJuIiwiY29kZSIsImhpZ2hsaWdodEF1dG8iLCJoaWdobGlnaHQiLCJpZ25vcmVJbGxlZ2FscyIsImF1dG9kZXRlY3QiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3MiLCJkb21Qcm9wcyIsImlubmVySFRNTCIsIlZ1ZVBsdWdpbiIsImluc3RhbGwiLCJWdWUiLCJjb21wb25lbnQiLCJtZXJnZUhUTUxQbHVnaW4iLCJibG9jayIsIm9yaWdpbmFsU3RyZWFtIiwibm9kZVN0cmVhbSIsInJlc3VsdE5vZGUiLCJkb2N1bWVudCIsIm1lcmdlU3RyZWFtcyIsInRhZyIsIm5vZGVOYW1lIiwiX25vZGVTdHJlYW0iLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJub2RlVHlwZSIsIm5vZGVWYWx1ZSIsImV2ZW50IiwicHJvY2Vzc2VkIiwibm9kZVN0YWNrIiwic2VsZWN0U3RyZWFtIiwib3BlbiIsImF0dHJpYnV0ZVN0cmluZyIsImF0dHIiLCJjYWxsIiwiYXR0cmlidXRlcyIsImNsb3NlIiwic3RyZWFtIiwicmV2ZXJzZSIsInN1YnN0ciIsImVycm9yIiwibWVzc2FnZSIsImxvZyIsImRlcHJlY2F0ZWQiLCJlc2NhcGUkMSIsImluaGVyaXQkMSIsIk5PX01BVENIIiwiU3ltYm9sIiwiSExKUyIsImxhbmd1YWdlcyIsImFsaWFzZXMiLCJTQUZFX01PREUiLCJmaXhNYXJrdXBSZSIsIkxBTkdVQUdFX05PVF9GT1VORCIsIlBMQUlOVEVYVF9MQU5HVUFHRSIsImRpc2FibGVBdXRvZGV0ZWN0Iiwibm9IaWdobGlnaHRSZSIsImxhbmd1YWdlRGV0ZWN0UmUiLCJ0YWJSZXBsYWNlIiwidXNlQlIiLCJfX2VtaXR0ZXIiLCJzaG91bGROb3RIaWdobGlnaHQiLCJsYW5ndWFnZU5hbWUiLCJ0ZXN0IiwiYmxvY2tMYW5ndWFnZSIsImNsYXNzZXMiLCJwYXJlbnROb2RlIiwiZmluZCIsIl9jbGFzcyIsImNvbnRpbnVhdGlvbiIsImNvbnRleHQiLCJmaXJlIiwiX2hpZ2hsaWdodCIsImNvZGVUb0hpZ2hsaWdodCIsImtleXdvcmREYXRhIiwibWF0Y2hUZXh0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwcm9jZXNzS2V5d29yZHMiLCJtb2RlQnVmZmVyIiwiYnVmIiwia2V5d29yZFJlbGV2YW5jZSIsImNzc0NsYXNzIiwicHJvY2Vzc1N1Ykxhbmd1YWdlIiwic3ViTGFuZ3VhZ2UiLCJjb250aW51YXRpb25zIiwicHJvY2Vzc0J1ZmZlciIsInN0YXJ0TmV3TW9kZSIsImVuZE9mTW9kZSIsIm1hdGNoUGx1c1JlbWFpbmRlciIsIm1hdGNoZWQiLCJlbmRzUGFyZW50IiwiZG9JZ25vcmUiLCJyZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24iLCJkb0JlZ2luTWF0Y2giLCJuZXdNb2RlIiwiYmVmb3JlQ2FsbGJhY2tzIiwiY2IiLCJza2lwIiwiZXhjbHVkZUJlZ2luIiwicmV0dXJuQmVnaW4iLCJkb0VuZE1hdGNoIiwiZW5kTW9kZSIsIm9yaWdpbiIsInJldHVybkVuZCIsImV4Y2x1ZGVFbmQiLCJwcm9jZXNzQ29udGludWF0aW9ucyIsImxpc3QiLCJjdXJyZW50IiwidW5zaGlmdCIsIml0ZW0iLCJsYXN0TWF0Y2giLCJwcm9jZXNzTGV4ZW1lIiwidGV4dEJlZm9yZU1hdGNoIiwiZXJyIiwiYmFkUnVsZSIsIml0ZXJhdGlvbnMiLCJtZCIsImJlZm9yZU1hdGNoIiwicHJvY2Vzc2VkQ291bnQiLCJpbGxlZ2FsQnkiLCJtc2ciLCJzb2ZhciIsImVycm9yUmFpc2VkIiwianVzdFRleHRIaWdobGlnaHRSZXN1bHQiLCJsYW5ndWFnZVN1YnNldCIsInBsYWludGV4dCIsInJlc3VsdHMiLCJmaWx0ZXIiLCJhdXRvRGV0ZWN0aW9uIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwic3VwZXJzZXRPZiIsImJlc3QiLCJzZWNvbmRCZXN0Iiwic2Vjb25kX2Jlc3QiLCJmaXhNYXJrdXAiLCJodG1sIiwidXBkYXRlQ2xhc3NOYW1lIiwiZWxlbWVudCIsImN1cnJlbnRMYW5nIiwicmVzdWx0TGFuZyIsImNsYXNzTGlzdCIsImJyUGx1Z2luIiwiVEFCX1JFUExBQ0VfUkUiLCJ0YWJSZXBsYWNlUGx1Z2luIiwiaGlnaGxpZ2h0QmxvY2siLCJ0ZXh0Q29udGVudCIsInJlbGF2YW5jZSIsImNvbmZpZ3VyZSIsInVzZXJPcHRpb25zIiwiaW5pdEhpZ2hsaWdodGluZyIsImNhbGxlZCIsImJsb2NrcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbml0SGlnaGxpZ2h0aW5nT25Mb2FkIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlZ2lzdGVyTGFuZ3VhZ2UiLCJsYW5ndWFnZURlZmluaXRpb24iLCJsYW5nIiwiZXJyb3IkMSIsInJhd0RlZmluaXRpb24iLCJiaW5kIiwicmVnaXN0ZXJBbGlhc2VzIiwibGlzdExhbmd1YWdlcyIsInJlcXVpcmVMYW5ndWFnZSIsImFsaWFzTGlzdCIsImFsaWFzIiwiYWRkUGx1Z2luIiwicGx1Z2luIiwiZGVwcmVjYXRlRml4TWFya3VwIiwiYXJnIiwidnVlUGx1Z2luIiwiZGVidWdNb2RlIiwic2FmZU1vZGUiLCJ2ZXJzaW9uU3RyaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsV0FBV0MsR0FBRztJQUNuQixJQUFJQSxlQUFlQyxLQUFLO1FBQ3BCRCxJQUFJRSxLQUFLLEdBQUdGLElBQUlHLE1BQU0sR0FBR0gsSUFBSUksR0FBRyxHQUFHO1lBQy9CLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKLE9BQU8sSUFBSUwsZUFBZU0sS0FBSztRQUMzQk4sSUFBSU8sR0FBRyxHQUFHUCxJQUFJRSxLQUFLLEdBQUdGLElBQUlHLE1BQU0sR0FBRztZQUMvQixNQUFNLElBQUlFLE1BQU07UUFDcEI7SUFDSjtJQUVBLGNBQWM7SUFDZEcsT0FBT0MsTUFBTSxDQUFDVDtJQUVkUSxPQUFPRSxtQkFBbUIsQ0FBQ1YsS0FBS1csT0FBTyxDQUFDLFNBQVVDLElB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VTtRQUNyQkEsV0FBVyxVQUFVO1FBRXJCLE9BQU8rRixVQUFVb0M7SUFDbkI7SUFFQSx3QkFBd0IsR0FDeEIvWixPQUFPb0ksTUFBTSxDQUFDaUcsTUFBTTtRQUNsQmE7UUFDQUQ7UUFDQTBJLFdBQVdtQztRQUNYekI7UUFDQUc7UUFDQUU7UUFDQUk7UUFDQUc7UUFDQU87UUFDQTNLO1FBQ0EwSztRQUNBRTtRQUNBdkM7UUFDQTlWLFNBQVMwUTtRQUNUOEg7UUFDQSx5QkFBeUI7UUFDekJJLFdBQVc1TCxlQUFlQyxNQUFNcUIsU0FBUztJQUMzQztJQUVBckIsS0FBSzRMLFNBQVMsR0FBRztRQUFhN0gsWUFBWTtJQUFPO0lBQ2pEL0QsS0FBSzZMLFFBQVEsR0FBRztRQUFhOUgsWUFBWTtJQUFNO0lBQy9DL0QsS0FBSzhMLGFBQWEsR0FBR2xNO0lBRXJCLElBQUssTUFBTXhNLE9BQU82RyxNQUFPO1FBQ3ZCLGFBQWE7UUFDYixJQUFJLE9BQU9BLEtBQUssQ0FBQzdHLElBQUksS0FBSyxVQUFVO1lBQ2xDLGFBQWE7WUFDYmxCLGNBQWMrSCxLQUFLLENBQUM3RyxJQUFJO1FBQzFCO0lBQ0Y7SUFFQSxrREFBa0Q7SUFDbER6QixPQUFPb0ksTUFBTSxDQUFDaUcsTUFBTS9GO0lBRXBCLGlFQUFpRTtJQUNqRStGLEtBQUt1TCxTQUFTLENBQUMxQixXQUFXLDhCQUE4QjtJQUN4RDdKLEtBQUt1TCxTQUFTLENBQUM5SjtJQUNmekIsS0FBS3VMLFNBQVMsQ0FBQ3hCO0lBQ2YsT0FBTy9KO0FBQ1Q7QUFFQSwwQ0FBMEM7QUFDMUMsSUFBSWEsWUFBWStDLEtBQUssQ0FBQztBQUV0Qm1JLE9BQU9DLE9BQU8sR0FBR25MIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvY29yZS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/bash.js":
/*!*********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/bash.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/*\nLanguage: Bash\nAuthor: vah <vahtenberg@gmail.com>\nContributrors: Benjamin Pannell <contact@sierrasoftworks.com>\nWebsite: https://www.gnu.org/software/bash/\nCategory: common\n*/ /** @type LanguageFn */ function bash(hljs) {\n    const VAR = {};\n    const BRACED_VAR = {\n        begin: /\\$\\{/,\n        end: /\\}/,\n        contains: [\n            \"self\",\n            {\n                begin: /:-/,\n                contains: [\n                    VAR\n                ]\n            } // default values\n        ]\n    };\n    Object.assign(VAR, {\n        className: \"variable\",\n        variants: [\n            {\n                begin: concat(/\\$[\\w\\d#@][\\w\\d_]*/, // negative look-ahead tries to avoid matching patterns that are not\n                // Perl at all like $ident$, @ident@, etc.\n                `(?![\\\\w\\\\d])(?![$])`)\n            },\n            BRACED_VAR\n        ]\n    });\n    const SUBST = {\n        className: \"subst\",\n        begin: /\\$\\(/,\n        end: /\\)/,\n        contains: [\n            hljs.BACKSLASH_ESCAPE\n        ]\n    };\n    const HERE_DOC = {\n        begin: /<<-?\\s*(?=\\w+)/,\n        starts: {\n            contains: [\n                hljs.END_SAME_AS_BEGIN({\n                    begin: /(\\w+)/,\n                    end: /(\\w+)/,\n                    className: \"string\"\n                })\n            ]\n        }\n    };\n    const QUOTE_STRING = {\n        className: \"string\",\n        begin: /\"/,\n        end: /\"/,\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            VAR,\n            SUBST\n        ]\n    };\n    SUBST.contains.push(QUOTE_STRING);\n    const ESCAPED_QUOTE = {\n        className: \"\",\n        begin: /\\\\\"/\n    };\n    const APOS_STRING = {\n        className: \"string\",\n        begin: /'/,\n        end: /'/\n    };\n    const ARITHMETIC = {\n        begin: /\\$\\(\\(/,\n        end: /\\)\\)/,\n        contains: [\n            {\n                begin: /\\d+#[0-9a-f]+/,\n                className: \"number\"\n            },\n            hljs.NUMBER_MODE,\n            VAR\n        ]\n    };\n    const SH_LIKE_SHELLS = [\n        \"fish\",\n        \"bash\",\n        \"zsh\",\n        \"sh\",\n        \"csh\",\n        \"ksh\",\n        \"tcsh\",\n        \"dash\",\n        \"scsh\"\n    ];\n    const KNOWN_SHEBANG = hljs.SHEBANG({\n        binary: `(${SH_LIKE_SHELLS.join(\"|\")})`,\n        relevance: 10\n    });\n    const FUNCTION = {\n        className: \"function\",\n        begin: /\\w[\\w\\d_]*\\s*\\(\\s*\\)\\s*\\{/,\n        returnBegin: true,\n        contains: [\n            hljs.inherit(hljs.TITLE_MODE, {\n                begin: /\\w[\\w\\d_]*/\n            })\n        ],\n        relevance: 0\n    };\n    return {\n        name: \"Bash\",\n        aliases: [\n            \"sh\",\n            \"zsh\"\n        ],\n        keywords: {\n            $pattern: /\\b[a-z._-]+\\b/,\n            keyword: \"if then else elif fi for while in do done case esac function\",\n            literal: \"true false\",\n            built_in: // Shell built-ins\n            // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n            \"break cd continue eval exec exit export getopts hash pwd readonly return shift test times \" + \"trap umask unset \" + // Bash built-ins\n            \"alias bind builtin caller command declare echo enable help let local logout mapfile printf \" + \"read readarray source type typeset ulimit unalias \" + // Shell modifiers\n            \"set shopt \" + // Zsh built-ins\n            \"autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles \" + \"compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate \" + \"fc fg float functions getcap getln history integer jobs kill limit log noglob popd print \" + \"pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit \" + \"unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof \" + \"zpty zregexparse zsocket zstyle ztcp\"\n        },\n        contains: [\n            KNOWN_SHEBANG,\n            hljs.SHEBANG(),\n            FUNCTION,\n            ARITHMETIC,\n            hljs.HASH_COMMENT_MODE,\n            HERE_DOC,\n            QUOTE_STRING,\n            ESCAPED_QUOTE,\n            APOS_STRING,\n            VAR\n        ]\n    };\n}\nmodule.exports = bash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Jhc2guanM/YWZmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqICovXG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc291cmNlKHJlKSB7XG4gIGlmICghcmUpIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHJlID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmU7XG5cbiAgcmV0dXJuIHJlLnNvdXJjZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gey4uLihSZWdFeHAgfCBzdHJpbmcpIH0gYXJnc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY29uY2F0KC4uLmFyZ3MpIHtcbiAgY29uc3Qgam9pbmVkID0gYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLypcbkxhbmd1YWdlOiBCYXNoXG5BdXRob3I6IHZhaCA8dmFodGVuYmVyZ0BnbWFpbC5jb20+XG5Db250cmlidXRyb3JzOiBCZW5qYW1pbiBQYW5uZWxsIDxjb250YWN0QHNpZXJyYXNvZnR3b3Jrcy5jb20+XG5XZWJzaXRlOiBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvXG5DYXRlZ29yeTogY29tbW9uXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gYmFzaChobGpzKSB7XG4gIGNvbnN0IFZBUiA9IHt9O1xuICBjb25zdCBCUkFDRURfVkFSID0ge1xuICAgIGJlZ2luOiAvXFwkXFx7LyxcbiAgICBlbmQ6L1xcfS8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIFwic2VsZlwiLFxuICAgICAge1xuICAgICAgICBiZWdpbjogLzotLyxcbiAgICAgICAgY29udGFpbnM6IFsgVkFSIF1cbiAgICAgIH0gLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICBdXG4gIH07XG4gIE9iamVjdC5hc3NpZ24oVkFSLHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtiZWdpbjogY29uY2F0KC9cXCRbXFx3XFxkI0BdW1xcd1xcZF9dKi8sXG4gICAgICAgIC8vIG5lZ2F0aXZlIGxvb2stYWhlYWQgdHJpZXMgdG8gYXZvaWQgbWF0Y2hpbmcgcGF0dGVybnMgdGhhdCBhcmUgbm90XG4gICAgICAgIC8vIFBlcmwgYXQgYWxsIGxpa2UgJGlkZW50JCwgQGlkZW50QCwgZXRjLlxuICAgICAgICBgKD8hW1xcXFx3XFxcXGRdKSg/IVskXSlgKSB9LFxuICAgICAgQlJBQ0VEX1ZBUlxuICAgIF1cbiAgfSk7XG5cbiAgY29uc3QgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAvXFwkXFwoLywgZW5kOiAvXFwpLyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV1cbiAgfTtcbiAgY29uc3QgSEVSRV9ET0MgPSB7XG4gICAgYmVnaW46IC88PC0/XFxzKig/PVxcdyspLyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuRU5EX1NBTUVfQVNfQkVHSU4oe1xuICAgICAgICAgIGJlZ2luOiAvKFxcdyspLyxcbiAgICAgICAgICBlbmQ6IC8oXFx3KykvLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmluZydcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICB9XG4gIH07XG4gIGNvbnN0IFFVT1RFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFZBUixcbiAgICAgIFNVQlNUXG4gICAgXVxuICB9O1xuICBTVUJTVC5jb250YWlucy5wdXNoKFFVT1RFX1NUUklORyk7XG4gIGNvbnN0IEVTQ0FQRURfUVVPVEUgPSB7XG4gICAgY2xhc3NOYW1lOiAnJyxcbiAgICBiZWdpbjogL1xcXFxcIi9cblxuICB9O1xuICBjb25zdCBBUE9TX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvJy8sIGVuZDogLycvXG4gIH07XG4gIGNvbnN0IEFSSVRITUVUSUMgPSB7XG4gICAgYmVnaW46IC9cXCRcXChcXCgvLFxuICAgIGVuZDogL1xcKVxcKS8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgYmVnaW46IC9cXGQrI1swLTlhLWZdKy8sIGNsYXNzTmFtZTogXCJudW1iZXJcIiB9LFxuICAgICAgaGxqcy5OVU1CRVJfTU9ERSxcbiAgICAgIFZBUlxuICAgIF1cbiAgfTtcbiAgY29uc3QgU0hfTElLRV9TSEVMTFMgPSBbXG4gICAgXCJmaXNoXCIsXG4gICAgXCJiYXNoXCIsXG4gICAgXCJ6c2hcIixcbiAgICBcInNoXCIsXG4gICAgXCJjc2hcIixcbiAgICBcImtzaFwiLFxuICAgIFwidGNzaFwiLFxuICAgIFwiZGFzaFwiLFxuICAgIFwic2NzaFwiLFxuICBdO1xuICBjb25zdCBLTk9XTl9TSEVCQU5HID0gaGxqcy5TSEVCQU5HKHtcbiAgICBiaW5hcnk6IGAoJHtTSF9MSUtFX1NIRUxMUy5qb2luKFwifFwiKX0pYCxcbiAgICByZWxldmFuY2U6IDEwXG4gIH0pO1xuICBjb25zdCBGVU5DVElPTiA9IHtcbiAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgYmVnaW46IC9cXHdbXFx3XFxkX10qXFxzKlxcKFxccypcXClcXHMqXFx7LyxcbiAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICBjb250YWluczogW2hsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHtiZWdpbjogL1xcd1tcXHdcXGRfXSovfSldLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0Jhc2gnLFxuICAgIGFsaWFzZXM6IFsnc2gnLCAnenNoJ10sXG4gICAga2V5d29yZHM6IHtcbiAgICAgICRwYXR0ZXJuOiAvXFxiW2Etei5fLV0rXFxiLyxcbiAgICAgIGtleXdvcmQ6XG4gICAgICAgICdpZiB0aGVuIGVsc2UgZWxpZiBmaSBmb3Igd2hpbGUgaW4gZG8gZG9uZSBjYXNlIGVzYWMgZnVuY3Rpb24nLFxuICAgICAgbGl0ZXJhbDpcbiAgICAgICAgJ3RydWUgZmFsc2UnLFxuICAgICAgYnVpbHRfaW46XG4gICAgICAgIC8vIFNoZWxsIGJ1aWx0LWluc1xuICAgICAgICAvLyBodHRwOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgICAgICAnYnJlYWsgY2QgY29udGludWUgZXZhbCBleGVjIGV4aXQgZXhwb3J0IGdldG9wdHMgaGFzaCBwd2QgcmVhZG9ubHkgcmV0dXJuIHNoaWZ0IHRlc3QgdGltZXMgJyArXG4gICAgICAgICd0cmFwIHVtYXNrIHVuc2V0ICcgK1xuICAgICAgICAvLyBCYXNoIGJ1aWx0LWluc1xuICAgICAgICAnYWxpYXMgYmluZCBidWlsdGluIGNhbGxlciBjb21tYW5kIGRlY2xhcmUgZWNobyBlbmFibGUgaGVscCBsZXQgbG9jYWwgbG9nb3V0IG1hcGZpbGUgcHJpbnRmICcgK1xuICAgICAgICAncmVhZCByZWFkYXJyYXkgc291cmNlIHR5cGUgdHlwZXNldCB1bGltaXQgdW5hbGlhcyAnICtcbiAgICAgICAgLy8gU2hlbGwgbW9kaWZpZXJzXG4gICAgICAgICdzZXQgc2hvcHQgJyArXG4gICAgICAgIC8vIFpzaCBidWlsdC1pbnNcbiAgICAgICAgJ2F1dG9sb2FkIGJnIGJpbmRrZXkgYnllIGNhcCBjaGRpciBjbG9uZSBjb21wYXJndW1lbnRzIGNvbXBjYWxsIGNvbXBjdGwgY29tcGRlc2NyaWJlIGNvbXBmaWxlcyAnICtcbiAgICAgICAgJ2NvbXBncm91cHMgY29tcHF1b3RlIGNvbXB0YWdzIGNvbXB0cnkgY29tcHZhbHVlcyBkaXJzIGRpc2FibGUgZGlzb3duIGVjaG90YyBlY2hvdGkgZW11bGF0ZSAnICtcbiAgICAgICAgJ2ZjIGZnIGZsb2F0IGZ1bmN0aW9ucyBnZXRjYXAgZ2V0bG4gaGlzdG9yeSBpbnRlZ2VyIGpvYnMga2lsbCBsaW1pdCBsb2cgbm9nbG9iIHBvcGQgcHJpbnQgJyArXG4gICAgICAgICdwdXNoZCBwdXNobG4gcmVoYXNoIHNjaGVkIHNldGNhcCBzZXRvcHQgc3RhdCBzdXNwZW5kIHR0eWN0bCB1bmZ1bmN0aW9uIHVuaGFzaCB1bmxpbWl0ICcgK1xuICAgICAgICAndW5zZXRvcHQgdmFyZWQgd2FpdCB3aGVuY2Ugd2hlcmUgd2hpY2ggemNvbXBpbGUgemZvcm1hdCB6ZnRwIHpsZSB6bW9kbG9hZCB6cGFyc2VvcHRzIHpwcm9mICcgK1xuICAgICAgICAnenB0eSB6cmVnZXhwYXJzZSB6c29ja2V0IHpzdHlsZSB6dGNwJ1xuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIEtOT1dOX1NIRUJBTkcsIC8vIHRvIGNhdGNoIGtub3duIHNoZWxscyBhbmQgYm9vc3QgcmVsZXZhbmN5XG4gICAgICBobGpzLlNIRUJBTkcoKSwgLy8gdG8gY2F0Y2ggdW5rbm93biBzaGVsbHMgYnV0IHN0aWxsIGhpZ2hsaWdodCB0aGUgc2hlYmFuZ1xuICAgICAgRlVOQ1RJT04sXG4gICAgICBBUklUSE1FVElDLFxuICAgICAgaGxqcy5IQVNIX0NPTU1FTlRfTU9ERSxcbiAgICAgIEhFUkVfRE9DLFxuICAgICAgUVVPVEVfU1RSSU5HLFxuICAgICAgRVNDQVBFRF9RVU9URSxcbiAgICAgIEFQT1NfU1RSSU5HLFxuICAgICAgVkFSXG4gICAgXVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2g7XG4iXSwibmFtZXMiOlsic291cmNlIiwicmUiLCJjb25jYXQiLCJhcmdzIiwiam9pbmVkIiwibWFwIiwieCIsImpvaW4iLCJiYXNoIiwiaGxqcyIsIlZBUiIsIkJSQUNFRF9WQVIiLCJiZWdpbiIsImVuZCIsImNvbnRhaW5zIiwiT2JqZWN0IiwiYXNzaWduIiwiY2xhc3NOYW1lIiwidmFyaWFudHMiLCJTVUJTVCIsIkJBQ0tTTEFTSF9FU0NBUEUiLCJIRVJFX0RPQyIsInN0YXJ0cyIsIkVORF9TQU1FX0FTX0JFR0lOIiwiUVVPVEVfU1RSSU5HIiwicHVzaCIsIkVTQ0FQRURfUVVPVEUiLCJBUE9TX1NUUklORyIsIkFSSVRITUVUSUMiLCJOVU1CRVJfTU9ERSIsIlNIX0xJS0VfU0hFTExTIiwiS05PV05fU0hFQkFORyIsIlNIRUJBTkciLCJiaW5hcnkiLCJyZWxldmFuY2UiLCJGVU5DVElPTiIsInJldHVybkJlZ2luIiwiaW5oZXJpdCIsIlRJVExFX01PREUiLCJuYW1lIiwiYWxpYXNlcyIsImtleXdvcmRzIiwiJHBhdHRlcm4iLCJrZXl3b3JkIiwibGl0ZXJhbCIsImJ1aWx0X2luIiwiSEFTSF9DT01NRU5UX01PREUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0csR0FFSDs7O0NBR0MsR0FDRCxTQUFTQSxPQUFPQyxFQUFFO0lBQ2hCLElBQUksQ0FBQ0EsSUFBSSxPQUFPO0lBQ2hCLElBQUksT0FBT0EsT0FBTyxVQUFVLE9BQU9BO0lBRW5DLE9BQU9BLEdBQUdELE1BQU07QUFDbEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRSxPQUFPLEdBQUdDLElBQUk7SUFDckIsTUFBTUMsU0FBU0QsS0FBS0UsR0FBRyxDQUFDLENBQUNDLElBQU1OLE9BQU9NLElBQUlDLElBQUksQ0FBQztJQUMvQyxPQUFPSDtBQUNUO0FBRUE7Ozs7OztBQU1BLEdBRUEscUJBQXFCLEdBQ3JCLFNBQVNJLEtBQUtDLElBQUk7SUFDaEIsTUFBTUMsTUFBTSxDQUFDO0lBQ2IsTUFBTUMsYUFBYTtRQUNqQkMsT0FBTztRQUNQQyxLQUFJO1FBQ0pDLFVBQVU7WUFDUjtZQUNBO2dCQUNFRixPQUFPO2dCQUNQRSxVQUFVO29CQUFFSjtpQkFBSztZQUNuQixFQUFFLGlCQUFpQjtTQUNwQjtJQUNIO0lBQ0FLLE9BQU9DLE1BQU0sQ0FBQ04sS0FBSTtRQUNoQk8sV0FBVztRQUNYQyxVQUFVO1lBQ1I7Z0JBQUNOLE9BQU9WLE9BQU8sc0JBQ2Isb0VBQW9FO2dCQUNwRSwwQ0FBMEM7Z0JBQzFDLENBQUMsbUJBQW1CLENBQUM7WUFBRTtZQUN6QlM7U0FDRDtJQUNIO0lBRUEsTUFBTVEsUUFBUTtRQUNaRixXQUFXO1FBQ1hMLE9BQU87UUFBUUMsS0FBSztRQUNwQkMsVUFBVTtZQUFDTCxLQUFLVyxnQkFBZ0I7U0FBQztJQUNuQztJQUNBLE1BQU1DLFdBQVc7UUFDZlQsT0FBTztRQUNQVSxRQUFRO1lBQ05SLFVBQVU7Z0JBQ1JMLEtBQUtjLGlCQUFpQixDQUFDO29CQUNyQlgsT0FBTztvQkFDUEMsS0FBSztvQkFDTEksV0FBVztnQkFDYjthQUNEO1FBQ0g7SUFDRjtJQUNBLE1BQU1PLGVBQWU7UUFDbkJQLFdBQVc7UUFDWEwsT0FBTztRQUFLQyxLQUFLO1FBQ2pCQyxVQUFVO1lBQ1JMLEtBQUtXLGdCQUFnQjtZQUNyQlY7WUFDQVM7U0FDRDtJQUNIO0lBQ0FBLE1BQU1MLFFBQVEsQ0FBQ1csSUFBSSxDQUFDRDtJQUNwQixNQUFNRSxnQkFBZ0I7UUFDcEJULFdBQVc7UUFDWEwsT0FBTztJQUVUO0lBQ0EsTUFBTWUsY0FBYztRQUNsQlYsV0FBVztRQUNYTCxPQUFPO1FBQUtDLEtBQUs7SUFDbkI7SUFDQSxNQUFNZSxhQUFhO1FBQ2pCaEIsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLFVBQVU7WUFDUjtnQkFBRUYsT0FBTztnQkFBaUJLLFdBQVc7WUFBUztZQUM5Q1IsS0FBS29CLFdBQVc7WUFDaEJuQjtTQUNEO0lBQ0g7SUFDQSxNQUFNb0IsaUJBQWlCO1FBQ3JCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsZ0JBQWdCdEIsS0FBS3VCLE9BQU8sQ0FBQztRQUNqQ0MsUUFBUSxDQUFDLENBQUMsRUFBRUgsZUFBZXZCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QzJCLFdBQVc7SUFDYjtJQUNBLE1BQU1DLFdBQVc7UUFDZmxCLFdBQVc7UUFDWEwsT0FBTztRQUNQd0IsYUFBYTtRQUNidEIsVUFBVTtZQUFDTCxLQUFLNEIsT0FBTyxDQUFDNUIsS0FBSzZCLFVBQVUsRUFBRTtnQkFBQzFCLE9BQU87WUFBWTtTQUFHO1FBQ2hFc0IsV0FBVztJQUNiO0lBRUEsT0FBTztRQUNMSyxNQUFNO1FBQ05DLFNBQVM7WUFBQztZQUFNO1NBQU07UUFDdEJDLFVBQVU7WUFDUkMsVUFBVTtZQUNWQyxTQUNFO1lBQ0ZDLFNBQ0U7WUFDRkMsVUFDRSxrQkFBa0I7WUFDbEIsZ0ZBQWdGO1lBQ2hGLCtGQUNBLHNCQUNBLGlCQUFpQjtZQUNqQixnR0FDQSx1REFDQSxrQkFBa0I7WUFDbEIsZUFDQSxnQkFBZ0I7WUFDaEIsbUdBQ0EsZ0dBQ0EsOEZBQ0EsMkZBQ0EsZ0dBQ0E7UUFDSjtRQUNBL0IsVUFBVTtZQUNSaUI7WUFDQXRCLEtBQUt1QixPQUFPO1lBQ1pHO1lBQ0FQO1lBQ0FuQixLQUFLcUMsaUJBQWlCO1lBQ3RCekI7WUFDQUc7WUFDQUU7WUFDQUM7WUFDQWpCO1NBQ0Q7SUFDSDtBQUNGO0FBRUFxQyxPQUFPQyxPQUFPLEdBQUd4QyIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9iYXNoLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/bash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/css.js":
/*!********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/css.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*\nLanguage: CSS\nCategory: common, css\nWebsite: https://developer.mozilla.org/en-US/docs/Web/CSS\n*/ /** @type LanguageFn */ function css(hljs) {\n    var FUNCTION_LIKE = {\n        begin: /[\\w-]+\\(/,\n        returnBegin: true,\n        contains: [\n            {\n                className: \"built_in\",\n                begin: /[\\w-]+/\n            },\n            {\n                begin: /\\(/,\n                end: /\\)/,\n                contains: [\n                    hljs.APOS_STRING_MODE,\n                    hljs.QUOTE_STRING_MODE,\n                    hljs.CSS_NUMBER_MODE\n                ]\n            }\n        ]\n    };\n    var ATTRIBUTE = {\n        className: \"attribute\",\n        begin: /\\S/,\n        end: \":\",\n        excludeEnd: true,\n        starts: {\n            endsWithParent: true,\n            excludeEnd: true,\n            contains: [\n                FUNCTION_LIKE,\n                hljs.CSS_NUMBER_MODE,\n                hljs.QUOTE_STRING_MODE,\n                hljs.APOS_STRING_MODE,\n                hljs.C_BLOCK_COMMENT_MODE,\n                {\n                    className: \"number\",\n                    begin: \"#[0-9A-Fa-f]+\"\n                },\n                {\n                    className: \"meta\",\n                    begin: \"!important\"\n                }\n            ]\n        }\n    };\n    var AT_IDENTIFIER = \"@[a-z-]+\"; // @font-face\n    var AT_MODIFIERS = \"and or not only\";\n    var AT_PROPERTY_RE = /@-?\\w[\\w]*(-\\w+)*/; // @-webkit-keyframes\n    var IDENT_RE = \"[a-zA-Z-][a-zA-Z0-9_-]*\";\n    var RULE = {\n        begin: /([*]\\s?)?(?:[A-Z_.\\-\\\\]+|--[a-zA-Z0-9_-]+)\\s*(\\/\\*\\*\\/)?:/,\n        returnBegin: true,\n        end: \";\",\n        endsWithParent: true,\n        contains: [\n            ATTRIBUTE\n        ]\n    };\n    return {\n        name: \"CSS\",\n        case_insensitive: true,\n        illegal: /[=|'\\$]/,\n        contains: [\n            hljs.C_BLOCK_COMMENT_MODE,\n            {\n                className: \"selector-id\",\n                begin: /#[A-Za-z0-9_-]+/\n            },\n            {\n                className: \"selector-class\",\n                begin: \"\\\\.\" + IDENT_RE\n            },\n            {\n                className: \"selector-attr\",\n                begin: /\\[/,\n                end: /\\]/,\n                illegal: \"$\",\n                contains: [\n                    hljs.APOS_STRING_MODE,\n                    hljs.QUOTE_STRING_MODE\n                ]\n            },\n            {\n                className: \"selector-pseudo\",\n                begin: /:(:)?[a-zA-Z0-9_+()\"'.-]+/\n            },\n            // matching these here allows us to treat them more like regular CSS\n            // rules so everything between the {} gets regular rule highlighting,\n            // which is what we want for page and font-face\n            {\n                begin: \"@(page|font-face)\",\n                lexemes: AT_IDENTIFIER,\n                keywords: \"@page @font-face\"\n            },\n            {\n                begin: \"@\",\n                end: \"[{;]\",\n                // because it doesn’t let it to be parsed as\n                // a rule set but instead drops parser into\n                // the default mode which is how it should be.\n                illegal: /:/,\n                returnBegin: true,\n                contains: [\n                    {\n                        className: \"keyword\",\n                        begin: AT_PROPERTY_RE\n                    },\n                    {\n                        begin: /\\s/,\n                        endsWithParent: true,\n                        excludeEnd: true,\n                        relevance: 0,\n                        keywords: AT_MODIFIERS,\n                        contains: [\n                            {\n                                begin: /[a-z-]+:/,\n                                className: \"attribute\"\n                            },\n                            hljs.APOS_STRING_MODE,\n                            hljs.QUOTE_STRING_MODE,\n                            hljs.CSS_NUMBER_MODE\n                        ]\n                    }\n                ]\n            },\n            {\n                className: \"selector-tag\",\n                begin: IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /\\{/,\n                end: /\\}/,\n                illegal: /\\S/,\n                contains: [\n                    hljs.C_BLOCK_COMMENT_MODE,\n                    {\n                        begin: /;/\n                    },\n                    RULE\n                ]\n            }\n        ]\n    };\n}\nmodule.exports = css;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2Nzcy5qcz8wZDFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5MYW5ndWFnZTogQ1NTXG5DYXRlZ29yeTogY29tbW9uLCBjc3NcbldlYnNpdGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTU1xuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGNzcyhobGpzKSB7XG4gIHZhciBGVU5DVElPTl9MSUtFID0ge1xuICAgIGJlZ2luOiAvW1xcdy1dK1xcKC8sIHJldHVybkJlZ2luOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2J1aWx0X2luJyxcbiAgICAgICAgYmVnaW46IC9bXFx3LV0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgICAgIGhsanMuQ1NTX05VTUJFUl9NT0RFLFxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICB2YXIgQVRUUklCVVRFID0ge1xuICAgIGNsYXNzTmFtZTogJ2F0dHJpYnV0ZScsXG4gICAgYmVnaW46IC9cXFMvLCBlbmQ6ICc6JywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgRlVOQ1RJT05fTElLRSxcbiAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREUsXG4gICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ251bWJlcicsIGJlZ2luOiAnI1swLTlBLUZhLWZdKydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLCBiZWdpbjogJyFpbXBvcnRhbnQnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH07XG4gIHZhciBBVF9JREVOVElGSUVSID0gJ0BbYS16LV0rJzsgLy8gQGZvbnQtZmFjZVxuICB2YXIgQVRfTU9ESUZJRVJTID0gXCJhbmQgb3Igbm90IG9ubHlcIjtcbiAgdmFyIEFUX1BST1BFUlRZX1JFID0gL0AtP1xcd1tcXHddKigtXFx3KykqLzsgLy8gQC13ZWJraXQta2V5ZnJhbWVzXG4gIHZhciBJREVOVF9SRSA9ICdbYS16QS1aLV1bYS16QS1aMC05Xy1dKic7XG4gIHZhciBSVUxFID0ge1xuICAgIGJlZ2luOiAvKFsqXVxccz8pPyg/OltBLVpfLlxcLVxcXFxdK3wtLVthLXpBLVowLTlfLV0rKVxccyooXFwvXFwqXFwqXFwvKT86LywgcmV0dXJuQmVnaW46IHRydWUsIGVuZDogJzsnLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBjb250YWluczogW1xuICAgICAgQVRUUklCVVRFXG4gICAgXVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NTUycsXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvWz18J1xcJF0vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1pZCcsIGJlZ2luOiAvI1tBLVphLXowLTlfLV0rL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItY2xhc3MnLCBiZWdpbjogJ1xcXFwuJyArIElERU5UX1JFXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgICAgYmVnaW46IC9cXFsvLCBlbmQ6IC9cXF0vLFxuICAgICAgICBpbGxlZ2FsOiAnJCcsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXBzZXVkbycsXG4gICAgICAgIGJlZ2luOiAvOig6KT9bYS16QS1aMC05XysoKVwiJy4tXSsvXG4gICAgICB9LFxuICAgICAgLy8gbWF0Y2hpbmcgdGhlc2UgaGVyZSBhbGxvd3MgdXMgdG8gdHJlYXQgdGhlbSBtb3JlIGxpa2UgcmVndWxhciBDU1NcbiAgICAgIC8vIHJ1bGVzIHNvIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUge30gZ2V0cyByZWd1bGFyIHJ1bGUgaGlnaGxpZ2h0aW5nLFxuICAgICAgLy8gd2hpY2ggaXMgd2hhdCB3ZSB3YW50IGZvciBwYWdlIGFuZCBmb250LWZhY2VcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdAKHBhZ2V8Zm9udC1mYWNlKScsXG4gICAgICAgIGxleGVtZXM6IEFUX0lERU5USUZJRVIsXG4gICAgICAgIGtleXdvcmRzOiAnQHBhZ2UgQGZvbnQtZmFjZSdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnQCcsIGVuZDogJ1t7O10nLCAvLyBhdF9ydWxlIGVhdGluZyBmaXJzdCBcIntcIiBpcyBhIGdvb2QgdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgZG9lc27igJl0IGxldCBpdCB0byBiZSBwYXJzZWQgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcnVsZSBzZXQgYnV0IGluc3RlYWQgZHJvcHMgcGFyc2VyIGludG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IG1vZGUgd2hpY2ggaXMgaG93IGl0IHNob3VsZCBiZS5cbiAgICAgICAgaWxsZWdhbDogLzovLCAvLyBicmVhayBvbiBMZXNzIHZhcmlhYmxlcyBAdmFyOiAuLi5cbiAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgICAgICAgICBiZWdpbjogQVRfUFJPUEVSVFlfUkVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvXFxzLywgZW5kc1dpdGhQYXJlbnQ6IHRydWUsIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBrZXl3b3JkczogQVRfTU9ESUZJRVJTLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiAvW2Etei1dKzovLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcImF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgaGxqcy5DU1NfTlVNQkVSX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXRhZycsIGJlZ2luOiBJREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcey8sIGVuZDogL1xcfS8sXG4gICAgICAgIGlsbGVnYWw6IC9cXFMvLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgeyBiZWdpbjogLzsvIH0sIC8vIGVtcHR5IDsgcnVsZVxuICAgICAgICAgIFJVTEUsXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzO1xuIl0sIm5hbWVzIjpbImNzcyIsImhsanMiLCJGVU5DVElPTl9MSUtFIiwiYmVnaW4iLCJyZXR1cm5CZWdpbiIsImNvbnRhaW5zIiwiY2xhc3NOYW1lIiwiZW5kIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiQ1NTX05VTUJFUl9NT0RFIiwiQVRUUklCVVRFIiwiZXhjbHVkZUVuZCIsInN0YXJ0cyIsImVuZHNXaXRoUGFyZW50IiwiQ19CTE9DS19DT01NRU5UX01PREUiLCJBVF9JREVOVElGSUVSIiwiQVRfTU9ESUZJRVJTIiwiQVRfUFJPUEVSVFlfUkUiLCJJREVOVF9SRSIsIlJVTEUiLCJuYW1lIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImlsbGVnYWwiLCJsZXhlbWVzIiwia2V5d29yZHMiLCJyZWxldmFuY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBRUEscUJBQXFCLEdBQ3JCLFNBQVNBLElBQUlDLElBQUk7SUFDZixJQUFJQyxnQkFBZ0I7UUFDbEJDLE9BQU87UUFBWUMsYUFBYTtRQUNoQ0MsVUFBVTtZQUNSO2dCQUNFQyxXQUFXO2dCQUNYSCxPQUFPO1lBQ1Q7WUFDQTtnQkFDRUEsT0FBTztnQkFBTUksS0FBSztnQkFDbEJGLFVBQVU7b0JBQ1JKLEtBQUtPLGdCQUFnQjtvQkFDckJQLEtBQUtRLGlCQUFpQjtvQkFDdEJSLEtBQUtTLGVBQWU7aUJBQ3JCO1lBQ0g7U0FDRDtJQUNIO0lBQ0EsSUFBSUMsWUFBWTtRQUNkTCxXQUFXO1FBQ1hILE9BQU87UUFBTUksS0FBSztRQUFLSyxZQUFZO1FBQ25DQyxRQUFRO1lBQ05DLGdCQUFnQjtZQUFNRixZQUFZO1lBQ2xDUCxVQUFVO2dCQUNSSDtnQkFDQUQsS0FBS1MsZUFBZTtnQkFDcEJULEtBQUtRLGlCQUFpQjtnQkFDdEJSLEtBQUtPLGdCQUFnQjtnQkFDckJQLEtBQUtjLG9CQUFvQjtnQkFDekI7b0JBQ0VULFdBQVc7b0JBQVVILE9BQU87Z0JBQzlCO2dCQUNBO29CQUNFRyxXQUFXO29CQUFRSCxPQUFPO2dCQUM1QjthQUNEO1FBQ0g7SUFDRjtJQUNBLElBQUlhLGdCQUFnQixZQUFZLGFBQWE7SUFDN0MsSUFBSUMsZUFBZTtJQUNuQixJQUFJQyxpQkFBaUIscUJBQXFCLHFCQUFxQjtJQUMvRCxJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsT0FBTztRQUNUakIsT0FBTztRQUE2REMsYUFBYTtRQUFNRyxLQUFLO1FBQUtPLGdCQUFnQjtRQUNqSFQsVUFBVTtZQUNSTTtTQUNEO0lBQ0g7SUFFQSxPQUFPO1FBQ0xVLE1BQU07UUFDTkMsa0JBQWtCO1FBQ2xCQyxTQUFTO1FBQ1RsQixVQUFVO1lBQ1JKLEtBQUtjLG9CQUFvQjtZQUN6QjtnQkFDRVQsV0FBVztnQkFBZUgsT0FBTztZQUNuQztZQUNBO2dCQUNFRyxXQUFXO2dCQUFrQkgsT0FBTyxRQUFRZ0I7WUFDOUM7WUFDQTtnQkFDRWIsV0FBVztnQkFDWEgsT0FBTztnQkFBTUksS0FBSztnQkFDbEJnQixTQUFTO2dCQUNUbEIsVUFBVTtvQkFDUkosS0FBS08sZ0JBQWdCO29CQUNyQlAsS0FBS1EsaUJBQWlCO2lCQUN2QjtZQUNIO1lBQ0E7Z0JBQ0VILFdBQVc7Z0JBQ1hILE9BQU87WUFDVDtZQUNBLG9FQUFvRTtZQUNwRSxxRUFBcUU7WUFDckUsK0NBQStDO1lBQy9DO2dCQUNFQSxPQUFPO2dCQUNQcUIsU0FBU1I7Z0JBQ1RTLFVBQVU7WUFDWjtZQUNBO2dCQUNFdEIsT0FBTztnQkFBS0ksS0FBSztnQkFDUSw0Q0FBNEM7Z0JBQzVDLDJDQUEyQztnQkFDM0MsOENBQThDO2dCQUN2RWdCLFNBQVM7Z0JBQ1RuQixhQUFhO2dCQUNiQyxVQUFVO29CQUNSO3dCQUNFQyxXQUFXO3dCQUNYSCxPQUFPZTtvQkFDVDtvQkFDQTt3QkFDRWYsT0FBTzt3QkFBTVcsZ0JBQWdCO3dCQUFNRixZQUFZO3dCQUMvQ2MsV0FBVzt3QkFDWEQsVUFBVVI7d0JBQ1ZaLFVBQVU7NEJBQ1I7Z0NBQ0VGLE9BQU87Z0NBQ1BHLFdBQVU7NEJBQ1o7NEJBQ0FMLEtBQUtPLGdCQUFnQjs0QkFDckJQLEtBQUtRLGlCQUFpQjs0QkFDdEJSLEtBQUtTLGVBQWU7eUJBQ3JCO29CQUNIO2lCQUNEO1lBQ0g7WUFDQTtnQkFDRUosV0FBVztnQkFBZ0JILE9BQU9nQjtnQkFDbENPLFdBQVc7WUFDYjtZQUNBO2dCQUNFdkIsT0FBTztnQkFBTUksS0FBSztnQkFDbEJnQixTQUFTO2dCQUNUbEIsVUFBVTtvQkFDUkosS0FBS2Msb0JBQW9CO29CQUN6Qjt3QkFBRVosT0FBTztvQkFBSTtvQkFDYmlCO2lCQUNEO1lBQ0g7U0FDRDtJQUNIO0FBQ0Y7QUFFQU8sT0FBT0MsT0FBTyxHQUFHNUIiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvY3NzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/css.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/java.js":
/*!*********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/java.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("// https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10\nvar decimalDigits = \"[0-9](_*[0-9])*\";\nvar frac = `\\\\.(${decimalDigits})`;\nvar hexDigits = \"[0-9a-fA-F](_*[0-9a-fA-F])*\";\nvar NUMERIC = {\n    className: \"number\",\n    variants: [\n        // DecimalFloatingPointLiteral\n        // including ExponentPart\n        {\n            begin: `(\\\\b(${decimalDigits})((${frac})|\\\\.)?|(${frac}))` + `[eE][+-]?(${decimalDigits})[fFdD]?\\\\b`\n        },\n        // excluding ExponentPart\n        {\n            begin: `\\\\b(${decimalDigits})((${frac})[fFdD]?\\\\b|\\\\.([fFdD]\\\\b)?)`\n        },\n        {\n            begin: `(${frac})[fFdD]?\\\\b`\n        },\n        {\n            begin: `\\\\b(${decimalDigits})[fFdD]\\\\b`\n        },\n        // HexadecimalFloatingPointLiteral\n        {\n            begin: `\\\\b0[xX]((${hexDigits})\\\\.?|(${hexDigits})?\\\\.(${hexDigits}))` + `[pP][+-]?(${decimalDigits})[fFdD]?\\\\b`\n        },\n        // DecimalIntegerLiteral\n        {\n            begin: \"\\\\b(0|[1-9](_*[0-9])*)[lL]?\\\\b\"\n        },\n        // HexIntegerLiteral\n        {\n            begin: `\\\\b0[xX](${hexDigits})[lL]?\\\\b`\n        },\n        // OctalIntegerLiteral\n        {\n            begin: \"\\\\b0(_*[0-7])*[lL]?\\\\b\"\n        },\n        // BinaryIntegerLiteral\n        {\n            begin: \"\\\\b0[bB][01](_*[01])*[lL]?\\\\b\"\n        }\n    ],\n    relevance: 0\n};\n/*\nLanguage: Java\nAuthor: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>\nCategory: common, enterprise\nWebsite: https://www.java.com/\n*/ function java(hljs) {\n    var JAVA_IDENT_RE = \"[\\xc0-ʸa-zA-Z_$][\\xc0-ʸa-zA-Z_$0-9]*\";\n    var GENERIC_IDENT_RE = JAVA_IDENT_RE + \"(<\" + JAVA_IDENT_RE + \"(\\\\s*,\\\\s*\" + JAVA_IDENT_RE + \")*>)?\";\n    var KEYWORDS = \"false synchronized int abstract float private char boolean var static null if const \" + \"for true while long strictfp finally protected import native final void \" + \"enum else break transient catch instanceof byte super volatile case assert short \" + \"package default double public try this switch continue throws protected public private \" + \"module requires exports do\";\n    var ANNOTATION = {\n        className: \"meta\",\n        begin: \"@\" + JAVA_IDENT_RE,\n        contains: [\n            {\n                begin: /\\(/,\n                end: /\\)/,\n                contains: [\n                    \"self\"\n                ] // allow nested () inside our annotation\n            }\n        ]\n    };\n    const NUMBER = NUMERIC;\n    return {\n        name: \"Java\",\n        aliases: [\n            \"jsp\"\n        ],\n        keywords: KEYWORDS,\n        illegal: /<\\/|#/,\n        contains: [\n            hljs.COMMENT(\"/\\\\*\\\\*\", \"\\\\*/\", {\n                relevance: 0,\n                contains: [\n                    {\n                        // eat up @'s in emails to prevent them to be recognized as doctags\n                        begin: /\\w+@/,\n                        relevance: 0\n                    },\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    }\n                ]\n            }),\n            // relevance boost\n            {\n                begin: /import java\\.[a-z]+\\./,\n                keywords: \"import\",\n                relevance: 2\n            },\n            hljs.C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            {\n                className: \"class\",\n                beginKeywords: \"class interface enum\",\n                end: /[{;=]/,\n                excludeEnd: true,\n                keywords: \"class interface enum\",\n                illegal: /[:\"\\[\\]]/,\n                contains: [\n                    {\n                        beginKeywords: \"extends implements\"\n                    },\n                    hljs.UNDERSCORE_TITLE_MODE\n                ]\n            },\n            {\n                // Expression keywords prevent 'keyword Name(...)' from being\n                // recognized as a function definition\n                beginKeywords: \"new throw return else\",\n                relevance: 0\n            },\n            {\n                className: \"class\",\n                begin: \"record\\\\s+\" + hljs.UNDERSCORE_IDENT_RE + \"\\\\s*\\\\(\",\n                returnBegin: true,\n                excludeEnd: true,\n                end: /[{;=]/,\n                keywords: KEYWORDS,\n                contains: [\n                    {\n                        beginKeywords: \"record\"\n                    },\n                    {\n                        begin: hljs.UNDERSCORE_IDENT_RE + \"\\\\s*\\\\(\",\n                        returnBegin: true,\n                        relevance: 0,\n                        contains: [\n                            hljs.UNDERSCORE_TITLE_MODE\n                        ]\n                    },\n                    {\n                        className: \"params\",\n                        begin: /\\(/,\n                        end: /\\)/,\n                        keywords: KEYWORDS,\n                        relevance: 0,\n                        contains: [\n                            hljs.C_BLOCK_COMMENT_MODE\n                        ]\n                    },\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            {\n                className: \"function\",\n                begin: \"(\" + GENERIC_IDENT_RE + \"\\\\s+)+\" + hljs.UNDERSCORE_IDENT_RE + \"\\\\s*\\\\(\",\n                returnBegin: true,\n                end: /[{;=]/,\n                excludeEnd: true,\n                keywords: KEYWORDS,\n                contains: [\n                    {\n                        begin: hljs.UNDERSCORE_IDENT_RE + \"\\\\s*\\\\(\",\n                        returnBegin: true,\n                        relevance: 0,\n                        contains: [\n                            hljs.UNDERSCORE_TITLE_MODE\n                        ]\n                    },\n                    {\n                        className: \"params\",\n                        begin: /\\(/,\n                        end: /\\)/,\n                        keywords: KEYWORDS,\n                        relevance: 0,\n                        contains: [\n                            ANNOTATION,\n                            hljs.APOS_STRING_MODE,\n                            hljs.QUOTE_STRING_MODE,\n                            NUMBER,\n                            hljs.C_BLOCK_COMMENT_MODE\n                        ]\n                    },\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            NUMBER,\n            ANNOTATION\n        ]\n    };\n}\nmodule.exports = java;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmEuanM/NzFmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTUvaHRtbC9qbHMtMy5odG1sI2pscy0zLjEwXG52YXIgZGVjaW1hbERpZ2l0cyA9ICdbMC05XShfKlswLTldKSonO1xudmFyIGZyYWMgPSBgXFxcXC4oJHtkZWNpbWFsRGlnaXRzfSlgO1xudmFyIGhleERpZ2l0cyA9ICdbMC05YS1mQS1GXShfKlswLTlhLWZBLUZdKSonO1xudmFyIE5VTUVSSUMgPSB7XG4gIGNsYXNzTmFtZTogJ251bWJlcicsXG4gIHZhcmlhbnRzOiBbXG4gICAgLy8gRGVjaW1hbEZsb2F0aW5nUG9pbnRMaXRlcmFsXG4gICAgLy8gaW5jbHVkaW5nIEV4cG9uZW50UGFydFxuICAgIHsgYmVnaW46IGAoXFxcXGIoJHtkZWNpbWFsRGlnaXRzfSkoKCR7ZnJhY30pfFxcXFwuKT98KCR7ZnJhY30pKWAgK1xuICAgICAgYFtlRV1bKy1dPygke2RlY2ltYWxEaWdpdHN9KVtmRmREXT9cXFxcYmAgfSxcbiAgICAvLyBleGNsdWRpbmcgRXhwb25lbnRQYXJ0XG4gICAgeyBiZWdpbjogYFxcXFxiKCR7ZGVjaW1hbERpZ2l0c30pKCgke2ZyYWN9KVtmRmREXT9cXFxcYnxcXFxcLihbZkZkRF1cXFxcYik/KWAgfSxcbiAgICB7IGJlZ2luOiBgKCR7ZnJhY30pW2ZGZERdP1xcXFxiYCB9LFxuICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxEaWdpdHN9KVtmRmREXVxcXFxiYCB9LFxuXG4gICAgLy8gSGV4YWRlY2ltYWxGbG9hdGluZ1BvaW50TGl0ZXJhbFxuICAgIHsgYmVnaW46IGBcXFxcYjBbeFhdKCgke2hleERpZ2l0c30pXFxcXC4/fCgke2hleERpZ2l0c30pP1xcXFwuKCR7aGV4RGlnaXRzfSkpYCArXG4gICAgICBgW3BQXVsrLV0/KCR7ZGVjaW1hbERpZ2l0c30pW2ZGZERdP1xcXFxiYCB9LFxuXG4gICAgLy8gRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gICAgeyBiZWdpbjogJ1xcXFxiKDB8WzEtOV0oXypbMC05XSkqKVtsTF0/XFxcXGInIH0sXG5cbiAgICAvLyBIZXhJbnRlZ2VyTGl0ZXJhbFxuICAgIHsgYmVnaW46IGBcXFxcYjBbeFhdKCR7aGV4RGlnaXRzfSlbbExdP1xcXFxiYCB9LFxuXG4gICAgLy8gT2N0YWxJbnRlZ2VyTGl0ZXJhbFxuICAgIHsgYmVnaW46ICdcXFxcYjAoXypbMC03XSkqW2xMXT9cXFxcYicgfSxcblxuICAgIC8vIEJpbmFyeUludGVnZXJMaXRlcmFsXG4gICAgeyBiZWdpbjogJ1xcXFxiMFtiQl1bMDFdKF8qWzAxXSkqW2xMXT9cXFxcYicgfSxcbiAgXSxcbiAgcmVsZXZhbmNlOiAwXG59O1xuXG4vKlxuTGFuZ3VhZ2U6IEphdmFcbkF1dGhvcjogVnNldm9sb2QgU29sb3Z5b3YgPHZzZXZvbG9kLnNvbG92eW92QGdtYWlsLmNvbT5cbkNhdGVnb3J5OiBjb21tb24sIGVudGVycHJpc2VcbldlYnNpdGU6IGh0dHBzOi8vd3d3LmphdmEuY29tL1xuKi9cblxuZnVuY3Rpb24gamF2YShobGpzKSB7XG4gIHZhciBKQVZBX0lERU5UX1JFID0gJ1tcXHUwMEMwLVxcdTAyQjhhLXpBLVpfJF1bXFx1MDBDMC1cXHUwMkI4YS16QS1aXyQwLTldKic7XG4gIHZhciBHRU5FUklDX0lERU5UX1JFID0gSkFWQV9JREVOVF9SRSArICcoPCcgKyBKQVZBX0lERU5UX1JFICsgJyhcXFxccyosXFxcXHMqJyArIEpBVkFfSURFTlRfUkUgKyAnKSo+KT8nO1xuICB2YXIgS0VZV09SRFMgPSAnZmFsc2Ugc3luY2hyb25pemVkIGludCBhYnN0cmFjdCBmbG9hdCBwcml2YXRlIGNoYXIgYm9vbGVhbiB2YXIgc3RhdGljIG51bGwgaWYgY29uc3QgJyArXG4gICAgJ2ZvciB0cnVlIHdoaWxlIGxvbmcgc3RyaWN0ZnAgZmluYWxseSBwcm90ZWN0ZWQgaW1wb3J0IG5hdGl2ZSBmaW5hbCB2b2lkICcgK1xuICAgICdlbnVtIGVsc2UgYnJlYWsgdHJhbnNpZW50IGNhdGNoIGluc3RhbmNlb2YgYnl0ZSBzdXBlciB2b2xhdGlsZSBjYXNlIGFzc2VydCBzaG9ydCAnICtcbiAgICAncGFja2FnZSBkZWZhdWx0IGRvdWJsZSBwdWJsaWMgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHRocm93cyBwcm90ZWN0ZWQgcHVibGljIHByaXZhdGUgJyArXG4gICAgJ21vZHVsZSByZXF1aXJlcyBleHBvcnRzIGRvJztcblxuICB2YXIgQU5OT1RBVElPTiA9IHtcbiAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICBiZWdpbjogJ0AnICsgSkFWQV9JREVOVF9SRSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGNvbnRhaW5zOiBbXCJzZWxmXCJdIC8vIGFsbG93IG5lc3RlZCAoKSBpbnNpZGUgb3VyIGFubm90YXRpb25cbiAgICAgIH0sXG4gICAgXVxuICB9O1xuICBjb25zdCBOVU1CRVIgPSBOVU1FUklDO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0phdmEnLFxuICAgIGFsaWFzZXM6IFsnanNwJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC88XFwvfCMvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgICcvXFxcXCpcXFxcKicsXG4gICAgICAgICdcXFxcKi8nLFxuICAgICAgICB7XG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIGVhdCB1cCBAJ3MgaW4gZW1haWxzIHRvIHByZXZlbnQgdGhlbSB0byBiZSByZWNvZ25pemVkIGFzIGRvY3RhZ3NcbiAgICAgICAgICAgICAgYmVnaW46IC9cXHcrQC8sIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZG9jdGFnJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdAW0EtWmEtel0rJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8vIHJlbGV2YW5jZSBib29zdFxuICAgICAge1xuICAgICAgICBiZWdpbjogL2ltcG9ydCBqYXZhXFwuW2Etel0rXFwuLyxcbiAgICAgICAga2V5d29yZHM6IFwiaW1wb3J0XCIsXG4gICAgICAgIHJlbGV2YW5jZTogMlxuICAgICAgfSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjbGFzcyBpbnRlcmZhY2UgZW51bScsIGVuZDogL1t7Oz1dLywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAga2V5d29yZHM6ICdjbGFzcyBpbnRlcmZhY2UgZW51bScsXG4gICAgICAgIGlsbGVnYWw6IC9bOlwiXFxbXFxdXS8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgeyBiZWdpbktleXdvcmRzOiAnZXh0ZW5kcyBpbXBsZW1lbnRzJyB9LFxuICAgICAgICAgIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIEV4cHJlc3Npb24ga2V5d29yZHMgcHJldmVudCAna2V5d29yZCBOYW1lKC4uLiknIGZyb20gYmVpbmdcbiAgICAgICAgLy8gcmVjb2duaXplZCBhcyBhIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ25ldyB0aHJvdyByZXR1cm4gZWxzZScsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgICAgICBiZWdpbjogJ3JlY29yZFxcXFxzKycgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnXFxcXHMqXFxcXCgnLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgZW5kOiAvW3s7PV0vLFxuICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgeyBiZWdpbktleXdvcmRzOiBcInJlY29yZFwiIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICdcXFxccypcXFxcKCcsXG4gICAgICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbaGxqcy5VTkRFUlNDT1JFX1RJVExFX01PREVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgYmVnaW46IC9cXCgvLCBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbjogJygnICsgR0VORVJJQ19JREVOVF9SRSArICdcXFxccyspKycgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnXFxcXHMqXFxcXCgnLCByZXR1cm5CZWdpbjogdHJ1ZSwgZW5kOiAvW3s7PV0vLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICdcXFxccypcXFxcKCcsIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtobGpzLlVOREVSU0NPUkVfVElUTEVfTU9ERV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sIGVuZDogL1xcKS8sXG4gICAgICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBBTk5PVEFUSU9OLFxuICAgICAgICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgIE5VTUJFUixcbiAgICAgICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREVcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIE5VTUJFUixcbiAgICAgIEFOTk9UQVRJT05cbiAgICBdXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gamF2YTtcbiJdLCJuYW1lcyI6WyJkZWNpbWFsRGlnaXRzIiwiZnJhYyIsImhleERpZ2l0cyIsIk5VTUVSSUMiLCJjbGFzc05hbWUiLCJ2YXJpYW50cyIsImJlZ2luIiwicmVsZXZhbmNlIiwiamF2YSIsImhsanMiLCJKQVZBX0lERU5UX1JFIiwiR0VORVJJQ19JREVOVF9SRSIsIktFWVdPUkRTIiwiQU5OT1RBVElPTiIsImNvbnRhaW5zIiwiZW5kIiwiTlVNQkVSIiwibmFtZSIsImFsaWFzZXMiLCJrZXl3b3JkcyIsImlsbGVnYWwiLCJDT01NRU5UIiwiQ19MSU5FX0NPTU1FTlRfTU9ERSIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiYmVnaW5LZXl3b3JkcyIsImV4Y2x1ZGVFbmQiLCJVTkRFUlNDT1JFX1RJVExFX01PREUiLCJVTkRFUlNDT1JFX0lERU5UX1JFIiwicmV0dXJuQmVnaW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSx5RUFBeUU7QUFDekUsSUFBSUEsZ0JBQWdCO0FBQ3BCLElBQUlDLE9BQU8sQ0FBQyxJQUFJLEVBQUVELGNBQWMsQ0FBQyxDQUFDO0FBQ2xDLElBQUlFLFlBQVk7QUFDaEIsSUFBSUMsVUFBVTtJQUNaQyxXQUFXO0lBQ1hDLFVBQVU7UUFDUiw4QkFBOEI7UUFDOUIseUJBQXlCO1FBQ3pCO1lBQUVDLE9BQU8sQ0FBQyxLQUFLLEVBQUVOLGNBQWMsR0FBRyxFQUFFQyxLQUFLLFNBQVMsRUFBRUEsS0FBSyxFQUFFLENBQUMsR0FDMUQsQ0FBQyxVQUFVLEVBQUVELGNBQWMsV0FBVyxDQUFDO1FBQUM7UUFDMUMseUJBQXlCO1FBQ3pCO1lBQUVNLE9BQU8sQ0FBQyxJQUFJLEVBQUVOLGNBQWMsR0FBRyxFQUFFQyxLQUFL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QkFBbUIsV0FBV0YsS0FBS29CLG1CQUFtQixHQUFHO2dCQUFXQyxhQUFhO2dCQUFNZixLQUFLO2dCQUN6R1ksWUFBWTtnQkFDWlIsVUFBVVA7Z0JBQ1ZFLFVBQVU7b0JBQ1I7d0JBQ0VSLE9BQU9HLEtBQUtvQixtQkFBbUIsR0FBRzt3QkFBV0MsYUFBYTt3QkFDMUR2QixXQUFXO3dCQUNYTyxVQUFVOzRCQUFDTCxLQUFLbUIscUJBQXFCO3lCQUFDO29CQUN4QztvQkFDQTt3QkFDRXhCLFdBQVc7d0JBQ1hFLE9BQU87d0JBQU1TLEtBQUs7d0JBQ2xCSSxVQUFVUDt3QkFDVkwsV0FBVzt3QkFDWE8sVUFBVTs0QkFDUkQ7NEJBQ0FKLEtBQUtlLGdCQUFnQjs0QkFDckJmLEtBQUtnQixpQkFBaUI7NEJBQ3RCVDs0QkFDQVAsS0FBS2Msb0JBQW9CO3lCQUMxQjtvQkFDSDtvQkFDQWQsS0FBS2EsbUJBQW1CO29CQUN4QmIsS0FBS2Msb0JBQW9CO2lCQUMxQjtZQUNIO1lBQ0FQO1lBQ0FIO1NBQ0Q7SUFDSDtBQUNGO0FBRUFrQixPQUFPQyxPQUFPLEdBQUd4QiIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/java.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/javascript.js":
/*!***************************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/javascript.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    // JS handles these with a special rule\n    // \"get\",\n    // \"set\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n];\nconst LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n    \"NaN\",\n    \"Infinity\"\n];\nconst TYPES = [\n    \"Intl\",\n    \"DataView\",\n    \"Number\",\n    \"Math\",\n    \"Date\",\n    \"String\",\n    \"RegExp\",\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Error\",\n    \"Symbol\",\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    \"Proxy\",\n    \"Reflect\",\n    \"JSON\",\n    \"Promise\",\n    \"Float64Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Int8Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"Float32Array\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"ArrayBuffer\"\n];\nconst ERROR_TYPES = [\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n];\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n];\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\" // Node.js\n];\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, TYPES, ERROR_TYPES);\n/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function lookahead(re) {\n    return concat(\"(?=\", re, \")\");\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/ /** @type LanguageFn */ function javascript(hljs) {\n    /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */ const hasClosingTag = (match, { after })=>{\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */ isTrulyOpeningTag: (match, response)=>{\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            // nested type?\n            // HTML should not include another raw `<` inside a tag\n            // But a type might: `<Array<Array<number>>`, etc.\n            if (nextChar === \"<\") {\n                response.ignoreMatch();\n                return;\n            }\n            // <something>\n            // This is now either a tag or a type.\n            if (nextChar === \">\") {\n                // if we cannot find a matching closing tag, then we\n                // will ignore it\n                if (!hasClosingTag(match, {\n                    after: afterMatchIndex\n                })) {\n                    response.ignoreMatch();\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS.join(\" \"),\n        literal: LITERALS.join(\" \"),\n        built_in: BUILT_INS.join(\" \")\n    };\n    // https://tc39.es/ecma262/#sec-literals-numeric-literals\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            // DecimalLiteral\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` + `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            {\n                begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b`\n            },\n            // DecimalBigIntegerLiteral\n            {\n                begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b`\n            },\n            // NonDecimalIntegerLiteral\n            {\n                begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\"\n            },\n            // LegacyOctalIntegerLiteral (does not include underscore separators)\n            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n            {\n                begin: \"\\\\b0[0-7]+n?\\\\b\"\n            }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: [] // defined later\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"css\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n        ]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                className: \"doctag\",\n                begin: \"@[A-Za-z]+\",\n                contains: [\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    // eat spaces (not newlines) so we can find\n                    // types or variables\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER,\n        hljs.REGEXP_MODE\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        // we need to pair up {} inside our subst to prevent\n        // it from ending too early by matching another }\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\n            \"self\"\n        ].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        // eat recursive parens in sub expressions\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\n                \"self\"\n            ].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    return {\n        name: \"Javascript\",\n        aliases: [\n            \"js\",\n            \"jsx\",\n            \"mjs\",\n            \"cjs\"\n        ],\n        keywords: KEYWORDS$1,\n        // this will be extended by TypeScript\n        exports: {\n            PARAMS_CONTAINS\n        },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            {\n                label: \"use_strict\",\n                className: \"meta\",\n                relevance: 10,\n                begin: /^\\s*['\"]use (strict|asm)['\"]/\n            },\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            NUMBER,\n            {\n                begin: concat(/[{,\\n]\\s*/, // we need to look ahead to make sure that we actually have an\n                // attribute coming up so we don't steal a comma from a potential\n                // \"value\" container\n                //\n                // NOTE: this might not work how you think.  We don't actually always\n                // enter this mode and stay.  Instead it might merely match `,\n                // <comments up next>` and then immediately end after the , because it\n                // fails to find any actual attrs. But this still does the job because\n                // it prevents the value contain rule from grabbing this instead and\n                // prevening this rule from firing when we actually DO have keys.\n                lookahead(concat(// we also need to allow for multiple possible comments inbetween\n                // the first key:value pairing\n                /(((\\/\\/.*$)|(\\/\\*(\\*[^/]|[^*])*\\*\\/))\\s*)*/, IDENT_RE$1 + \"\\\\s*:\"))),\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"attr\",\n                        begin: IDENT_RE$1 + lookahead(\"\\\\s*:\"),\n                        relevance: 0\n                    }\n                ]\n            },\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        // we have to count the parens to make sure we actually have the\n                        // correct bounding ( ) before the =>.  There could be any number of\n                        // sub-expressions inside also surrounded by parens.\n                        begin: \"(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)|\" + hljs.UNDERSCORE_IDENT_RE + \")\\\\s*=>\",\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        className: \"\",\n                        begin: /\\s/,\n                        end: /\\s*/,\n                        skip: true\n                    },\n                    {\n                        variants: [\n                            {\n                                begin: FRAGMENT.begin,\n                                end: FRAGMENT.end\n                            },\n                            {\n                                begin: XML_TAG.begin,\n                                // we carefully check the opening tag to see if it truly\n                                // is a tag and not a false positive\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\n                                    \"self\"\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                relevance: 0\n            },\n            {\n                className: \"function\",\n                beginKeywords: \"function\",\n                end: /[{;]/,\n                excludeEnd: true,\n                keywords: KEYWORDS$1,\n                contains: [\n                    \"self\",\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    PARAMS\n                ],\n                illegal: /%/\n            },\n            {\n                // prevent this from getting swallowed up by function\n                // since they appear \"function like\"\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                className: \"function\",\n                // we have to count the parens to make sure we actually have the correct\n                // bounding ( ).  There could be any number of sub-expressions inside\n                // also surrounded by parens.\n                begin: hljs.UNDERSCORE_IDENT_RE + \"\\\\(\" + // first parens\n                \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    })\n                ]\n            },\n            // hack: prevents detection of keywords in some circumstances\n            // .keyword()\n            // $keyword = x\n            {\n                variants: [\n                    {\n                        begin: \"\\\\.\" + IDENT_RE$1\n                    },\n                    {\n                        begin: \"\\\\$\" + IDENT_RE$1\n                    }\n                ],\n                relevance: 0\n            },\n            {\n                className: \"class\",\n                beginKeywords: \"class\",\n                end: /[{;=]/,\n                excludeEnd: true,\n                illegal: /[:\"[\\]]/,\n                contains: [\n                    {\n                        beginKeywords: \"extends\"\n                    },\n                    hljs.UNDERSCORE_TITLE_MODE\n                ]\n            },\n            {\n                begin: /\\b(?=constructor)/,\n                end: /[{;]/,\n                excludeEnd: true,\n                contains: [\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    \"self\",\n                    PARAMS\n                ]\n            },\n            {\n                begin: \"(get|set)\\\\s+(?=\" + IDENT_RE$1 + \"\\\\()\",\n                end: /\\{/,\n                keywords: \"get set\",\n                contains: [\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    {\n                        begin: /\\(\\)/\n                    },\n                    PARAMS\n                ]\n            },\n            {\n                begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n            }\n        ]\n    };\n}\nmodule.exports = javascript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanM/ZjNlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuY29uc3QgS0VZV09SRFMgPSBbXG4gIFwiYXNcIiwgLy8gZm9yIGV4cG9ydHNcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiaWZcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImZpbmFsbHlcIixcbiAgXCJ2YXJcIixcbiAgXCJuZXdcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcImRvXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwidm9pZFwiLFxuICBcImVsc2VcIixcbiAgXCJicmVha1wiLFxuICBcImNhdGNoXCIsXG4gIFwiaW5zdGFuY2VvZlwiLFxuICBcIndpdGhcIixcbiAgXCJ0aHJvd1wiLFxuICBcImNhc2VcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwidHJ5XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwiY29udGludWVcIixcbiAgXCJ0eXBlb2ZcIixcbiAgXCJkZWxldGVcIixcbiAgXCJsZXRcIixcbiAgXCJ5aWVsZFwiLFxuICBcImNvbnN0XCIsXG4gIFwiY2xhc3NcIixcbiAgLy8gSlMgaGFuZGxlcyB0aGVzZSB3aXRoIGEgc3BlY2lhbCBydWxlXG4gIC8vIFwiZ2V0XCIsXG4gIC8vIFwic2V0XCIsXG4gIFwiZGVidWdnZXJcIixcbiAgXCJhc3luY1wiLFxuICBcImF3YWl0XCIsXG4gIFwic3RhdGljXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwiZnJvbVwiLFxuICBcImV4cG9ydFwiLFxuICBcImV4dGVuZHNcIlxuXTtcbmNvbnN0IExJVEVSQUxTID0gW1xuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJOYU5cIixcbiAgXCJJbmZpbml0eVwiXG5dO1xuXG5jb25zdCBUWVBFUyA9IFtcbiAgXCJJbnRsXCIsXG4gIFwiRGF0YVZpZXdcIixcbiAgXCJOdW1iZXJcIixcbiAgXCJNYXRoXCIsXG4gIFwiRGF0ZVwiLFxuICBcIlN0cmluZ1wiLFxuICBcIlJlZ0V4cFwiLFxuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIkVycm9yXCIsXG4gIFwiU3ltYm9sXCIsXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJQcm94eVwiLFxuICBcIlJlZmxlY3RcIixcbiAgXCJKU09OXCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIkZsb2F0NjRBcnJheVwiLFxuICBcIkludDE2QXJyYXlcIixcbiAgXCJJbnQzMkFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDE2QXJyYXlcIixcbiAgXCJVaW50MzJBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLFxuICBcIkFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiQXJyYXlCdWZmZXJcIlxuXTtcblxuY29uc3QgRVJST1JfVFlQRVMgPSBbXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBCVUlMVF9JTl9WQVJJQUJMRVMsXG4gIFRZUEVTLFxuICBFUlJPUl9UWVBFU1xuKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKlxuTGFuZ3VhZ2U6IEphdmFTY3JpcHRcbkRlc2NyaXB0aW9uOiBKYXZhU2NyaXB0IChKUykgaXMgYSBsaWdodHdlaWdodCwgaW50ZXJwcmV0ZWQsIG9yIGp1c3QtaW4tdGltZSBjb21waWxlZCBwcm9ncmFtbWluZyBsYW5ndWFnZSB3aXRoIGZpcnN0LWNsYXNzIGZ1bmN0aW9ucy5cbkNhdGVnb3J5OiBjb21tb24sIHNjcmlwdGluZ1xuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdFxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmFzY3JpcHQoaGxqcykge1xuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgbGlrZSBcIjxCb29nZXJcIiBhbmQgY2hlY2tzIHRvIHNlZVxuICAgKiBpZiB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIFwiPC9Cb29nZXJcIiBsYXRlciBpbiB0aGVcbiAgICogY29udGVudC5cbiAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgKiBAcGFyYW0ge3thZnRlcjpudW1iZXJ9fSBwYXJhbTFcbiAgICovXG4gIGNvbnN0IGhhc0Nsb3NpbmdUYWcgPSAobWF0Y2gsIHsgYWZ0ZXIgfSkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFwiPC9cIiArIG1hdGNoWzBdLnNsaWNlKDEpO1xuICAgIGNvbnN0IHBvcyA9IG1hdGNoLmlucHV0LmluZGV4T2YodGFnLCBhZnRlcik7XG4gICAgcmV0dXJuIHBvcyAhPT0gLTE7XG4gIH07XG5cbiAgY29uc3QgSURFTlRfUkUkMSA9IElERU5UX1JFO1xuICBjb25zdCBGUkFHTUVOVCA9IHtcbiAgICBiZWdpbjogJzw+JyxcbiAgICBlbmQ6ICc8Lz4nXG4gIH07XG4gIGNvbnN0IFhNTF9UQUcgPSB7XG4gICAgYmVnaW46IC88W0EtWmEtejAtOVxcXFwuXzotXSsvLFxuICAgIGVuZDogL1xcL1tBLVphLXowLTlcXFxcLl86LV0rPnxcXC8+LyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIGlzVHJ1bHlPcGVuaW5nVGFnOiAobWF0Y2gsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1hdGNoSW5kZXggPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2guaW5wdXRbYWZ0ZXJNYXRjaEluZGV4XTtcbiAgICAgIC8vIG5lc3RlZCB0eXBlP1xuICAgICAgLy8gSFRNTCBzaG91bGQgbm90IGluY2x1ZGUgYW5vdGhlciByYXcgYDxgIGluc2lkZSBhIHRhZ1xuICAgICAgLy8gQnV0IGEgdHlwZSBtaWdodDogYDxBcnJheTxBcnJheTxudW1iZXI+PmAsIGV0Yy5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gPHNvbWV0aGluZz5cbiAgICAgIC8vIFRoaXMgaXMgbm93IGVpdGhlciBhIHRhZyBvciBhIHR5cGUuXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBLRVlXT1JEUyQxID0ge1xuICAgICRwYXR0ZXJuOiBJREVOVF9SRSxcbiAgICBrZXl3b3JkOiBLRVlXT1JEUy5qb2luKFwiIFwiKSxcbiAgICBsaXRlcmFsOiBMSVRFUkFMUy5qb2luKFwiIFwiKSxcbiAgICBidWlsdF9pbjogQlVJTFRfSU5TLmpvaW4oXCIgXCIpXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxEaWdpdHMgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgZnJhYyA9IGBcXFxcLigke2RlY2ltYWxEaWdpdHN9KWA7XG4gIC8vIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCwgaW5jbHVkaW5nIEFubmV4IEIgTm9uT2N0YWxEZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxJbnRlZ2VyID0gYDB8WzEtOV0oXz9bMC05XSkqfDBbMC03XSpbODldWzAtOV0qYDtcbiAgY29uc3QgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIERlY2ltYWxMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgKFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KSgoJHtmcmFjfSl8XFxcXC4pP3woJHtmcmFjfSkpYCArXG4gICAgICAgIGBbZUVdWystXT8oJHtkZWNpbWFsRGlnaXRzfSlcXFxcYmAgfSxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSlcXFxcYigoJHtmcmFjfSlcXFxcYnxcXFxcLik/fCgke2ZyYWN9KVxcXFxiYCB9LFxuXG4gICAgICAvLyBEZWNpbWFsQmlnSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigwfFsxLTldKF8/WzAtOV0pKiluXFxcXGJgIH0sXG5cbiAgICAgIC8vIE5vbkRlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbeFhdWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtiQl1bMC0xXShfP1swLTFdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW29PXVswLTddKF8/WzAtN10pKm4/XFxcXGJcIiB9LFxuXG4gICAgICAvLyBMZWdhY3lPY3RhbEludGVnZXJMaXRlcmFsIChkb2VzIG5vdCBpbmNsdWRlIHVuZGVyc2NvcmUgc2VwYXJhdG9ycylcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbMC03XStuP1xcXFxiXCIgfSxcbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IFNVQlNUID0ge1xuICAgIGNsYXNzTmFtZTogJ3N1YnN0JyxcbiAgICBiZWdpbjogJ1xcXFwkXFxcXHsnLFxuICAgIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICBjb250YWluczogW10gLy8gZGVmaW5lZCBsYXRlclxuICB9O1xuICBjb25zdCBIVE1MX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnaHRtbGAnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnXG4gICAgfVxuICB9O1xuICBjb25zdCBDU1NfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdjc3NgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAnY3NzJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgVEVNUExBVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdgJyxcbiAgICBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIGNvbnN0IEpTRE9DX0NPTU1FTlQgPSBobGpzLkNPTU1FTlQoXG4gICAgL1xcL1xcKlxcKig/IVxcLykvLFxuICAgICdcXFxcKi8nLFxuICAgIHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgICAgIGJlZ2luOiAnQFtBLVphLXpdKycsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgIGJlZ2luOiAnXFxcXHsnLFxuICAgICAgICAgICAgICBlbmQ6ICdcXFxcfScsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArICcoPz1cXFxccyooLSl8JCknLFxuICAgICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlYXQgc3BhY2VzIChub3QgbmV3bGluZXMpIHNvIHdlIGNhbiBmaW5kXG4gICAgICAgICAgICAvLyB0eXBlcyBvciB2YXJpYWJsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC8oPz1bXlxcbl0pXFxzLyxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICApO1xuICBjb25zdCBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb21tZW50XCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIEpTRE9DX0NPTU1FTlQsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xuICBjb25zdCBTVUJTVF9JTlRFUk5BTFMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgSFRNTF9URU1QTEFURSxcbiAgICBDU1NfVEVNUExBVEUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF07XG4gIFNVQlNULmNvbnRhaW5zID0gU1VCU1RfSU5URVJOQUxTXG4gICAgLmNvbmNhdCh7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHBhaXIgdXAge30gaW5zaWRlIG91ciBzdWJzdCB0byBwcmV2ZW50XG4gICAgICAvLyBpdCBmcm9tIGVuZGluZyB0b28gZWFybHkgYnkgbWF0Y2hpbmcgYW5vdGhlciB9XG4gICAgICBiZWdpbjogL1xcey8sXG4gICAgICBlbmQ6IC9cXH0vLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBcInNlbGZcIlxuICAgICAgXS5jb25jYXQoU1VCU1RfSU5URVJOQUxTKVxuICAgIH0pO1xuICBjb25zdCBTVUJTVF9BTkRfQ09NTUVOVFMgPSBbXS5jb25jYXQoQ09NTUVOVCwgU1VCU1QuY29udGFpbnMpO1xuICBjb25zdCBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVF9BTkRfQ09NTUVOVFMuY29uY2F0KFtcbiAgICAvLyBlYXQgcmVjdXJzaXZlIHBhcmVucyBpbiBzdWIgZXhwcmVzc2lvbnNcbiAgICB7XG4gICAgICBiZWdpbjogL1xcKC8sXG4gICAgICBlbmQ6IC9cXCkvLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1wic2VsZlwiXS5jb25jYXQoU1VCU1RfQU5EX0NPTU1FTlRTKVxuICAgIH1cbiAgXSk7XG4gIGNvbnN0IFBBUkFNUyA9IHtcbiAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdKYXZhc2NyaXB0JyxcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCcsICdtanMnLCAnY2pzJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGV4dGVuZGVkIGJ5IFR5cGVTY3JpcHRcbiAgICBleHBvcnRzOiB7IFBBUkFNU19DT05UQUlOUyB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiBcInVzZV9zdHJpY3RcIixcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgSFRNTF9URU1QTEFURSxcbiAgICAgIENTU19URU1QTEFURSxcbiAgICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICAgIENPTU1FTlQsXG4gICAgICBOVU1CRVIsXG4gICAgICB7IC8vIG9iamVjdCBhdHRyIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogY29uY2F0KC9beyxcXG5dXFxzKi8sXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBsb29rIGFoZWFkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGFjdHVhbGx5IGhhdmUgYW5cbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgY29taW5nIHVwIHNvIHdlIGRvbid0IHN0ZWFsIGEgY29tbWEgZnJvbSBhIHBvdGVudGlhbFxuICAgICAgICAgIC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5PVEU6IHRoaXMgbWlnaHQgbm90IHdvcmsgaG93IHlvdSB0aGluay4gIFdlIGRvbid0IGFjdHVhbGx5IGFsd2F5c1xuICAgICAgICAgIC8vIGVudGVyIHRoaXMgbW9kZSBhbmQgc3RheS4gIEluc3RlYWQgaXQgbWlnaHQgbWVyZWx5IG1hdGNoIGAsXG4gICAgICAgICAgLy8gPGNvbW1lbnRzIHVwIG5leHQ+YCBhbmQgdGhlbiBpbW1lZGlhdGVseSBlbmQgYWZ0ZXIgdGhlICwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGZhaWxzIHRvIGZpbmQgYW55IGFjdHVhbCBhdHRycy4gQnV0IHRoaXMgc3RpbGwgZG9lcyB0aGUgam9iIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBwcmV2ZW50cyB0aGUgdmFsdWUgY29udGFpbiBydWxlIGZyb20gZ3JhYmJpbmcgdGhpcyBpbnN0ZWFkIGFuZFxuICAgICAgICAgIC8vIHByZXZlbmluZyB0aGlzIHJ1bGUgZnJvbSBmaXJpbmcgd2hlbiB3ZSBhY3R1YWxseSBETyBoYXZlIGtleXMuXG4gICAgICAgICAgbG9va2FoZWFkKGNvbmNhdChcbiAgICAgICAgICAgIC8vIHdlIGFsc28gbmVlZCB0byBhbGxvdyBmb3IgbXVsdGlwbGUgcG9zc2libGUgY29tbWVudHMgaW5iZXR3ZWVuXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3Qga2V5OnZhbHVlIHBhaXJpbmdcbiAgICAgICAgICAgIC8oKChcXC9cXC8uKiQpfChcXC9cXCooXFwqW14vXXxbXipdKSpcXCpcXC8pKVxccyopKi8sXG4gICAgICAgICAgICBJREVOVF9SRSQxICsgJ1xcXFxzKjonKSkpLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYXR0cicsXG4gICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArIGxvb2thaGVhZCgnXFxcXHMqOicpLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBDT01NRU5ULFxuICAgICAgICAgIGhsanMuUkVHRVhQX01PREUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjb3VudCB0aGUgcGFyZW5zIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCBib3VuZGluZyAoICkgYmVmb3JlIHRoZSA9Pi4gIFRoZXJlIGNvdWxkIGJlIGFueSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHN1Yi1leHByZXNzaW9ucyBpbnNpZGUgYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgICAgIGJlZ2luOiAnKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qJyArXG4gICAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAgICdcXFxcKXwnICsgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFICsgJylcXFxccyo9PicsXG4gICAgICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZDogJ1xcXFxzKj0+JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgICBza2lwOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gY291bGQgYmUgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXJhbXMgdG8gYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICBiZWdpbjogLywvLCByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgICBiZWdpbjogL1xccy8sXG4gICAgICAgICAgICBlbmQ6IC9cXHMqLyxcbiAgICAgICAgICAgIHNraXA6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gSlNYXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7IGJlZ2luOiBGUkFHTUVOVC5iZWdpbiwgZW5kOiBGUkFHTUVOVC5lbmQgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiBYTUxfVEFHLmJlZ2luLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhcmVmdWxseSBjaGVjayB0aGUgb3BlbmluZyB0YWcgdG8gc2VlIGlmIGl0IHRydWx5XG4gICAgICAgICAgICAgICAgLy8gaXMgYSB0YWcgYW5kIG5vdCBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgJ29uOmJlZ2luJzogWE1MX1RBRy5pc1RydWx5T3BlbmluZ1RhZyxcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgZW5kOiBYTUxfVEFHLmVuZCxcbiAgICAgICAgICAgICAgICBza2lwOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZW5kOiAvW3s7XS8sXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICdzZWxmJyxcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7IGJlZ2luOiBJREVOVF9SRSQxIH0pLFxuICAgICAgICAgIFBBUkFNU1xuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvJS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhpcyBmcm9tIGdldHRpbmcgc3dhbGxvd2VkIHVwIGJ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgYXBwZWFyIFwiZnVuY3Rpb24gbGlrZVwiXG4gICAgICAgIGJlZ2luS2V5d29yZHM6IFwid2hpbGUgaWYgc3dpdGNoIGNhdGNoIGZvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAvLyBib3VuZGluZyAoICkuICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mIHN1Yi1leHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgLy8gYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArXG4gICAgICAgICAgJ1xcXFwoJyArIC8vIGZpcnN0IHBhcmVuc1xuICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICAgJ1teKCldKicgK1xuICAgICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICdcXFxcKVxcXFxzKlxcXFx7JywgLy8gZW5kIHBhcmVuc1xuICAgICAgICByZXR1cm5CZWdpbjp0cnVlLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFBBUkFNUyxcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7IGJlZ2luOiBJREVOVF9SRSQxIH0pLFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gaGFjazogcHJldmVudHMgZGV0ZWN0aW9uIG9mIGtleXdvcmRzIGluIHNvbWUgY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gLmtleXdvcmQoKVxuICAgICAgLy8gJGtleXdvcmQgPSB4XG4gICAgICB7XG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgeyBiZWdpbjogJ1xcXFwuJyArIElERU5UX1JFJDEgfSxcbiAgICAgICAgICB7IGJlZ2luOiAnXFxcXCQnICsgSURFTlRfUkUkMSB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHsgLy8gRVM2IGNsYXNzXG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2NsYXNzJyxcbiAgICAgICAgZW5kOiAvW3s7PV0vLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBpbGxlZ2FsOiAvWzpcIltcXF1dLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7IGJlZ2luS2V5d29yZHM6ICdleHRlbmRzJyB9LFxuICAgICAgICAgIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxiKD89Y29uc3RydWN0b3IpLyxcbiAgICAgICAgZW5kOiAvW3s7XS8sXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwgeyBiZWdpbjogSURFTlRfUkUkMSB9KSxcbiAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgUEFSQU1TXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnKGdldHxzZXQpXFxcXHMrKD89JyArIElERU5UX1JFJDEgKyAnXFxcXCgpJyxcbiAgICAgICAgZW5kOiAvXFx7LyxcbiAgICAgICAga2V5d29yZHM6IFwiZ2V0IHNldFwiLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHsgYmVnaW46IElERU5UX1JFJDEgfSksXG4gICAgICAgICAgeyBiZWdpbjogL1xcKFxcKS8gfSwgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICAgIFBBUkFNU1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGphdmFzY3JpcHQ7XG4iXSwibmFtZXMiOlsiSURFTlRfUkUiLCJLRVlXT1JEUyIsIkxJVEVSQUxTIiwiVFlQRVMiLCJFUlJPUl9UWVBFUyIsIkJVSUxUX0lOX0dMT0JBTFMiLCJCVUlMVF9JTl9WQVJJQUJMRVMiLCJCVUlMVF9JTlMiLCJjb25jYXQiLCJzb3VyY2UiLCJyZSIsImxvb2thaGVhZCIsImFyZ3MiLCJqb2luZWQiLCJtYXAiLCJ4Iiwiam9pbiIsImphdmFzY3JpcHQiLCJobGpzIiwiaGFzQ2xvc2luZ1RhZyIsIm1hdGNoIiwiYWZ0ZXIiLCJ0YWciLCJzbGljZSIsInBvcyIsImlucHV0IiwiaW5kZXhPZiIsIklERU5UX1JFJDEiLCJGUkFHTUVOVCIsImJlZ2luIiwiZW5kIiwiWE1MX1RBRyIsImlzVHJ1bHlPcGVuaW5nVGFnIiwicmVzcG9uc2UiLCJhZnRlck1hdGNoSW5kZXgiLCJsZW5ndGgiLCJpbmRleCIsIm5leHRDaGFyIiwiaWdub3JlTWF0Y2giLCJLRVlXT1JEUyQxIiwiJHBhdHRlcm4iLCJrZXl3b3JkIiwibGl0ZXJhbCIsImJ1aWx0X2luIiwiZGVjaW1hbERpZ2l0cyIsImZyYWMiLCJkZWNpbWFsSW50ZWdlciIsIk5VTUJFUiIsImNsYXNzTmFtZSIsInZhcmlhbnRzIiwicmVsZXZhbmNlIiwiU1VCU1QiLCJrZXl3b3JkcyIsImNvbnRhaW5zIiwiSFRNTF9URU1QTEFURSIsInN0YXJ0cyIsInJldHVybkVuZCIsIkJBQ0tTTEFTSF9FU0NBUEUiLCJzdWJMYW5ndWFnZSIsIkNTU19URU1QTEFURSIsIlRFTVBMQVRFX1NUUklORyIsIkpTRE9DX0NPTU1FTlQiLCJDT01NRU5UIiwiZW5kc1BhcmVudCIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiQ19MSU5FX0NPTU1FTlRfTU9ERSIsIlNVQlNUX0lOVEVSTkFMUyIsIkFQT1NfU1RSSU5HX01PREUiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlJFR0VYUF9NT0RFIiwiU1VCU1RfQU5EX0NPTU1FTlRTIiwiUEFSQU1TX0NPTlRBSU5TIiwiUEFSQU1TIiwiZXhjbHVkZUJlZ2luIiwiZXhjbHVkZUVuZCIsIm5hbWUiLCJhbGlhc2VzIiwiZXhwb3J0cyIsImlsbGVnYWwiLCJTSEVCQU5HIiwibGFiZWwiLCJiaW5hcnkiLCJSRV9TVEFSVEVSU19SRSIsIlVOREVSU0NPUkVfSURFTlRfUkUiLCJyZXR1cm5CZWdpbiIsInNraXAiLCJiZWdpbktleXdvcmRzIiwiaW5oZXJpdCIsIlRJVExFX01PREUiLCJVTkRFUlNDT1JFX1RJVExFX01PREUiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFdBQVc7QUFDakIsTUFBTUMsV0FBVztJQUNmO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLHVDQUF1QztJQUN2QyxTQUFTO0lBQ1QsU0FBUztJQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLFdBQVc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELE1BQU1DLFFBQVE7SUFDWjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJ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TyxDQUFDckUsS0FBS3NFLFVBQVUsRUFBRTt3QkFBRTNELE9BQU9GO29CQUFXO29CQUNsRDZDO2lCQUNEO2dCQUNETSxTQUFTO1lBQ1g7WUFDQTtnQkFDRSxxREFBcUQ7Z0JBQ3JELG9DQUFvQztnQkFDcENRLGVBQWU7WUFDakI7WUFDQTtnQkFDRXRDLFdBQVc7Z0JBQ1gsd0VBQXdFO2dCQUN4RSxxRUFBcUU7Z0JBQ3JFLDZCQUE2QjtnQkFDN0JuQixPQUFPWCxLQUFLaUUsbUJBQW1CLEdBQzdCLFFBQVEsZUFBZTtnQkFDdkIsZUFDRSxlQUNFLFdBQ0YsZ0JBQ0YsZ0JBQ0E7Z0JBQ0ZDLGFBQVk7Z0JBQ1ovQixVQUFVO29CQUNSbUI7b0JBQ0F0RCxLQUFLcUUsT0FBTyxDQUFDckUsS0FBS3NFLFVBQVUsRUFBRTt3QkFBRTNELE9BQU9GO29CQUFXO2lCQUNuRDtZQUNIO1lBQ0EsNkRBQTZEO1lBQzdELGFBQWE7WUFDYixlQUFlO1lBQ2Y7Z0JBQ0VzQixVQUFVO29CQUNSO3dCQUFFcEIsT0FBTyxRQUFRRjtvQkFBVztvQkFDNUI7d0JBQUVFLE9BQU8sUUFBUUY7b0JBQVc7aUJBQzdCO2dCQUNEdUIsV0FBVztZQUNiO1lBQ0E7Z0JBQ0VGLFdBQVc7Z0JBQ1hzQyxlQUFlO2dCQUNmeEQsS0FBSztnQkFDTDRDLFlBQVk7Z0JBQ1pJLFNBQVM7Z0JBQ1R6QixVQUFVO29CQUNSO3dCQUFFaUMsZUFBZTtvQkFBVTtvQkFDM0JwRSxLQUFLdUUscUJBQXFCO2lCQUMzQjtZQUNIO1lBQ0E7Z0JBQ0U1RCxPQUFPO2dCQUNQQyxLQUFLO2dCQUNMNEMsWUFBWTtnQkFDWnJCLFVBQVU7b0JBQ1JuQyxLQUFLcUUsT0FBTyxDQUFDckUsS0FBS3NFLFVBQVUsRUFBRTt3QkFBRTNELE9BQU9GO29CQUFXO29CQUNsRDtvQkFDQTZDO2lCQUNEO1lBQ0g7WUFDQTtnQkFDRTNDLE9BQU8scUJBQXFCRixhQUFhO2dCQUN6Q0csS0FBSztnQkFDTHNCLFVBQVU7Z0JBQ1ZDLFVBQVU7b0JBQ1JuQyxLQUFLcUUsT0FBTyxDQUFDckUsS0FBS3NFLFVBQVUsRUFBRTt3QkFBRTNELE9BQU9GO29CQUFXO29CQUNsRDt3QkFBRUUsT0FBTztvQkFBTztvQkFDaEIyQztpQkFDRDtZQUNIO1lBQ0E7Z0JBQ0UzQyxPQUFPLFNBQVMsc0ZBQXNGO1lBQ3hHO1NBQ0Q7SUFDSDtBQUNGO0FBRUE2RCxPQUFPYixPQUFPLEdBQUc1RCIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy9qYXZhc2NyaXB0LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/javascript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/json.js":
/*!*********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/json.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/*\nLanguage: JSON\nDescription: JSON (JavaScript Object Notation) is a lightweight data-interchange format.\nAuthor: Ivan Sagalaev <maniac@softwaremaniacs.org>\nWebsite: http://www.json.org\nCategory: common, protocols\n*/ function json(hljs) {\n    const LITERALS = {\n        literal: \"true false null\"\n    };\n    const ALLOWED_COMMENTS = [\n        hljs.C_LINE_COMMENT_MODE,\n        hljs.C_BLOCK_COMMENT_MODE\n    ];\n    const TYPES = [\n        hljs.QUOTE_STRING_MODE,\n        hljs.C_NUMBER_MODE\n    ];\n    const VALUE_CONTAINER = {\n        end: \",\",\n        endsWithParent: true,\n        excludeEnd: true,\n        contains: TYPES,\n        keywords: LITERALS\n    };\n    const OBJECT = {\n        begin: /\\{/,\n        end: /\\}/,\n        contains: [\n            {\n                className: \"attr\",\n                begin: /\"/,\n                end: /\"/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE\n                ],\n                illegal: \"\\\\n\"\n            },\n            hljs.inherit(VALUE_CONTAINER, {\n                begin: /:/\n            })\n        ].concat(ALLOWED_COMMENTS),\n        illegal: \"\\\\S\"\n    };\n    const ARRAY = {\n        begin: \"\\\\[\",\n        end: \"\\\\]\",\n        contains: [\n            hljs.inherit(VALUE_CONTAINER)\n        ],\n        illegal: \"\\\\S\"\n    };\n    TYPES.push(OBJECT, ARRAY);\n    ALLOWED_COMMENTS.forEach(function(rule) {\n        TYPES.push(rule);\n    });\n    return {\n        name: \"JSON\",\n        contains: TYPES,\n        keywords: LITERALS,\n        illegal: \"\\\\S\"\n    };\n}\nmodule.exports = json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2pzb24uanM/ZDY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTGFuZ3VhZ2U6IEpTT05cbkRlc2NyaXB0aW9uOiBKU09OIChKYXZhU2NyaXB0IE9iamVjdCBOb3RhdGlvbikgaXMgYSBsaWdodHdlaWdodCBkYXRhLWludGVyY2hhbmdlIGZvcm1hdC5cbkF1dGhvcjogSXZhbiBTYWdhbGFldiA8bWFuaWFjQHNvZnR3YXJlbWFuaWFjcy5vcmc+XG5XZWJzaXRlOiBodHRwOi8vd3d3Lmpzb24ub3JnXG5DYXRlZ29yeTogY29tbW9uLCBwcm90b2NvbHNcbiovXG5cbmZ1bmN0aW9uIGpzb24oaGxqcykge1xuICBjb25zdCBMSVRFUkFMUyA9IHtcbiAgICBsaXRlcmFsOiAndHJ1ZSBmYWxzZSBudWxsJ1xuICB9O1xuICBjb25zdCBBTExPV0VEX0NPTU1FTlRTID0gW1xuICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gIF07XG4gIGNvbnN0IFRZUEVTID0gW1xuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgaGxqcy5DX05VTUJFUl9NT0RFXG4gIF07XG4gIGNvbnN0IFZBTFVFX0NPTlRBSU5FUiA9IHtcbiAgICBlbmQ6ICcsJyxcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBUWVBFUyxcbiAgICBrZXl3b3JkczogTElURVJBTFNcbiAgfTtcbiAgY29uc3QgT0JKRUNUID0ge1xuICAgIGJlZ2luOiAvXFx7LyxcbiAgICBlbmQ6IC9cXH0vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogL1wiLyxcbiAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgICAgIGlsbGVnYWw6ICdcXFxcbidcbiAgICAgIH0sXG4gICAgICBobGpzLmluaGVyaXQoVkFMVUVfQ09OVEFJTkVSLCB7XG4gICAgICAgIGJlZ2luOiAvOi9cbiAgICAgIH0pXG4gICAgXS5jb25jYXQoQUxMT1dFRF9DT01NRU5UUyksXG4gICAgaWxsZWdhbDogJ1xcXFxTJ1xuICB9O1xuICBjb25zdCBBUlJBWSA9IHtcbiAgICBiZWdpbjogJ1xcXFxbJyxcbiAgICBlbmQ6ICdcXFxcXScsXG4gICAgY29udGFpbnM6IFtobGpzLmluaGVyaXQoVkFMVUVfQ09OVEFJTkVSKV0sIC8vIGluaGVyaXQgaXMgYSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyB0aGF0IG1ha2VzIHNoYXJlZCBtb2RlcyB3aXRoIGVuZHNXaXRoUGFyZW50IGNvbXBpbGUgb25seSB0aGUgZW5kaW5nIG9mIG9uZSBvZiB0aGUgcGFyZW50c1xuICAgIGlsbGVnYWw6ICdcXFxcUydcbiAgfTtcbiAgVFlQRVMucHVzaChPQkpFQ1QsIEFSUkFZKTtcbiAgQUxMT1dFRF9DT01NRU5UUy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICBUWVBFUy5wdXNoKHJ1bGUpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnSlNPTicsXG4gICAgY29udGFpbnM6IFRZUEVTLFxuICAgIGtleXdvcmRzOiBMSVRFUkFMUyxcbiAgICBpbGxlZ2FsOiAnXFxcXFMnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbjtcbiJdLCJuYW1lcyI6WyJqc29uIiwiaGxqcyIsIkxJVEVSQUxTIiwibGl0ZXJhbCIsIkFMTE9XRURfQ09NTUVOVFMiLCJDX0xJTkVfQ09NTUVOVF9NT0RFIiwiQ19CTE9DS19DT01NRU5UX01PREUiLCJUWVBFUyIsIlFVT1RFX1NUUklOR19NT0RFIiwiQ19OVU1CRVJfTU9ERSIsIlZBTFVFX0NPTlRBSU5FUiIsImVuZCIsImVuZHNXaXRoUGFyZW50IiwiZXhjbHVkZUVuZCIsImNvbnRhaW5zIiwia2V5d29yZHMiLCJPQkpFQ1QiLCJiZWdpbiIsImNsYXNzTmFtZSIsIkJBQ0tTTEFTSF9FU0NBUEUiLCJpbGxlZ2FsIiwiaW5oZXJpdCIsImNvbmNhdCIsIkFSUkFZIiwicHVzaCIsImZvckVhY2giLCJydWxlIiwibmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFNQSxHQUVBLFNBQVNBLEtBQUtDLElBQUk7SUFDaEIsTUFBTUMsV0FBVztRQUNmQyxTQUFTO0lBQ1g7SUFDQSxNQUFNQyxtQkFBbUI7UUFDdkJILEtBQUtJLG1CQUFtQjtRQUN4QkosS0FBS0ssb0JBQW9CO0tBQzFCO0lBQ0QsTUFBTUMsUUFBUTtRQUNaTixLQUFLTyxpQkFBaUI7UUFDdEJQLEtBQUtRLGFBQWE7S0FDbkI7SUFDRCxNQUFNQyxrQkFBa0I7UUFDdEJDLEtBQUs7UUFDTEMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLFVBQVVQO1FBQ1ZRLFVBQVViO0lBQ1o7SUFDQSxNQUFNYyxTQUFTO1FBQ2JDLE9BQU87UUFDUE4sS0FBSztRQUNMRyxVQUFVO1lBQ1I7Z0JBQ0VJLFdBQVc7Z0JBQ1hELE9BQU87Z0JBQ1BOLEtBQUs7Z0JBQ0xHLFVBQVU7b0JBQUNiLEtBQUtrQixnQkFBZ0I7aUJBQUM7Z0JBQ2pDQyxTQUFTO1lBQ1g7WUFDQW5CLEtBQUtvQixPQUFPLENBQUNYLGlCQUFpQjtnQkFDNUJPLE9BQU87WUFDVDtTQUNELENBQUNLLE1BQU0sQ0FBQ2xCO1FBQ1RnQixTQUFTO0lBQ1g7SUFDQSxNQUFNRyxRQUFRO1FBQ1pOLE9BQU87UUFDUE4sS0FBSztRQUNMRyxVQUFVO1lBQUNiLEtBQUtvQixPQUFPLENBQUNYO1NBQWlCO1FBQ3pDVSxTQUFTO0lBQ1g7SUFDQWIsTUFBTWlCLElBQUksQ0FBQ1IsUUFBUU87SUFDbkJuQixpQkFBaUJxQixPQUFPLENBQUMsU0FBU0MsSUFBSTtRQUNwQ25CLE1BQU1pQixJQUFJLENBQUNFO0lBQ2I7SUFDQSxPQUFPO1FBQ0xDLE1BQU07UUFDTmIsVUFBVVA7UUFDVlEsVUFBVWI7UUFDVmtCLFNBQVM7SUFDWDtBQUNGO0FBRUFRLE9BQU9DLE9BQU8sR0FBRzdCIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL2pzb24uanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/markdown.js":
/*!*************************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/markdown.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/*\nLanguage: Markdown\nRequires: xml.js\nAuthor: John Crepezzi <john.crepezzi@gmail.com>\nWebsite: https://daringfireball.net/projects/markdown/\nCategory: common, markup\n*/ function markdown(hljs) {\n    const INLINE_HTML = {\n        begin: /<\\/?[A-Za-z_]/,\n        end: \">\",\n        subLanguage: \"xml\",\n        relevance: 0\n    };\n    const HORIZONTAL_RULE = {\n        begin: \"^[-\\\\*]{3,}\",\n        end: \"$\"\n    };\n    const CODE = {\n        className: \"code\",\n        variants: [\n            // TODO: fix to allow these to work with sublanguage also\n            {\n                begin: \"(`{3,})[^`](.|\\\\n)*?\\\\1`*[ ]*\"\n            },\n            {\n                begin: \"(~{3,})[^~](.|\\\\n)*?\\\\1~*[ ]*\"\n            },\n            // needed to allow markdown as a sublanguage to work\n            {\n                begin: \"```\",\n                end: \"```+[ ]*$\"\n            },\n            {\n                begin: \"~~~\",\n                end: \"~~~+[ ]*$\"\n            },\n            {\n                begin: \"`.+?`\"\n            },\n            {\n                begin: \"(?=^( {4}|\\\\t))\",\n                // use contains to gobble up multiple lines to allow the block to be whatever size\n                // but only have a single open/close tag vs one per line\n                contains: [\n                    {\n                        begin: \"^( {4}|\\\\t)\",\n                        end: \"(\\\\n)$\"\n                    }\n                ],\n                relevance: 0\n            }\n        ]\n    };\n    const LIST = {\n        className: \"bullet\",\n        begin: \"^[ \t]*([*+-]|(\\\\d+\\\\.))(?=\\\\s+)\",\n        end: \"\\\\s+\",\n        excludeEnd: true\n    };\n    const LINK_REFERENCE = {\n        begin: /^\\[[^\\n]+\\]:/,\n        returnBegin: true,\n        contains: [\n            {\n                className: \"symbol\",\n                begin: /\\[/,\n                end: /\\]/,\n                excludeBegin: true,\n                excludeEnd: true\n            },\n            {\n                className: \"link\",\n                begin: /:\\s*/,\n                end: /$/,\n                excludeBegin: true\n            }\n        ]\n    };\n    const URL_SCHEME = /[A-Za-z][A-Za-z0-9+.-]*/;\n    const LINK = {\n        variants: [\n            // too much like nested array access in so many languages\n            // to have any real relevance\n            {\n                begin: /\\[.+?\\]\\[.*?\\]/,\n                relevance: 0\n            },\n            // popular internet URLs\n            {\n                begin: /\\[.+?\\]\\(((data|javascript|mailto):|(?:http|ftp)s?:\\/\\/).*?\\)/,\n                relevance: 2\n            },\n            {\n                begin: concat(/\\[.+?\\]\\(/, URL_SCHEME, /:\\/\\/.*?\\)/),\n                relevance: 2\n            },\n            // relative urls\n            {\n                begin: /\\[.+?\\]\\([./?&#].*?\\)/,\n                relevance: 1\n            },\n            // whatever else, lower relevance (might not be a link at all)\n            {\n                begin: /\\[.+?\\]\\(.*?\\)/,\n                relevance: 0\n            }\n        ],\n        returnBegin: true,\n        contains: [\n            {\n                className: \"string\",\n                relevance: 0,\n                begin: \"\\\\[\",\n                end: \"\\\\]\",\n                excludeBegin: true,\n                returnEnd: true\n            },\n            {\n                className: \"link\",\n                relevance: 0,\n                begin: \"\\\\]\\\\(\",\n                end: \"\\\\)\",\n                excludeBegin: true,\n                excludeEnd: true\n            },\n            {\n                className: \"symbol\",\n                relevance: 0,\n                begin: \"\\\\]\\\\[\",\n                end: \"\\\\]\",\n                excludeBegin: true,\n                excludeEnd: true\n            }\n        ]\n    };\n    const BOLD = {\n        className: \"strong\",\n        contains: [],\n        variants: [\n            {\n                begin: /_{2}/,\n                end: /_{2}/\n            },\n            {\n                begin: /\\*{2}/,\n                end: /\\*{2}/\n            }\n        ]\n    };\n    const ITALIC = {\n        className: \"emphasis\",\n        contains: [],\n        variants: [\n            {\n                begin: /\\*(?!\\*)/,\n                end: /\\*/\n            },\n            {\n                begin: /_(?!_)/,\n                end: /_/,\n                relevance: 0\n            }\n        ]\n    };\n    BOLD.contains.push(ITALIC);\n    ITALIC.contains.push(BOLD);\n    let CONTAINABLE = [\n        INLINE_HTML,\n        LINK\n    ];\n    BOLD.contains = BOLD.contains.concat(CONTAINABLE);\n    ITALIC.contains = ITALIC.contains.concat(CONTAINABLE);\n    CONTAINABLE = CONTAINABLE.concat(BOLD, ITALIC);\n    const HEADER = {\n        className: \"section\",\n        variants: [\n            {\n                begin: \"^#{1,6}\",\n                end: \"$\",\n                contains: CONTAINABLE\n            },\n            {\n                begin: \"(?=^.+?\\\\n[=-]{2,}$)\",\n                contains: [\n                    {\n                        begin: \"^[=-]*$\"\n                    },\n                    {\n                        begin: \"^\",\n                        end: \"\\\\n\",\n                        contains: CONTAINABLE\n                    }\n                ]\n            }\n        ]\n    };\n    const BLOCKQUOTE = {\n        className: \"quote\",\n        begin: \"^>\\\\s+\",\n        contains: CONTAINABLE,\n        end: \"$\"\n    };\n    return {\n        name: \"Markdown\",\n        aliases: [\n            \"md\",\n            \"mkdown\",\n            \"mkd\"\n        ],\n        contains: [\n            HEADER,\n            INLINE_HTML,\n            LIST,\n            BOLD,\n            ITALIC,\n            BLOCKQUOTE,\n            CODE,\n            HORIZONTAL_RULE,\n            LINK,\n            LINK_REFERENCE\n        ]\n    };\n}\nmodule.exports = markdown;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL21hcmtkb3duLmpzPzg5ODIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi4oUmVnRXhwIHwgc3RyaW5nKSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9IGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qXG5MYW5ndWFnZTogTWFya2Rvd25cblJlcXVpcmVzOiB4bWwuanNcbkF1dGhvcjogSm9obiBDcmVwZXp6aSA8am9obi5jcmVwZXp6aUBnbWFpbC5jb20+XG5XZWJzaXRlOiBodHRwczovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9cbkNhdGVnb3J5OiBjb21tb24sIG1hcmt1cFxuKi9cblxuZnVuY3Rpb24gbWFya2Rvd24oaGxqcykge1xuICBjb25zdCBJTkxJTkVfSFRNTCA9IHtcbiAgICBiZWdpbjogLzxcXC8/W0EtWmEtel9dLyxcbiAgICBlbmQ6ICc+JyxcbiAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGNvbnN0IEhPUklaT05UQUxfUlVMRSA9IHtcbiAgICBiZWdpbjogJ15bLVxcXFwqXXszLH0nLFxuICAgIGVuZDogJyQnXG4gIH07XG4gIGNvbnN0IENPREUgPSB7XG4gICAgY2xhc3NOYW1lOiAnY29kZScsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIFRPRE86IGZpeCB0byBhbGxvdyB0aGVzZSB0byB3b3JrIHdpdGggc3VibGFuZ3VhZ2UgYWxzb1xuICAgICAge1xuICAgICAgICBiZWdpbjogJyhgezMsfSlbXmBdKC58XFxcXG4pKj9cXFxcMWAqWyBdKidcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnKH57Myx9KVtefl0oLnxcXFxcbikqP1xcXFwxfipbIF0qJ1xuICAgICAgfSxcbiAgICAgIC8vIG5lZWRlZCB0byBhbGxvdyBtYXJrZG93biBhcyBhIHN1Ymxhbmd1YWdlIHRvIHdvcmtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICdgYGAnLFxuICAgICAgICBlbmQ6ICdgYGArWyBdKiQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJ35+ficsXG4gICAgICAgIGVuZDogJ35+fitbIF0qJCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnYC4rP2AnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJyg/PV4oIHs0fXxcXFxcdCkpJyxcbiAgICAgICAgLy8gdXNlIGNvbnRhaW5zIHRvIGdvYmJsZSB1cCBtdWx0aXBsZSBsaW5lcyB0byBhbGxvdyB0aGUgYmxvY2sgdG8gYmUgd2hhdGV2ZXIgc2l6ZVxuICAgICAgICAvLyBidXQgb25seSBoYXZlIGEgc2luZ2xlIG9wZW4vY2xvc2UgdGFnIHZzIG9uZSBwZXIgbGluZVxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAnXiggezR9fFxcXFx0KScsXG4gICAgICAgICAgICBlbmQ6ICcoXFxcXG4pJCdcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3QgTElTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdidWxsZXQnLFxuICAgIGJlZ2luOiAnXlsgXFx0XSooWyorLV18KFxcXFxkK1xcXFwuKSkoPz1cXFxccyspJyxcbiAgICBlbmQ6ICdcXFxccysnLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgfTtcbiAgY29uc3QgTElOS19SRUZFUkVOQ0UgPSB7XG4gICAgYmVnaW46IC9eXFxbW15cXG5dK1xcXTovLFxuICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N5bWJvbCcsXG4gICAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdsaW5rJyxcbiAgICAgICAgYmVnaW46IC86XFxzKi8sXG4gICAgICAgIGVuZDogLyQvLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IFVSTF9TQ0hFTUUgPSAvW0EtWmEtel1bQS1aYS16MC05Ky4tXSovO1xuICBjb25zdCBMSU5LID0ge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICAvLyB0b28gbXVjaCBsaWtlIG5lc3RlZCBhcnJheSBhY2Nlc3MgaW4gc28gbWFueSBsYW5ndWFnZXNcbiAgICAgIC8vIHRvIGhhdmUgYW55IHJlYWwgcmVsZXZhbmNlXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLis/XFxdXFxbLio/XFxdLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgLy8gcG9wdWxhciBpbnRlcm5ldCBVUkxzXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxbLis/XFxdXFwoKChkYXRhfGphdmFzY3JpcHR8bWFpbHRvKTp8KD86aHR0cHxmdHApcz86XFwvXFwvKS4qP1xcKS8sXG4gICAgICAgIHJlbGV2YW5jZTogMlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGNvbmNhdCgvXFxbLis/XFxdXFwoLywgVVJMX1NDSEVNRSwgLzpcXC9cXC8uKj9cXCkvKSxcbiAgICAgICAgcmVsZXZhbmNlOiAyXG4gICAgICB9LFxuICAgICAgLy8gcmVsYXRpdmUgdXJsc1xuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcWy4rP1xcXVxcKFsuLz8mI10uKj9cXCkvLFxuICAgICAgICByZWxldmFuY2U6IDFcbiAgICAgIH0sXG4gICAgICAvLyB3aGF0ZXZlciBlbHNlLCBsb3dlciByZWxldmFuY2UgKG1pZ2h0IG5vdCBiZSBhIGxpbmsgYXQgYWxsKVxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcWy4rP1xcXVxcKC4qP1xcKS8sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfVxuICAgIF0sXG4gICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBiZWdpbjogJ1xcXFxbJyxcbiAgICAgICAgZW5kOiAnXFxcXF0nLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgIHJldHVybkVuZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbGluaycsXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgYmVnaW46ICdcXFxcXVxcXFwoJyxcbiAgICAgICAgZW5kOiAnXFxcXCknLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3N5bWJvbCcsXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgYmVnaW46ICdcXFxcXVxcXFxbJyxcbiAgICAgICAgZW5kOiAnXFxcXF0nLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWVcbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IEJPTEQgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Ryb25nJyxcbiAgICBjb250YWluczogW10sXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9fezJ9LyxcbiAgICAgICAgZW5kOiAvX3syfS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFwqezJ9LyxcbiAgICAgICAgZW5kOiAvXFwqezJ9L1xuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3QgSVRBTElDID0ge1xuICAgIGNsYXNzTmFtZTogJ2VtcGhhc2lzJyxcbiAgICBjb250YWluczogW10sXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCooPyFcXCopLyxcbiAgICAgICAgZW5kOiAvXFwqL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9fKD8hXykvLFxuICAgICAgICBlbmQ6IC9fLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBCT0xELmNvbnRhaW5zLnB1c2goSVRBTElDKTtcbiAgSVRBTElDLmNvbnRhaW5zLnB1c2goQk9MRCk7XG5cbiAgbGV0IENPTlRBSU5BQkxFID0gW1xuICAgIElOTElORV9IVE1MLFxuICAgIExJTktcbiAgXTtcblxuICBCT0xELmNvbnRhaW5zID0gQk9MRC5jb250YWlucy5jb25jYXQoQ09OVEFJTkFCTEUpO1xuICBJVEFMSUMuY29udGFpbnMgPSBJVEFMSUMuY29udGFpbnMuY29uY2F0KENPTlRBSU5BQkxFKTtcblxuICBDT05UQUlOQUJMRSA9IENPTlRBSU5BQkxFLmNvbmNhdChCT0xELCBJVEFMSUMpO1xuXG4gIGNvbnN0IEhFQURFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdzZWN0aW9uJyxcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogJ14jezEsNn0nLFxuICAgICAgICBlbmQ6ICckJyxcbiAgICAgICAgY29udGFpbnM6IENPTlRBSU5BQkxFXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogJyg/PV4uKz9cXFxcbls9LV17Mix9JCknLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAnXls9LV0qJCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAnXicsXG4gICAgICAgICAgICBlbmQ6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIGNvbnRhaW5zOiBDT05UQUlOQUJMRVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcblxuICBjb25zdCBCTE9DS1FVT1RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3F1b3RlJyxcbiAgICBiZWdpbjogJ14+XFxcXHMrJyxcbiAgICBjb250YWluczogQ09OVEFJTkFCTEUsXG4gICAgZW5kOiAnJCdcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdNYXJrZG93bicsXG4gICAgYWxpYXNlczogW1xuICAgICAgJ21kJyxcbiAgICAgICdta2Rvd24nLFxuICAgICAgJ21rZCdcbiAgICBdLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBIRUFERVIsXG4gICAgICBJTkxJTkVfSFRNTCxcbiAgICAgIExJU1QsXG4gICAgICBCT0xELFxuICAgICAgSVRBTElDLFxuICAgICAgQkxPQ0tRVU9URSxcbiAgICAgIENPREUsXG4gICAgICBIT1JJWk9OVEFMX1JVTEUsXG4gICAgICBMSU5LLFxuICAgICAgTElOS19SRUZFUkVOQ0VcbiAgICBdXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFya2Rvd247XG4iXSwibmFtZXMiOlsic291cmNlIiwicmUiLCJjb25jYXQiLCJhcmdzIiwiam9pbmVkIiwibWFwIiwieCIsImpvaW4iLCJtYXJrZG93biIsImhsanMiLCJJTkxJTkVfSFRNTCIsImJlZ2luIiwiZW5kIiwic3ViTGFuZ3VhZ2UiLCJyZWxldmFuY2UiLCJIT1JJWk9OVEFMX1JVTEUiLCJDT0RFIiwiY2xhc3NOYW1lIiwidmFyaWFudHMiLCJjb250YWlucyIsIkxJU1QiLCJleGNsdWRlRW5kIiwiTElOS19SRUZFUkVOQ0UiLCJyZXR1cm5CZWdpbiIsImV4Y2x1ZGVCZWdpbiIsIlVSTF9TQ0hFTUUiLCJMSU5LIiwicmV0dXJuRW5kIiwiQk9MRCIsIklUQUxJQyIsInB1c2giLCJDT05UQUlOQUJMRSIsIkhFQURFUiIsIkJMT0NLUVVPVEUiLCJuYW1lIiwiYWxpYXNlcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRyxHQUVIOzs7Q0FHQyxHQUNELFNBQVNBLE9BQU9DLEVBQUU7SUFDaEIsSUFBSSxDQUFDQSxJQUFJLE9BQU87SUFDaEIsSUFBSSxPQUFPQSxPQUFPLFVBQVUsT0FBT0E7SUFFbkMsT0FBT0EsR0FBR0QsTUFBTTtBQUNsQjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNFLE9BQU8sR0FBR0MsSUFBSTtJQUNyQixNQUFNQyxTQUFTRCxLQUFLRSxHQUFHLENBQUMsQ0FBQ0MsSUFBTU4sT0FBT00sSUFBSUMsSUFBSSxDQUFDO0lBQy9DLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7O0FBTUEsR0FFQSxTQUFTSSxTQUFTQyxJQUFJO0lBQ3BCLE1BQU1DLGNBQWM7UUFDbEJDLE9BQU87UUFDUEMsS0FBSztRQUNMQyxhQUFhO1FBQ2JDLFdBQVc7SUFDYjtJQUNBLE1BQU1DLGtCQUFrQjtRQUN0QkosT0FBTztRQUNQQyxLQUFLO0lBQ1A7SUFDQSxNQUFNSSxPQUFPO1FBQ1hDLFdBQVc7UUFDWEMsVUFBVTtZQUNSLHlEQUF5RDtZQUN6RDtnQkFDRVAsT0FBTztZQUNUO1lBQ0E7Z0JBQ0VBLE9BQU87WUFDVDtZQUNBLG9EQUFvRDtZQUNwRDtnQkFDRUEsT0FBTztnQkFDUEMsS0FBSztZQUNQO1lBQ0E7Z0JBQ0VELE9BQU87Z0JBQ1BDLEtBQUs7WUFDUDtZQUNBO2dCQUNFRCxPQUFPO1lBQ1Q7WUFDQTtnQkFDRUEsT0FBTztnQkFDUCxrRkFBa0Y7Z0JBQ2xGLHdEQUF3RDtnQkFDeERRLFVBQVU7b0JBQ1I7d0JBQ0VSLE9BQU87d0JBQ1BDLEtBQUs7b0JBQ1A7aUJBQ0Q7Z0JBQ0RFLFdBQVc7WUFDYjtTQUNEO0lBQ0g7SUFDQSxNQUFNTSxPQUFPO1FBQ1hILFdBQVc7UUFDWE4sT0FBTztRQUNQQyxLQUFLO1FBQ0xTLFlBQVk7SUFDZDtJQUNBLE1BQU1DLGlCQUFpQjtRQUNyQlgsT0FBTztRQUNQWSxhQUFhO1FBQ2JKLFVBQVU7WUFDUjtnQkFDRUYsV0FBVztnQkFDWE4sT0FBTztnQkFDUEMsS0FBSztnQkFDTFksY0FBYztnQkFDZEgsWUFBWTtZQUNkO1lBQ0E7Z0JBQ0VKLFdBQVc7Z0JBQ1hOLE9BQU87Z0JBQ1BDLEtBQUs7Z0JBQ0xZLGNBQWM7WUFDaEI7U0FDRDtJQUNIO0lBQ0EsTUFBTUMsYUFBYTtJQUNuQixNQUFNQyxPQUFPO1FBQ1hSLFVBQVU7WUFDUix5REFBeUQ7WUFDekQsNkJBQTZCO1lBQzdCO2dCQUNFUCxPQUFPO2dCQUNQRyxXQUFXO1lBQ2I7WUFDQSx3QkFBd0I7WUFDeEI7Z0JBQ0VILE9BQU87Z0JBQ1BHLFdBQVc7WUFDYjtZQUNBO2dCQUNFSCxPQUFPVCxPQUFPLGFBQWF1QixZQUFZO2dCQUN2Q1gsV0FBVztZQUNiO1lBQ0EsZ0JBQWdCO1lBQ2hCO2dCQUNFSCxPQUFPO2dCQUNQRyxXQUFXO1lBQ2I7WUFDQSw4REFBOEQ7WUFDOUQ7Z0JBQ0VILE9BQU87Z0JBQ1BHLFdBQVc7WUFDYjtTQUNEO1FBQ0RTLGFBQWE7UUFDYkosVUFBVTtZQUNSO2dCQUNFRixXQUFXO2dCQUNYSCxXQUFXO2dCQUNYSCxPQUFPO2dCQUNQQyxLQUFLO2dCQUNMWSxjQUFjO2dCQUNkRyxXQUFXO1lBQ2I7WUFDQTtnQkFDRVYsV0FBVztnQkFDWEgsV0FBVztnQkFDWEgsT0FBTztnQkFDUEMsS0FBSztnQkFDTFksY0FBYztnQkFDZEgsWUFBWTtZQUNkO1lBQ0E7Z0JBQ0VKLFdBQVc7Z0JBQ1hILFdBQVc7Z0JBQ1hILE9BQU87Z0JBQ1BDLEtBQUs7Z0JBQ0xZLGNBQWM7Z0JBQ2RILFlBQVk7WUFDZDtTQUNEO0lBQ0g7SUFDQSxNQUFNTyxPQUFPO1FBQ1hYLFdBQVc7UUFDWEUsVUFBVSxFQUFFO1FBQ1pELFVBQVU7WUFDUjtnQkFDRVAsT0FBTztnQkFDUEMsS0FBSztZQUNQO1lBQ0E7Z0JBQ0VELE9BQU87Z0JBQ1BDLEtBQUs7WUFDUDtTQUNEO0lBQ0g7SUFDQSxNQUFNaUIsU0FBUztRQUNiWixXQUFXO1FBQ1hFLFVBQVUsRUFBRTtRQUNaRCxVQUFVO1lBQ1I7Z0JBQ0VQLE9BQU87Z0JBQ1BDLEtBQUs7WUFDUDtZQUNBO2dCQUNFRCxPQUFPO2dCQUNQQyxLQUFLO2dCQUNMRSxXQUFXO1lBQ2I7U0FDRDtJQUNIO0lBQ0FjLEtBQUtULFFBQVEsQ0FBQ1csSUFBSSxDQUFDRDtJQUNuQkEsT0FBT1YsUUFBUSxDQUFDVyxJQUFJLENBQUNGO0lBRXJCLElBQUlHLGNBQWM7UUFDaEJyQjtRQUNBZ0I7S0FDRDtJQUVERSxLQUFLVCxRQUFRLEdBQUdTLEtBQUtULFFBQVEsQ0FBQ2pCLE1BQU0sQ0FBQzZCO0lBQ3JDRixPQUFPVixRQUFRLEdBQUdVLE9BQU9WLFFBQVEsQ0FBQ2pCLE1BQU0sQ0FBQzZCO0lBRXpDQSxjQUFjQSxZQUFZN0IsTUFBTSxDQUFDMEIsTUFBTUM7SUFFdkMsTUFBTUcsU0FBUztRQUNiZixXQUFXO1FBQ1hDLFVBQVU7WUFDUjtnQkFDRVAsT0FBTztnQkFDUEMsS0FBSztnQkFDTE8sVUFBVVk7WUFDWjtZQUNBO2dCQUNFcEIsT0FBTztnQkFDUFEsVUFBVTtvQkFDUjt3QkFDRVIsT0FBTztvQkFDVDtvQkFDQTt3QkFDRUEsT0FBTzt3QkFDUEMsS0FBSzt3QkFDTE8sVUFBVVk7b0JBQ1o7aUJBQ0Q7WUFDSDtTQUNEO0lBQ0g7SUFFQSxNQUFNRSxhQUFhO1FBQ2pCaEIsV0FBVztRQUNYTixPQUFPO1FBQ1BRLFVBQVVZO1FBQ1ZuQixLQUFLO0lBQ1A7SUFFQSxPQUFPO1FBQ0xzQixNQUFNO1FBQ05DLFNBQVM7WUFDUDtZQUNBO1lBQ0E7U0FDRDtRQUNEaEIsVUFBVTtZQUNSYTtZQUNBdEI7WUFDQVU7WUFDQVE7WUFDQUM7WUFDQUk7WUFDQWpCO1lBQ0FEO1lBQ0FXO1lBQ0FKO1NBQ0Q7SUFDSDtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBRzdCIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL21hcmtkb3duLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/markdown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/python.js":
/*!***********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/python.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/*\nLanguage: Python\nDescription: Python is an interpreted, object-oriented, high-level programming language with dynamic semantics.\nWebsite: https://www.python.org\nCategory: common\n*/ function python(hljs) {\n    const RESERVED_WORDS = [\n        \"and\",\n        \"as\",\n        \"assert\",\n        \"async\",\n        \"await\",\n        \"break\",\n        \"class\",\n        \"continue\",\n        \"def\",\n        \"del\",\n        \"elif\",\n        \"else\",\n        \"except\",\n        \"finally\",\n        \"for\",\n        \"\",\n        \"from\",\n        \"global\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"is\",\n        \"lambda\",\n        \"nonlocal|10\",\n        \"not\",\n        \"or\",\n        \"pass\",\n        \"raise\",\n        \"return\",\n        \"try\",\n        \"while\",\n        \"with\",\n        \"yield\"\n    ];\n    const BUILT_INS = [\n        \"__import__\",\n        \"abs\",\n        \"all\",\n        \"any\",\n        \"ascii\",\n        \"bin\",\n        \"bool\",\n        \"breakpoint\",\n        \"bytearray\",\n        \"bytes\",\n        \"callable\",\n        \"chr\",\n        \"classmethod\",\n        \"compile\",\n        \"complex\",\n        \"delattr\",\n        \"dict\",\n        \"dir\",\n        \"divmod\",\n        \"enumerate\",\n        \"eval\",\n        \"exec\",\n        \"filter\",\n        \"float\",\n        \"format\",\n        \"frozenset\",\n        \"getattr\",\n        \"globals\",\n        \"hasattr\",\n        \"hash\",\n        \"help\",\n        \"hex\",\n        \"id\",\n        \"input\",\n        \"int\",\n        \"isinstance\",\n        \"issubclass\",\n        \"iter\",\n        \"len\",\n        \"list\",\n        \"locals\",\n        \"map\",\n        \"max\",\n        \"memoryview\",\n        \"min\",\n        \"next\",\n        \"object\",\n        \"oct\",\n        \"open\",\n        \"ord\",\n        \"pow\",\n        \"print\",\n        \"property\",\n        \"range\",\n        \"repr\",\n        \"reversed\",\n        \"round\",\n        \"set\",\n        \"setattr\",\n        \"slice\",\n        \"sorted\",\n        \"staticmethod\",\n        \"str\",\n        \"sum\",\n        \"super\",\n        \"tuple\",\n        \"type\",\n        \"vars\",\n        \"zip\"\n    ];\n    const LITERALS = [\n        \"__debug__\",\n        \"Ellipsis\",\n        \"False\",\n        \"None\",\n        \"NotImplemented\",\n        \"True\"\n    ];\n    const KEYWORDS = {\n        keyword: RESERVED_WORDS.join(\" \"),\n        built_in: BUILT_INS.join(\" \"),\n        literal: LITERALS.join(\" \")\n    };\n    const PROMPT = {\n        className: \"meta\",\n        begin: /^(>>>|\\.\\.\\.) /\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS,\n        illegal: /#/\n    };\n    const LITERAL_BRACKET = {\n        begin: /\\{\\{/,\n        relevance: 0\n    };\n    const STRING = {\n        className: \"string\",\n        contains: [\n            hljs.BACKSLASH_ESCAPE\n        ],\n        variants: [\n            {\n                begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,\n                end: /'''/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    PROMPT\n                ],\n                relevance: 10\n            },\n            {\n                begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?\"\"\"/,\n                end: /\"\"\"/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    PROMPT\n                ],\n                relevance: 10\n            },\n            {\n                begin: /([fF][rR]|[rR][fF]|[fF])'''/,\n                end: /'''/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    PROMPT,\n                    LITERAL_BRACKET,\n                    SUBST\n                ]\n            },\n            {\n                begin: /([fF][rR]|[rR][fF]|[fF])\"\"\"/,\n                end: /\"\"\"/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    PROMPT,\n                    LITERAL_BRACKET,\n                    SUBST\n                ]\n            },\n            {\n                begin: /([uU]|[rR])'/,\n                end: /'/,\n                relevance: 10\n            },\n            {\n                begin: /([uU]|[rR])\"/,\n                end: /\"/,\n                relevance: 10\n            },\n            {\n                begin: /([bB]|[bB][rR]|[rR][bB])'/,\n                end: /'/\n            },\n            {\n                begin: /([bB]|[bB][rR]|[rR][bB])\"/,\n                end: /\"/\n            },\n            {\n                begin: /([fF][rR]|[rR][fF]|[fF])'/,\n                end: /'/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    LITERAL_BRACKET,\n                    SUBST\n                ]\n            },\n            {\n                begin: /([fF][rR]|[rR][fF]|[fF])\"/,\n                end: /\"/,\n                contains: [\n                    hljs.BACKSLASH_ESCAPE,\n                    LITERAL_BRACKET,\n                    SUBST\n                ]\n            },\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE\n        ]\n    };\n    // https://docs.python.org/3.9/reference/lexical_analysis.html#numeric-literals\n    const digitpart = \"[0-9](_?[0-9])*\";\n    const pointfloat = `(\\\\b(${digitpart}))?\\\\.(${digitpart})|\\\\b(${digitpart})\\\\.`;\n    const NUMBER = {\n        className: \"number\",\n        relevance: 0,\n        variants: [\n            // exponentfloat, pointfloat\n            // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals\n            // optionally imaginary\n            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals\n            // Note: no leading \\b because floats can start with a decimal point\n            // and we don't want to mishandle e.g. `fn(.5)`,\n            // no trailing \\b for pointfloat because it can end with a decimal point\n            // and we don't want to mishandle e.g. `0..hex()`; this should be safe\n            // because both MUST contain a decimal point and so cannot be confused with\n            // the interior part of an identifier\n            {\n                begin: `(\\\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?\\\\b`\n            },\n            {\n                begin: `(${pointfloat})[jJ]?`\n            },\n            // decinteger, bininteger, octinteger, hexinteger\n            // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals\n            // optionally \"long\" in Python 2\n            // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals\n            // decinteger is optionally imaginary\n            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals\n            {\n                begin: \"\\\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[bB](_?[01])+[lL]?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[oO](_?[0-7])+[lL]?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[xX](_?[0-9a-fA-F])+[lL]?\\\\b\"\n            },\n            // imagnumber (digitpart-based)\n            // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals\n            {\n                begin: `\\\\b(${digitpart})[jJ]\\\\b`\n            }\n        ]\n    };\n    const PARAMS = {\n        className: \"params\",\n        variants: [\n            // Exclude params at functions without params\n            {\n                begin: /\\(\\s*\\)/,\n                skip: true,\n                className: null\n            },\n            {\n                begin: /\\(/,\n                end: /\\)/,\n                excludeBegin: true,\n                excludeEnd: true,\n                keywords: KEYWORDS,\n                contains: [\n                    \"self\",\n                    PROMPT,\n                    NUMBER,\n                    STRING,\n                    hljs.HASH_COMMENT_MODE\n                ]\n            }\n        ]\n    };\n    SUBST.contains = [\n        STRING,\n        NUMBER,\n        PROMPT\n    ];\n    return {\n        name: \"Python\",\n        aliases: [\n            \"py\",\n            \"gyp\",\n            \"ipython\"\n        ],\n        keywords: KEYWORDS,\n        illegal: /(<\\/|->|\\?)|=>/,\n        contains: [\n            PROMPT,\n            NUMBER,\n            // eat \"if\" prior to string so that it won't accidentally be\n            // labeled as an f-string as in:\n            {\n                begin: /\\bself\\b/\n            },\n            {\n                beginKeywords: \"if\",\n                relevance: 0\n            },\n            STRING,\n            hljs.HASH_COMMENT_MODE,\n            {\n                variants: [\n                    {\n                        className: \"function\",\n                        beginKeywords: \"def\"\n                    },\n                    {\n                        className: \"class\",\n                        beginKeywords: \"class\"\n                    }\n                ],\n                end: /:/,\n                illegal: /[${=;\\n,]/,\n                contains: [\n                    hljs.UNDERSCORE_TITLE_MODE,\n                    PARAMS,\n                    {\n                        begin: /->/,\n                        endsWithParent: true,\n                        keywords: \"None\"\n                    }\n                ]\n            },\n            {\n                className: \"meta\",\n                begin: /^[\\t ]*@/,\n                end: /(?=#)|$/,\n                contains: [\n                    NUMBER,\n                    PARAMS,\n                    STRING\n                ]\n            },\n            {\n                begin: /\\b(print|exec)\\(/ // don’t highlight keywords-turned-functions in Python 3\n            }\n        ]\n    };\n}\nmodule.exports = python;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3B5dGhvbi5qcz83MWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5MYW5ndWFnZTogUHl0aG9uXG5EZXNjcmlwdGlvbjogUHl0aG9uIGlzIGFuIGludGVycHJldGVkLCBvYmplY3Qtb3JpZW50ZWQsIGhpZ2gtbGV2ZWwgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugd2l0aCBkeW5hbWljIHNlbWFudGljcy5cbldlYnNpdGU6IGh0dHBzOi8vd3d3LnB5dGhvbi5vcmdcbkNhdGVnb3J5OiBjb21tb25cbiovXG5cbmZ1bmN0aW9uIHB5dGhvbihobGpzKSB7XG4gIGNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuICAgICdhbmQnLFxuICAgICdhcycsXG4gICAgJ2Fzc2VydCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXdhaXQnLFxuICAgICdicmVhaycsXG4gICAgJ2NsYXNzJyxcbiAgICAnY29udGludWUnLFxuICAgICdkZWYnLFxuICAgICdkZWwnLFxuICAgICdlbGlmJyxcbiAgICAnZWxzZScsXG4gICAgJ2V4Y2VwdCcsXG4gICAgJ2ZpbmFsbHknLFxuICAgICdmb3InLFxuICAgICcnLFxuICAgICdmcm9tJyxcbiAgICAnZ2xvYmFsJyxcbiAgICAnaWYnLFxuICAgICdpbXBvcnQnLFxuICAgICdpbicsXG4gICAgJ2lzJyxcbiAgICAnbGFtYmRhJyxcbiAgICAnbm9ubG9jYWx8MTAnLFxuICAgICdub3QnLFxuICAgICdvcicsXG4gICAgJ3Bhc3MnLFxuICAgICdyYWlzZScsXG4gICAgJ3JldHVybicsXG4gICAgJ3RyeScsXG4gICAgJ3doaWxlJyxcbiAgICAnd2l0aCcsXG4gICAgJ3lpZWxkJyxcbiAgXTtcblxuICBjb25zdCBCVUlMVF9JTlMgPSBbXG4gICAgJ19faW1wb3J0X18nLFxuICAgICdhYnMnLFxuICAgICdhbGwnLFxuICAgICdhbnknLFxuICAgICdhc2NpaScsXG4gICAgJ2JpbicsXG4gICAgJ2Jvb2wnLFxuICAgICdicmVha3BvaW50JyxcbiAgICAnYnl0ZWFycmF5JyxcbiAgICAnYnl0ZXMnLFxuICAgICdjYWxsYWJsZScsXG4gICAgJ2NocicsXG4gICAgJ2NsYXNzbWV0aG9kJyxcbiAgICAnY29tcGlsZScsXG4gICAgJ2NvbXBsZXgnLFxuICAgICdkZWxhdHRyJyxcbiAgICAnZGljdCcsXG4gICAgJ2RpcicsXG4gICAgJ2Rpdm1vZCcsXG4gICAgJ2VudW1lcmF0ZScsXG4gICAgJ2V2YWwnLFxuICAgICdleGVjJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZmxvYXQnLFxuICAgICdmb3JtYXQnLFxuICAgICdmcm96ZW5zZXQnLFxuICAgICdnZXRhdHRyJyxcbiAgICAnZ2xvYmFscycsXG4gICAgJ2hhc2F0dHInLFxuICAgICdoYXNoJyxcbiAgICAnaGVscCcsXG4gICAgJ2hleCcsXG4gICAgJ2lkJyxcbiAgICAnaW5wdXQnLFxuICAgICdpbnQnLFxuICAgICdpc2luc3RhbmNlJyxcbiAgICAnaXNzdWJjbGFzcycsXG4gICAgJ2l0ZXInLFxuICAgICdsZW4nLFxuICAgICdsaXN0JyxcbiAgICAnbG9jYWxzJyxcbiAgICAnbWFwJyxcbiAgICAnbWF4JyxcbiAgICAnbWVtb3J5dmlldycsXG4gICAgJ21pbicsXG4gICAgJ25leHQnLFxuICAgICdvYmplY3QnLFxuICAgICdvY3QnLFxuICAgICdvcGVuJyxcbiAgICAnb3JkJyxcbiAgICAncG93JyxcbiAgICAncHJpbnQnLFxuICAgICdwcm9wZXJ0eScsXG4gICAgJ3JhbmdlJyxcbiAgICAncmVwcicsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAncm91bmQnLFxuICAgICdzZXQnLFxuICAgICdzZXRhdHRyJyxcbiAgICAnc2xpY2UnLFxuICAgICdzb3J0ZWQnLFxuICAgICdzdGF0aWNtZXRob2QnLFxuICAgICdzdHInLFxuICAgICdzdW0nLFxuICAgICdzdXBlcicsXG4gICAgJ3R1cGxlJyxcbiAgICAndHlwZScsXG4gICAgJ3ZhcnMnLFxuICAgICd6aXAnLFxuICBdO1xuXG4gIGNvbnN0IExJVEVSQUxTID0gW1xuICAgICdfX2RlYnVnX18nLFxuICAgICdFbGxpcHNpcycsXG4gICAgJ0ZhbHNlJyxcbiAgICAnTm9uZScsXG4gICAgJ05vdEltcGxlbWVudGVkJyxcbiAgICAnVHJ1ZScsXG4gIF07XG5cbiAgY29uc3QgS0VZV09SRFMgPSB7XG4gICAga2V5d29yZDogUkVTRVJWRURfV09SRFMuam9pbignICcpLFxuICAgIGJ1aWx0X2luOiBCVUlMVF9JTlMuam9pbignICcpLFxuICAgIGxpdGVyYWw6IExJVEVSQUxTLmpvaW4oJyAnKVxuICB9O1xuXG4gIGNvbnN0IFBST01QVCA9IHtcbiAgICBjbGFzc05hbWU6ICdtZXRhJywgIGJlZ2luOiAvXig+Pj58XFwuXFwuXFwuKSAvXG4gIH07XG5cbiAgY29uc3QgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAvXFx7LywgZW5kOiAvXFx9LyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgaWxsZWdhbDogLyMvXG4gIH07XG5cbiAgY29uc3QgTElURVJBTF9CUkFDS0VUID0ge1xuICAgIGJlZ2luOiAvXFx7XFx7LyxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBTVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRV0sXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW3VVXXxbYkJdfFtyUl18W2JCXVtyUl18W3JSXVtiQl0pPycnJy8sIGVuZDogLycnJy8sXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFLCBQUk9NUFRdLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogLyhbdVVdfFtiQl18W3JSXXxbYkJdW3JSXXxbclJdW2JCXSk/XCJcIlwiLywgZW5kOiAvXCJcIlwiLyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFBST01QVF0sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtmRl1bclJdfFtyUl1bZkZdfFtmRl0pJycnLywgZW5kOiAvJycnLyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFBST01QVCwgTElURVJBTF9CUkFDS0VULCBTVUJTVF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtmRl1bclJdfFtyUl1bZkZdfFtmRl0pXCJcIlwiLywgZW5kOiAvXCJcIlwiLyxcbiAgICAgICAgY29udGFpbnM6IFtobGpzLkJBQ0tTTEFTSF9FU0NBUEUsIFBST01QVCwgTElURVJBTF9CUkFDS0VULCBTVUJTVF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFt1VV18W3JSXSknLywgZW5kOiAvJy8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFt1VV18W3JSXSlcIi8sIGVuZDogL1wiLyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC8oW2JCXXxbYkJdW3JSXXxbclJdW2JCXSknLywgZW5kOiAvJy9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtiQl18W2JCXVtyUl18W3JSXVtiQl0pXCIvLCBlbmQ6IC9cIi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtmRl1bclJdfFtyUl1bZkZdfFtmRl0pJy8sIGVuZDogLycvLFxuICAgICAgICBjb250YWluczogW2hsanMuQkFDS1NMQVNIX0VTQ0FQRSwgTElURVJBTF9CUkFDS0VULCBTVUJTVF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvKFtmRl1bclJdfFtyUl1bZkZdfFtmRl0pXCIvLCBlbmQ6IC9cIi8sXG4gICAgICAgIGNvbnRhaW5zOiBbaGxqcy5CQUNLU0xBU0hfRVNDQVBFLCBMSVRFUkFMX0JSQUNLRVQsIFNVQlNUXVxuICAgICAgfSxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICBdXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkaWdpdHBhcnQgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgcG9pbnRmbG9hdCA9IGAoXFxcXGIoJHtkaWdpdHBhcnR9KSk/XFxcXC4oJHtkaWdpdHBhcnR9KXxcXFxcYigke2RpZ2l0cGFydH0pXFxcXC5gO1xuICBjb25zdCBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJywgcmVsZXZhbmNlOiAwLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICAvLyBleHBvbmVudGZsb2F0LCBwb2ludGZsb2F0XG4gICAgICAvLyBodHRwczovL2RvY3MucHl0aG9uLm9yZy8zLjkvcmVmZXJlbmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNmbG9hdGluZy1wb2ludC1saXRlcmFsc1xuICAgICAgLy8gb3B0aW9uYWxseSBpbWFnaW5hcnlcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMuOS9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNpcy5odG1sI2ltYWdpbmFyeS1saXRlcmFsc1xuICAgICAgLy8gTm90ZTogbm8gbGVhZGluZyBcXGIgYmVjYXVzZSBmbG9hdHMgY2FuIHN0YXJ0IHdpdGggYSBkZWNpbWFsIHBvaW50XG4gICAgICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBtaXNoYW5kbGUgZS5nLiBgZm4oLjUpYCxcbiAgICAgIC8vIG5vIHRyYWlsaW5nIFxcYiBmb3IgcG9pbnRmbG9hdCBiZWNhdXNlIGl0IGNhbiBlbmQgd2l0aCBhIGRlY2ltYWwgcG9pbnRcbiAgICAgIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIG1pc2hhbmRsZSBlLmcuIGAwLi5oZXgoKWA7IHRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAgIC8vIGJlY2F1c2UgYm90aCBNVVNUIGNvbnRhaW4gYSBkZWNpbWFsIHBvaW50IGFuZCBzbyBjYW5ub3QgYmUgY29uZnVzZWQgd2l0aFxuICAgICAgLy8gdGhlIGludGVyaW9yIHBhcnQgb2YgYW4gaWRlbnRpZmllclxuICAgICAgeyBiZWdpbjogYChcXFxcYigke2RpZ2l0cGFydH0pfCgke3BvaW50ZmxvYXR9KSlbZUVdWystXT8oJHtkaWdpdHBhcnR9KVtqSl0/XFxcXGJgIH0sXG4gICAgICB7IGJlZ2luOiBgKCR7cG9pbnRmbG9hdH0pW2pKXT9gIH0sXG5cbiAgICAgIC8vIGRlY2ludGVnZXIsIGJpbmludGVnZXIsIG9jdGludGVnZXIsIGhleGludGVnZXJcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzMuOS9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNpcy5odG1sI2ludGVnZXItbGl0ZXJhbHNcbiAgICAgIC8vIG9wdGlvbmFsbHkgXCJsb25nXCIgaW4gUHl0aG9uIDJcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIuNy9yZWZlcmVuY2UvbGV4aWNhbF9hbmFseXNpcy5odG1sI2ludGVnZXItYW5kLWxvbmctaW50ZWdlci1saXRlcmFsc1xuICAgICAgLy8gZGVjaW50ZWdlciBpcyBvcHRpb25hbGx5IGltYWdpbmFyeVxuICAgICAgLy8gaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy45L3JlZmVyZW5jZS9sZXhpY2FsX2FuYWx5c2lzLmh0bWwjaW1hZ2luYXJ5LWxpdGVyYWxzXG4gICAgICB7IGJlZ2luOiAnXFxcXGIoWzEtOV0oXz9bMC05XSkqfDArKF8/MCkqKVtsTGpKXT9cXFxcYicgfSxcbiAgICAgIHsgYmVnaW46ICdcXFxcYjBbYkJdKF8/WzAxXSkrW2xMXT9cXFxcYicgfSxcbiAgICAgIHsgYmVnaW46ICdcXFxcYjBbb09dKF8/WzAtN10pK1tsTF0/XFxcXGInIH0sXG4gICAgICB7IGJlZ2luOiAnXFxcXGIwW3hYXShfP1swLTlhLWZBLUZdKStbbExdP1xcXFxiJyB9LFxuXG4gICAgICAvLyBpbWFnbnVtYmVyIChkaWdpdHBhcnQtYmFzZWQpXG4gICAgICAvLyBodHRwczovL2RvY3MucHl0aG9uLm9yZy8zLjkvcmVmZXJlbmNlL2xleGljYWxfYW5hbHlzaXMuaHRtbCNpbWFnaW5hcnktbGl0ZXJhbHNcbiAgICAgIHsgYmVnaW46IGBcXFxcYigke2RpZ2l0cGFydH0pW2pKXVxcXFxiYCB9LFxuICAgIF1cbiAgfTtcblxuICBjb25zdCBQQVJBTVMgPSB7XG4gICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gRXhjbHVkZSBwYXJhbXMgYXQgZnVuY3Rpb25zIHdpdGhvdXQgcGFyYW1zXG4gICAgICB7YmVnaW46IC9cXChcXHMqXFwpLywgc2tpcDogdHJ1ZSwgY2xhc3NOYW1lOiBudWxsIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFwoLywgZW5kOiAvXFwpLywgZXhjbHVkZUJlZ2luOiB0cnVlLCBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnLCBQUk9NUFQsIE5VTUJFUiwgU1RSSU5HLCBobGpzLkhBU0hfQ09NTUVOVF9NT0RFXSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbiAgU1VCU1QuY29udGFpbnMgPSBbU1RSSU5HLCBOVU1CRVIsIFBST01QVF07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUHl0aG9uJyxcbiAgICBhbGlhc2VzOiBbJ3B5JywgJ2d5cCcsICdpcHl0aG9uJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC8oPFxcL3wtPnxcXD8pfD0+LyxcbiAgICBjb250YWluczogW1xuICAgICAgUFJPTVBULFxuICAgICAgTlVNQkVSLFxuICAgICAgLy8gZWF0IFwiaWZcIiBwcmlvciB0byBzdHJpbmcgc28gdGhhdCBpdCB3b24ndCBhY2NpZGVudGFsbHkgYmVcbiAgICAgIC8vIGxhYmVsZWQgYXMgYW4gZi1zdHJpbmcgYXMgaW46XG4gICAgICB7IGJlZ2luOiAvXFxic2VsZlxcYi8sIH0sIC8vIHZlcnkgY29tbW9uIGNvbnZlbnRpb25cbiAgICAgIHsgYmVnaW5LZXl3b3JkczogXCJpZlwiLCByZWxldmFuY2U6IDAgfSxcbiAgICAgIFNUUklORyxcbiAgICAgIGhsanMuSEFTSF9DT01NRU5UX01PREUsXG4gICAgICB7XG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAge2NsYXNzTmFtZTogJ2Z1bmN0aW9uJywgYmVnaW5LZXl3b3JkczogJ2RlZid9LFxuICAgICAgICAgIHtjbGFzc05hbWU6ICdjbGFzcycsIGJlZ2luS2V5d29yZHM6ICdjbGFzcyd9XG4gICAgICAgIF0sXG4gICAgICAgIGVuZDogLzovLFxuICAgICAgICBpbGxlZ2FsOiAvWyR7PTtcXG4sXS8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5VTkRFUlNDT1JFX1RJVExFX01PREUsXG4gICAgICAgICAgUEFSQU1TLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvLT4vLCBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGtleXdvcmRzOiAnTm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogL15bXFx0IF0qQC8sIGVuZDogLyg/PSMpfCQvLFxuICAgICAgICBjb250YWluczogW05VTUJFUiwgUEFSQU1TLCBTVFJJTkddXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcYihwcmludHxleGVjKVxcKC8gLy8gZG9u4oCZdCBoaWdobGlnaHQga2V5d29yZHMtdHVybmVkLWZ1bmN0aW9ucyBpbiBQeXRob24gM1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBweXRob247XG4iXSwibmFtZXMiOlsicHl0aG9uIiwiaGxqcyIsIlJFU0VSVkVEX1dPUkRTIiwiQlVJTFRfSU5TIiwiTElURVJBTFMiLCJLRVlXT1JEUyIsImtleXdvcmQiLCJqb2luIiwiYnVpbHRfaW4iLCJsaXRlcmFsIiwiUFJPTVBUIiwiY2xhc3NOYW1lIiwiYmVnaW4iLCJTVUJTVCIsImVuZCIsImtleXdvcmRzIiwiaWxsZWdhbCIsIkxJVEVSQUxfQlJBQ0tFVCIsInJlbGV2YW5jZSIsIlNUUklORyIsImNvbnRhaW5zIiwiQkFDS1NMQVNIX0VTQ0FQRSIsInZhcmlhbnRzIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiZGlnaXRwYXJ0IiwicG9pbnRmbG9hdCIsIk5VTUJFUiIsIlBBUkFNUyIsInNraXAiLCJleGNsdWRlQmVnaW4iLCJleGNsdWRlRW5kIiwiSEFTSF9DT01NRU5UX01PREUiLCJuYW1lIiwiYWxpYXNlcyIsImJlZ2luS2V5d29yZHMiLCJVTkRFUlNDT1JFX1RJVExFX01PREUiLCJlbmRzV2l0aFBhcmVudCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBLEdBRUEsU0FBU0EsT0FBT0MsSUFBSTtJQUNsQixNQUFNQyxpQkFBaUI7UUFDckI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxZQUFZO1FBQ2hC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QUV1QixlQUFlO2dCQUFNakIsV0FBVztZQUFFO1lBQ3BDQztZQUNBbEIsS0FBSytCLGlCQUFpQjtZQUN0QjtnQkFDRVYsVUFBVTtvQkFDUjt3QkFBQ1gsV0FBVzt3QkFBWXdCLGVBQWU7b0JBQUs7b0JBQzVDO3dCQUFDeEIsV0FBVzt3QkFBU3dCLGVBQWU7b0JBQU87aUJBQzVDO2dCQUNEckIsS0FBSztnQkFDTEUsU0FBUztnQkFDVEksVUFBVTtvQkFDUm5CLEtBQUttQyxxQkFBcUI7b0JBQzFCUjtvQkFDQTt3QkFDRWhCLE9BQU87d0JBQU15QixnQkFBZ0I7d0JBQzdCdEIsVUFBVTtvQkFDWjtpQkFDRDtZQUNIO1lBQ0E7Z0JBQ0VKLFdBQVc7Z0JBQ1hDLE9BQU87Z0JBQVlFLEtBQUs7Z0JBQ3hCTSxVQUFVO29CQUFDTztvQkFBUUM7b0JBQVFUO2lCQUFPO1lBQ3BDO1lBQ0E7Z0JBQ0VQLE9BQU8sbUJBQW1CLHdEQUF3RDtZQUNwRjtTQUNEO0lBQ0g7QUFDRjtBQUVBMEIsT0FBT0MsT0FBTyxHQUFHdkMiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvcHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/python.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/sql.js":
/*!********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/sql.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */ function either(...args) {\n    const joined = \"(\" + args.map((x)=>source(x)).join(\"|\") + \")\";\n    return joined;\n}\n/*\n Language: SQL\n Website: https://en.wikipedia.org/wiki/SQL\n Category: common, database\n */ function sql(hljs) {\n    const COMMENT_MODE = hljs.COMMENT(\"--\", \"$\");\n    const STRING = {\n        className: \"string\",\n        variants: [\n            {\n                begin: /'/,\n                end: /'/,\n                contains: [\n                    {\n                        begin: /''/\n                    }\n                ]\n            }\n        ]\n    };\n    const QUOTED_IDENTIFIER = {\n        begin: /\"/,\n        end: /\"/,\n        contains: [\n            {\n                begin: /\"\"/\n            }\n        ]\n    };\n    const LITERALS = [\n        \"true\",\n        \"false\",\n        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.\n        // \"null\",\n        \"unknown\"\n    ];\n    const MULTI_WORD_TYPES = [\n        \"double precision\",\n        \"large object\",\n        \"with timezone\",\n        \"without timezone\"\n    ];\n    const TYPES = [\n        \"bigint\",\n        \"binary\",\n        \"blob\",\n        \"boolean\",\n        \"char\",\n        \"character\",\n        \"clob\",\n        \"date\",\n        \"dec\",\n        \"decfloat\",\n        \"decimal\",\n        \"float\",\n        \"int\",\n        \"integer\",\n        \"interval\",\n        \"nchar\",\n        \"nclob\",\n        \"national\",\n        \"numeric\",\n        \"real\",\n        \"row\",\n        \"smallint\",\n        \"time\",\n        \"timestamp\",\n        \"varchar\",\n        \"varying\",\n        \"varbinary\"\n    ];\n    const NON_RESERVED_WORDS = [\n        \"add\",\n        \"asc\",\n        \"collation\",\n        \"desc\",\n        \"final\",\n        \"first\",\n        \"last\",\n        \"view\"\n    ];\n    // https://jakewheat.github.io/sql-overview/sql-2016-foundation-grammar.html#reserved-word\n    const RESERVED_WORDS = [\n        \"abs\",\n        \"acos\",\n        \"all\",\n        \"allocate\",\n        \"alter\",\n        \"and\",\n        \"any\",\n        \"are\",\n        \"array\",\n        \"array_agg\",\n        \"array_max_cardinality\",\n        \"as\",\n        \"asensitive\",\n        \"asin\",\n        \"asymmetric\",\n        \"at\",\n        \"atan\",\n        \"atomic\",\n        \"authorization\",\n        \"avg\",\n        \"begin\",\n        \"begin_frame\",\n        \"begin_partition\",\n        \"between\",\n        \"bigint\",\n        \"binary\",\n        \"blob\",\n        \"boolean\",\n        \"both\",\n        \"by\",\n        \"call\",\n        \"called\",\n        \"cardinality\",\n        \"cascaded\",\n        \"case\",\n        \"cast\",\n        \"ceil\",\n        \"ceiling\",\n        \"char\",\n        \"char_length\",\n        \"character\",\n        \"character_length\",\n        \"check\",\n        \"classifier\",\n        \"clob\",\n        \"close\",\n        \"coalesce\",\n        \"collate\",\n        \"collect\",\n        \"column\",\n        \"commit\",\n        \"condition\",\n        \"connect\",\n        \"constraint\",\n        \"contains\",\n        \"convert\",\n        \"copy\",\n        \"corr\",\n        \"corresponding\",\n        \"cos\",\n        \"cosh\",\n        \"count\",\n        \"covar_pop\",\n        \"covar_samp\",\n        \"create\",\n        \"cross\",\n        \"cube\",\n        \"cume_dist\",\n        \"current\",\n        \"current_catalog\",\n        \"current_date\",\n        \"current_default_transform_group\",\n        \"current_path\",\n        \"current_role\",\n        \"current_row\",\n        \"current_schema\",\n        \"current_time\",\n        \"current_timestamp\",\n        \"current_path\",\n        \"current_role\",\n        \"current_transform_group_for_type\",\n        \"current_user\",\n        \"cursor\",\n        \"cycle\",\n        \"date\",\n        \"day\",\n        \"deallocate\",\n        \"dec\",\n        \"decimal\",\n        \"decfloat\",\n        \"declare\",\n        \"default\",\n        \"define\",\n        \"delete\",\n        \"dense_rank\",\n        \"deref\",\n        \"describe\",\n        \"deterministic\",\n        \"disconnect\",\n        \"distinct\",\n        \"double\",\n        \"drop\",\n        \"dynamic\",\n        \"each\",\n        \"element\",\n        \"else\",\n        \"empty\",\n        \"end\",\n        \"end_frame\",\n        \"end_partition\",\n        \"end-exec\",\n        \"equals\",\n        \"escape\",\n        \"every\",\n        \"except\",\n        \"exec\",\n        \"execute\",\n        \"exists\",\n        \"exp\",\n        \"external\",\n        \"extract\",\n        \"false\",\n        \"fetch\",\n        \"filter\",\n        \"first_value\",\n        \"float\",\n        \"floor\",\n        \"for\",\n        \"foreign\",\n        \"frame_row\",\n        \"free\",\n        \"from\",\n        \"full\",\n        \"function\",\n        \"fusion\",\n        \"get\",\n        \"global\",\n        \"grant\",\n        \"group\",\n        \"grouping\",\n        \"groups\",\n        \"having\",\n        \"hold\",\n        \"hour\",\n        \"identity\",\n        \"in\",\n        \"indicator\",\n        \"initial\",\n        \"inner\",\n        \"inout\",\n        \"insensitive\",\n        \"insert\",\n        \"int\",\n        \"integer\",\n        \"intersect\",\n        \"intersection\",\n        \"interval\",\n        \"into\",\n        \"is\",\n        \"join\",\n        \"json_array\",\n        \"json_arrayagg\",\n        \"json_exists\",\n        \"json_object\",\n        \"json_objectagg\",\n        \"json_query\",\n        \"json_table\",\n        \"json_table_primitive\",\n        \"json_value\",\n        \"lag\",\n        \"language\",\n        \"large\",\n        \"last_value\",\n        \"lateral\",\n        \"lead\",\n        \"leading\",\n        \"left\",\n        \"like\",\n        \"like_regex\",\n        \"listagg\",\n        \"ln\",\n        \"local\",\n        \"localtime\",\n        \"localtimestamp\",\n        \"log\",\n        \"log10\",\n        \"lower\",\n        \"match\",\n        \"match_number\",\n        \"match_recognize\",\n        \"matches\",\n        \"max\",\n        \"member\",\n        \"merge\",\n        \"method\",\n        \"min\",\n        \"minute\",\n        \"mod\",\n        \"modifies\",\n        \"module\",\n        \"month\",\n        \"multiset\",\n        \"national\",\n        \"natural\",\n        \"nchar\",\n        \"nclob\",\n        \"new\",\n        \"no\",\n        \"none\",\n        \"normalize\",\n        \"not\",\n        \"nth_value\",\n        \"ntile\",\n        \"null\",\n        \"nullif\",\n        \"numeric\",\n        \"octet_length\",\n        \"occurrences_regex\",\n        \"of\",\n        \"offset\",\n        \"old\",\n        \"omit\",\n        \"on\",\n        \"one\",\n        \"only\",\n        \"open\",\n        \"or\",\n        \"order\",\n        \"out\",\n        \"outer\",\n        \"over\",\n        \"overlaps\",\n        \"overlay\",\n        \"parameter\",\n        \"partition\",\n        \"pattern\",\n        \"per\",\n        \"percent\",\n        \"percent_rank\",\n        \"percentile_cont\",\n        \"percentile_disc\",\n        \"period\",\n        \"portion\",\n        \"position\",\n        \"position_regex\",\n        \"power\",\n        \"precedes\",\n        \"precision\",\n        \"prepare\",\n        \"primary\",\n        \"procedure\",\n        \"ptf\",\n        \"range\",\n        \"rank\",\n        \"reads\",\n        \"real\",\n        \"recursive\",\n        \"ref\",\n        \"references\",\n        \"referencing\",\n        \"regr_avgx\",\n        \"regr_avgy\",\n        \"regr_count\",\n        \"regr_intercept\",\n        \"regr_r2\",\n        \"regr_slope\",\n        \"regr_sxx\",\n        \"regr_sxy\",\n        \"regr_syy\",\n        \"release\",\n        \"result\",\n        \"return\",\n        \"returns\",\n        \"revoke\",\n        \"right\",\n        \"rollback\",\n        \"rollup\",\n        \"row\",\n        \"row_number\",\n        \"rows\",\n        \"running\",\n        \"savepoint\",\n        \"scope\",\n        \"scroll\",\n        \"search\",\n        \"second\",\n        \"seek\",\n        \"select\",\n        \"sensitive\",\n        \"session_user\",\n        \"set\",\n        \"show\",\n        \"similar\",\n        \"sin\",\n        \"sinh\",\n        \"skip\",\n        \"smallint\",\n        \"some\",\n        \"specific\",\n        \"specifictype\",\n        \"sql\",\n        \"sqlexception\",\n        \"sqlstate\",\n        \"sqlwarning\",\n        \"sqrt\",\n        \"start\",\n        \"static\",\n        \"stddev_pop\",\n        \"stddev_samp\",\n        \"submultiset\",\n        \"subset\",\n        \"substring\",\n        \"substring_regex\",\n        \"succeeds\",\n        \"sum\",\n        \"symmetric\",\n        \"system\",\n        \"system_time\",\n        \"system_user\",\n        \"table\",\n        \"tablesample\",\n        \"tan\",\n        \"tanh\",\n        \"then\",\n        \"time\",\n        \"timestamp\",\n        \"timezone_hour\",\n        \"timezone_minute\",\n        \"to\",\n        \"trailing\",\n        \"translate\",\n        \"translate_regex\",\n        \"translation\",\n        \"treat\",\n        \"trigger\",\n        \"trim\",\n        \"trim_array\",\n        \"true\",\n        \"truncate\",\n        \"uescape\",\n        \"union\",\n        \"unique\",\n        \"unknown\",\n        \"unnest\",\n        \"update   \",\n        \"upper\",\n        \"user\",\n        \"using\",\n        \"value\",\n        \"values\",\n        \"value_of\",\n        \"var_pop\",\n        \"var_samp\",\n        \"varbinary\",\n        \"varchar\",\n        \"varying\",\n        \"versioning\",\n        \"when\",\n        \"whenever\",\n        \"where\",\n        \"width_bucket\",\n        \"window\",\n        \"with\",\n        \"within\",\n        \"without\",\n        \"year\"\n    ];\n    // these are reserved words we have identified to be functions\n    // and should only be highlighted in a dispatch-like context\n    // ie, array_agg(...), etc.\n    const RESERVED_FUNCTIONS = [\n        \"abs\",\n        \"acos\",\n        \"array_agg\",\n        \"asin\",\n        \"atan\",\n        \"avg\",\n        \"cast\",\n        \"ceil\",\n        \"ceiling\",\n        \"coalesce\",\n        \"corr\",\n        \"cos\",\n        \"cosh\",\n        \"count\",\n        \"covar_pop\",\n        \"covar_samp\",\n        \"cume_dist\",\n        \"dense_rank\",\n        \"deref\",\n        \"element\",\n        \"exp\",\n        \"extract\",\n        \"first_value\",\n        \"floor\",\n        \"json_array\",\n        \"json_arrayagg\",\n        \"json_exists\",\n        \"json_object\",\n        \"json_objectagg\",\n        \"json_query\",\n        \"json_table\",\n        \"json_table_primitive\",\n        \"json_value\",\n        \"lag\",\n        \"last_value\",\n        \"lead\",\n        \"listagg\",\n        \"ln\",\n        \"log\",\n        \"log10\",\n        \"lower\",\n        \"max\",\n        \"min\",\n        \"mod\",\n        \"nth_value\",\n        \"ntile\",\n        \"nullif\",\n        \"percent_rank\",\n        \"percentile_cont\",\n        \"percentile_disc\",\n        \"position\",\n        \"position_regex\",\n        \"power\",\n        \"rank\",\n        \"regr_avgx\",\n        \"regr_avgy\",\n        \"regr_count\",\n        \"regr_intercept\",\n        \"regr_r2\",\n        \"regr_slope\",\n        \"regr_sxx\",\n        \"regr_sxy\",\n        \"regr_syy\",\n        \"row_number\",\n        \"sin\",\n        \"sinh\",\n        \"sqrt\",\n        \"stddev_pop\",\n        \"stddev_samp\",\n        \"substring\",\n        \"substring_regex\",\n        \"sum\",\n        \"tan\",\n        \"tanh\",\n        \"translate\",\n        \"translate_regex\",\n        \"treat\",\n        \"trim\",\n        \"trim_array\",\n        \"unnest\",\n        \"upper\",\n        \"value_of\",\n        \"var_pop\",\n        \"var_samp\",\n        \"width_bucket\"\n    ];\n    // these functions can\n    const POSSIBLE_WITHOUT_PARENS = [\n        \"current_catalog\",\n        \"current_date\",\n        \"current_default_transform_group\",\n        \"current_path\",\n        \"current_role\",\n        \"current_schema\",\n        \"current_transform_group_for_type\",\n        \"current_user\",\n        \"session_user\",\n        \"system_time\",\n        \"system_user\",\n        \"current_time\",\n        \"localtime\",\n        \"current_timestamp\",\n        \"localtimestamp\"\n    ];\n    // those exist to boost relevance making these very\n    // \"SQL like\" keyword combos worth +1 extra relevance\n    const COMBOS = [\n        \"create table\",\n        \"insert into\",\n        \"primary key\",\n        \"foreign key\",\n        \"not null\",\n        \"alter table\",\n        \"add constraint\",\n        \"grouping sets\",\n        \"on overflow\",\n        \"character set\",\n        \"respect nulls\",\n        \"ignore nulls\",\n        \"nulls first\",\n        \"nulls last\",\n        \"depth first\",\n        \"breadth first\"\n    ];\n    const FUNCTIONS = RESERVED_FUNCTIONS;\n    const KEYWORDS = [\n        ...RESERVED_WORDS,\n        ...NON_RESERVED_WORDS\n    ].filter((keyword)=>{\n        return !RESERVED_FUNCTIONS.includes(keyword);\n    });\n    const VARIABLE = {\n        className: \"variable\",\n        begin: /@[a-z0-9]+/\n    };\n    const OPERATOR = {\n        className: \"operator\",\n        begin: /[-+*/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,\n        relevance: 0\n    };\n    const FUNCTION_CALL = {\n        begin: concat(/\\b/, either(...FUNCTIONS), /\\s*\\(/),\n        keywords: {\n            built_in: FUNCTIONS.join(\" \")\n        }\n    };\n    // keywords with less than 3 letters are reduced in relevancy\n    function reduceRelevancy(list, { exceptions, when } = {}) {\n        const qualifyFn = when;\n        exceptions = exceptions || [];\n        return list.map((item)=>{\n            if (item.match(/\\|\\d+$/) || exceptions.includes(item)) {\n                return item;\n            } else if (qualifyFn(item)) {\n                return `${item}|0`;\n            } else {\n                return item;\n            }\n        });\n    }\n    return {\n        name: \"SQL\",\n        case_insensitive: true,\n        // does not include {} or HTML tags `</`\n        illegal: /[{}]|<\\//,\n        keywords: {\n            $pattern: /\\b[\\w\\.]+/,\n            keyword: reduceRelevancy(KEYWORDS, {\n                when: (x)=>x.length < 3\n            }).join(\" \"),\n            literal: LITERALS.join(\" \"),\n            type: TYPES.join(\" \"),\n            built_in: POSSIBLE_WITHOUT_PARENS.join(\" \")\n        },\n        contains: [\n            {\n                begin: either(...COMBOS),\n                keywords: {\n                    $pattern: /[\\w\\.]+/,\n                    keyword: KEYWORDS.concat(COMBOS).join(\" \"),\n                    literal: LITERALS.join(\" \"),\n                    type: TYPES.join(\" \")\n                }\n            },\n            {\n                className: \"type\",\n                begin: either(...MULTI_WORD_TYPES)\n            },\n            FUNCTION_CALL,\n            VARIABLE,\n            STRING,\n            QUOTED_IDENTIFIER,\n            hljs.C_NUMBER_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            COMMENT_MODE,\n            OPERATOR\n        ]\n    };\n}\nmodule.exports = sql;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3NxbC5qcz85NjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogKi9cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzb3VyY2UocmUpIHtcbiAgaWYgKCFyZSkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgcmUgPT09IFwic3RyaW5nXCIpIHJldHVybiByZTtcblxuICByZXR1cm4gcmUuc291cmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlaXRoZXIoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSAnKCcgKyBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKlxuIExhbmd1YWdlOiBTUUxcbiBXZWJzaXRlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TUUxcbiBDYXRlZ29yeTogY29tbW9uLCBkYXRhYmFzZVxuICovXG5cbmZ1bmN0aW9uIHNxbChobGpzKSB7XG4gIGNvbnN0IENPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnLS0nLCAnJCcpO1xuICBjb25zdCBTVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICBlbmQ6IC8nLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7YmVnaW46IC8nJy8gfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBjb25zdCBRVU9URURfSURFTlRJRklFUiA9IHtcbiAgICBiZWdpbjogL1wiLyxcbiAgICBlbmQ6IC9cIi8sXG4gICAgY29udGFpbnM6IFsgeyBiZWdpbjogL1wiXCIvIH0gXVxuICB9O1xuXG4gIGNvbnN0IExJVEVSQUxTID0gW1xuICAgIFwidHJ1ZVwiLFxuICAgIFwiZmFsc2VcIixcbiAgICAvLyBOb3Qgc3VyZSBpdCdzIGNvcnJlY3QgdG8gY2FsbCBOVUxMIGxpdGVyYWwsIGFuZCBjbGF1c2VzIGxpa2UgSVMgW05PVF0gTlVMTCBsb29rIHN0cmFuZ2UgdGhhdCB3YXkuXG4gICAgLy8gXCJudWxsXCIsXG4gICAgXCJ1bmtub3duXCJcbiAgXTtcblxuICBjb25zdCBNVUxUSV9XT1JEX1RZUEVTID0gW1xuICAgIFwiZG91YmxlIHByZWNpc2lvblwiLFxuICAgIFwibGFyZ2Ugb2JqZWN0XCIsXG4gICAgXCJ3aXRoIHRpbWV6b25lXCIsXG4gICAgXCJ3aXRob3V0IHRpbWV6b25lXCJcbiAgXTtcblxuICBjb25zdCBUWVBFUyA9IFtcbiAgICAnYmlnaW50JyxcbiAgICAnYmluYXJ5JyxcbiAgICAnYmxvYicsXG4gICAgJ2Jvb2xlYW4nLFxuICAgICdjaGFyJyxcbiAgICAnY2hhcmFjdGVyJyxcbiAgICAnY2xvYicsXG4gICAgJ2RhdGUnLFxuICAgICdkZWMnLFxuICAgICdkZWNmbG9hdCcsXG4gICAgJ2RlY2ltYWwnLFxuICAgICdmbG9hdCcsXG4gICAgJ2ludCcsXG4gICAgJ2ludGVnZXInLFxuICAgICdpbnRlcnZhbCcsXG4gICAgJ25jaGFyJyxcbiAgICAnbmNsb2InLFxuICAgICduYXRpb25hbCcsXG4gICAgJ251bWVyaWMnLFxuICAgICdyZWFsJyxcbiAgICAncm93JyxcbiAgICAnc21hbGxpbnQnLFxuICAgICd0aW1lJyxcbiAgICAndGltZXN0YW1wJyxcbiAgICAndmFyY2hhcicsXG4gICAgJ3ZhcnlpbmcnLCAvLyBtb2RpZmllciAoY2hhcmFjdGVyIHZhcnlpbmcpXG4gICAgJ3ZhcmJpbmFyeSdcbiAgXTtcblxuICBjb25zdCBOT05fUkVTRVJWRURfV09SRFMgPSBbXG4gICAgXCJhZGRcIixcbiAgICBcImFzY1wiLFxuICAgIFwiY29sbGF0aW9uXCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJmaW5hbFwiLFxuICAgIFwiZmlyc3RcIixcbiAgICBcImxhc3RcIixcbiAgICBcInZpZXdcIlxuICBdO1xuXG4gIC8vIGh0dHBzOi8vamFrZXdoZWF0LmdpdGh1Yi5pby9zcWwtb3ZlcnZpZXcvc3FsLTIwMTYtZm91bmRhdGlvbi1ncmFtbWFyLmh0bWwjcmVzZXJ2ZWQtd29yZFxuICBjb25zdCBSRVNFUlZFRF9XT1JEUyA9IFtcbiAgICBcImFic1wiLFxuICAgIFwiYWNvc1wiLFxuICAgIFwiYWxsXCIsXG4gICAgXCJhbGxvY2F0ZVwiLFxuICAgIFwiYWx0ZXJcIixcbiAgICBcImFuZFwiLFxuICAgIFwiYW55XCIsXG4gICAgXCJhcmVcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJhcnJheV9hZ2dcIixcbiAgICBcImFycmF5X21heF9jYXJkaW5hbGl0eVwiLFxuICAgIFwiYXNcIixcbiAgICBcImFzZW5zaXRpdmVcIixcbiAgICBcImFzaW5cIixcbiAgICBcImFzeW1tZXRyaWNcIixcbiAgICBcImF0XCIsXG4gICAgXCJhdGFuXCIsXG4gICAgXCJhdG9taWNcIixcbiAgICBcImF1dGhvcml6YXRpb25cIixcbiAgICBcImF2Z1wiLFxuICAgIFwiYmVnaW5cIixcbiAgICBcImJlZ2luX2ZyYW1lXCIsXG4gICAgXCJiZWdpbl9wYXJ0aXRpb25cIixcbiAgICBcImJldHdlZW5cIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwiYmluYXJ5XCIsXG4gICAgXCJibG9iXCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJib3RoXCIsXG4gICAgXCJieVwiLFxuICAgIFwiY2FsbFwiLFxuICAgIFwiY2FsbGVkXCIsXG4gICAgXCJjYXJkaW5hbGl0eVwiLFxuICAgIFwiY2FzY2FkZWRcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNhc3RcIixcbiAgICBcImNlaWxcIixcbiAgICBcImNlaWxpbmdcIixcbiAgICBcImNoYXJcIixcbiAgICBcImNoYXJfbGVuZ3RoXCIsXG4gICAgXCJjaGFyYWN0ZXJcIixcbiAgICBcImNoYXJhY3Rlcl9sZW5ndGhcIixcbiAgICBcImNoZWNrXCIsXG4gICAgXCJjbGFzc2lmaWVyXCIsXG4gICAgXCJjbG9iXCIsXG4gICAgXCJjbG9zZVwiLFxuICAgIFwiY29hbGVzY2VcIixcbiAgICBcImNvbGxhdGVcIixcbiAgICBcImNvbGxlY3RcIixcbiAgICBcImNvbHVtblwiLFxuICAgIFwiY29tbWl0XCIsXG4gICAgXCJjb25kaXRpb25cIixcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbnN0cmFpbnRcIixcbiAgICBcImNvbnRhaW5zXCIsXG4gICAgXCJjb252ZXJ0XCIsXG4gICAgXCJjb3B5XCIsXG4gICAgXCJjb3JyXCIsXG4gICAgXCJjb3JyZXNwb25kaW5nXCIsXG4gICAgXCJjb3NcIixcbiAgICBcImNvc2hcIixcbiAgICBcImNvdW50XCIsXG4gICAgXCJjb3Zhcl9wb3BcIixcbiAgICBcImNvdmFyX3NhbXBcIixcbiAgICBcImNyZWF0ZVwiLFxuICAgIFwiY3Jvc3NcIixcbiAgICBcImN1YmVcIixcbiAgICBcImN1bWVfZGlzdFwiLFxuICAgIFwiY3VycmVudFwiLFxuICAgIFwiY3VycmVudF9jYXRhbG9nXCIsXG4gICAgXCJjdXJyZW50X2RhdGVcIixcbiAgICBcImN1cnJlbnRfZGVmYXVsdF90cmFuc2Zvcm1fZ3JvdXBcIixcbiAgICBcImN1cnJlbnRfcGF0aFwiLFxuICAgIFwiY3VycmVudF9yb2xlXCIsXG4gICAgXCJjdXJyZW50X3Jvd1wiLFxuICAgIFwiY3VycmVudF9zY2hlbWFcIixcbiAgICBcImN1cnJlbnRfdGltZVwiLFxuICAgIFwiY3VycmVudF90aW1lc3RhbXBcIixcbiAgICBcImN1cnJlbnRfcGF0aFwiLFxuICAgIFwiY3VycmVudF9yb2xlXCIsXG4gICAgXCJjdXJyZW50X3RyYW5zZm9ybV9ncm91cF9mb3JfdHlwZVwiLFxuICAgIFwiY3VycmVudF91c2VyXCIsXG4gICAgXCJjdXJzb3JcIixcbiAgICBcImN5Y2xlXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJkYXlcIixcbiAgICBcImRlYWxsb2NhdGVcIixcbiAgICBcImRlY1wiLFxuICAgIFwiZGVjaW1hbFwiLFxuICAgIFwiZGVjZmxvYXRcIixcbiAgICBcImRlY2xhcmVcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlZmluZVwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkZW5zZV9yYW5rXCIsXG4gICAgXCJkZXJlZlwiLFxuICAgIFwiZGVzY3JpYmVcIixcbiAgICBcImRldGVybWluaXN0aWNcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc3RpbmN0XCIsXG4gICAgXCJkb3VibGVcIixcbiAgICBcImRyb3BcIixcbiAgICBcImR5bmFtaWNcIixcbiAgICBcImVhY2hcIixcbiAgICBcImVsZW1lbnRcIixcbiAgICBcImVsc2VcIixcbiAgICBcImVtcHR5XCIsXG4gICAgXCJlbmRcIixcbiAgICBcImVuZF9mcmFtZVwiLFxuICAgIFwiZW5kX3BhcnRpdGlvblwiLFxuICAgIFwiZW5kLWV4ZWNcIixcbiAgICBcImVxdWFsc1wiLFxuICAgIFwiZXNjYXBlXCIsXG4gICAgXCJldmVyeVwiLFxuICAgIFwiZXhjZXB0XCIsXG4gICAgXCJleGVjXCIsXG4gICAgXCJleGVjdXRlXCIsXG4gICAgXCJleGlzdHNcIixcbiAgICBcImV4cFwiLFxuICAgIFwiZXh0ZXJuYWxcIixcbiAgICBcImV4dHJhY3RcIixcbiAgICBcImZhbHNlXCIsXG4gICAgXCJmZXRjaFwiLFxuICAgIFwiZmlsdGVyXCIsXG4gICAgXCJmaXJzdF92YWx1ZVwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImZsb29yXCIsXG4gICAgXCJmb3JcIixcbiAgICBcImZvcmVpZ25cIixcbiAgICBcImZyYW1lX3Jvd1wiLFxuICAgIFwiZnJlZVwiLFxuICAgIFwiZnJvbVwiLFxuICAgIFwiZnVsbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcImZ1c2lvblwiLFxuICAgIFwiZ2V0XCIsXG4gICAgXCJnbG9iYWxcIixcbiAgICBcImdyYW50XCIsXG4gICAgXCJncm91cFwiLFxuICAgIFwiZ3JvdXBpbmdcIixcbiAgICBcImdyb3Vwc1wiLFxuICAgIFwiaGF2aW5nXCIsXG4gICAgXCJob2xkXCIsXG4gICAgXCJob3VyXCIsXG4gICAgXCJpZGVudGl0eVwiLFxuICAgIFwiaW5cIixcbiAgICBcImluZGljYXRvclwiLFxuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwiaW5uZXJcIixcbiAgICBcImlub3V0XCIsXG4gICAgXCJpbnNlbnNpdGl2ZVwiLFxuICAgIFwiaW5zZXJ0XCIsXG4gICAgXCJpbnRcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImludGVyc2VjdFwiLFxuICAgIFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgXCJpbnRlcnZhbFwiLFxuICAgIFwiaW50b1wiLFxuICAgIFwiaXNcIixcbiAgICBcImpvaW5cIixcbiAgICBcImpzb25fYXJyYXlcIixcbiAgICBcImpzb25fYXJyYXlhZ2dcIixcbiAgICBcImpzb25fZXhpc3RzXCIsXG4gICAgXCJqc29uX29iamVjdFwiLFxuICAgIFwianNvbl9vYmplY3RhZ2dcIixcbiAgICBcImpzb25fcXVlcnlcIixcbiAgICBcImpzb25fdGFibGVcIixcbiAgICBcImpzb25fdGFibGVfcHJpbWl0aXZlXCIsXG4gICAgXCJqc29uX3ZhbHVlXCIsXG4gICAgXCJsYWdcIixcbiAgICBcImxhbmd1YWdlXCIsXG4gICAgXCJsYXJnZVwiLFxuICAgIFwibGFzdF92YWx1ZVwiLFxuICAgIFwibGF0ZXJhbFwiLFxuICAgIFwibGVhZFwiLFxuICAgIFwibGVhZGluZ1wiLFxuICAgIFwibGVmdFwiLFxuICAgIFwibGlrZVwiLFxuICAgIFwibGlrZV9yZWdleFwiLFxuICAgIFwibGlzdGFnZ1wiLFxuICAgIFwibG5cIixcbiAgICBcImxvY2FsXCIsXG4gICAgXCJsb2NhbHRpbWVcIixcbiAgICBcImxvY2FsdGltZXN0YW1wXCIsXG4gICAgXCJsb2dcIixcbiAgICBcImxvZzEwXCIsXG4gICAgXCJsb3dlclwiLFxuICAgIFwibWF0Y2hcIixcbiAgICBcIm1hdGNoX251bWJlclwiLFxuICAgIFwibWF0Y2hfcmVjb2duaXplXCIsXG4gICAgXCJtYXRjaGVzXCIsXG4gICAgXCJtYXhcIixcbiAgICBcIm1lbWJlclwiLFxuICAgIFwibWVyZ2VcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwibWluXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcIm1vZFwiLFxuICAgIFwibW9kaWZpZXNcIixcbiAgICBcIm1vZHVsZVwiLFxuICAgIFwibW9udGhcIixcbiAgICBcIm11bHRpc2V0XCIsXG4gICAgXCJuYXRpb25hbFwiLFxuICAgIFwibmF0dXJhbFwiLFxuICAgIFwibmNoYXJcIixcbiAgICBcIm5jbG9iXCIsXG4gICAgXCJuZXdcIixcbiAgICBcIm5vXCIsXG4gICAgXCJub25lXCIsXG4gICAgXCJub3JtYWxpemVcIixcbiAgICBcIm5vdFwiLFxuICAgIFwibnRoX3ZhbHVlXCIsXG4gICAgXCJudGlsZVwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwibnVsbGlmXCIsXG4gICAgXCJudW1lcmljXCIsXG4gICAgXCJvY3RldF9sZW5ndGhcIixcbiAgICBcIm9jY3VycmVuY2VzX3JlZ2V4XCIsXG4gICAgXCJvZlwiLFxuICAgIFwib2Zmc2V0XCIsXG4gICAgXCJvbGRcIixcbiAgICBcIm9taXRcIixcbiAgICBcIm9uXCIsXG4gICAgXCJvbmVcIixcbiAgICBcIm9ubHlcIixcbiAgICBcIm9wZW5cIixcbiAgICBcIm9yXCIsXG4gICAgXCJvcmRlclwiLFxuICAgIFwib3V0XCIsXG4gICAgXCJvdXRlclwiLFxuICAgIFwib3ZlclwiLFxuICAgIFwib3ZlcmxhcHNcIixcbiAgICBcIm92ZXJsYXlcIixcbiAgICBcInBhcmFtZXRlclwiLFxuICAgIFwicGFydGl0aW9uXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJwZXJcIixcbiAgICBcInBlcmNlbnRcIixcbiAgICBcInBlcmNlbnRfcmFua1wiLFxuICAgIFwicGVyY2VudGlsZV9jb250XCIsXG4gICAgXCJwZXJjZW50aWxlX2Rpc2NcIixcbiAgICBcInBlcmlvZFwiLFxuICAgIFwicG9ydGlvblwiLFxuICAgIFwicG9zaXRpb25cIixcbiAgICBcInBvc2l0aW9uX3JlZ2V4XCIsXG4gICAgXCJwb3dlclwiLFxuICAgIFwicHJlY2VkZXNcIixcbiAgICBcInByZWNpc2lvblwiLFxuICAgIFwicHJlcGFyZVwiLFxuICAgIFwicHJpbWFyeVwiLFxuICAgIFwicHJvY2VkdXJlXCIsXG4gICAgXCJwdGZcIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJyYW5rXCIsXG4gICAgXCJyZWFkc1wiLFxuICAgIFwicmVhbFwiLFxuICAgIFwicmVjdXJzaXZlXCIsXG4gICAgXCJyZWZcIixcbiAgICBcInJlZmVyZW5jZXNcIixcbiAgICBcInJlZmVyZW5jaW5nXCIsXG4gICAgXCJyZWdyX2F2Z3hcIixcbiAgICBcInJlZ3JfYXZneVwiLFxuICAgIFwicmVncl9jb3VudFwiLFxuICAgIFwicmVncl9pbnRlcmNlcHRcIixcbiAgICBcInJlZ3JfcjJcIixcbiAgICBcInJlZ3Jfc2xvcGVcIixcbiAgICBcInJlZ3Jfc3h4XCIsXG4gICAgXCJyZWdyX3N4eVwiLFxuICAgIFwicmVncl9zeXlcIixcbiAgICBcInJlbGVhc2VcIixcbiAgICBcInJlc3VsdFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJyZXR1cm5zXCIsXG4gICAgXCJyZXZva2VcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJyb2xsYmFja1wiLFxuICAgIFwicm9sbHVwXCIsXG4gICAgXCJyb3dcIixcbiAgICBcInJvd19udW1iZXJcIixcbiAgICBcInJvd3NcIixcbiAgICBcInJ1bm5pbmdcIixcbiAgICBcInNhdmVwb2ludFwiLFxuICAgIFwic2NvcGVcIixcbiAgICBcInNjcm9sbFwiLFxuICAgIFwic2VhcmNoXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcInNlZWtcIixcbiAgICBcInNlbGVjdFwiLFxuICAgIFwic2Vuc2l0aXZlXCIsXG4gICAgXCJzZXNzaW9uX3VzZXJcIixcbiAgICBcInNldFwiLFxuICAgIFwic2hvd1wiLFxuICAgIFwic2ltaWxhclwiLFxuICAgIFwic2luXCIsXG4gICAgXCJzaW5oXCIsXG4gICAgXCJza2lwXCIsXG4gICAgXCJzbWFsbGludFwiLFxuICAgIFwic29tZVwiLFxuICAgIFwic3BlY2lmaWNcIixcbiAgICBcInNwZWNpZmljdHlwZVwiLFxuICAgIFwic3FsXCIsXG4gICAgXCJzcWxleGNlcHRpb25cIixcbiAgICBcInNxbHN0YXRlXCIsXG4gICAgXCJzcWx3YXJuaW5nXCIsXG4gICAgXCJzcXJ0XCIsXG4gICAgXCJzdGFydFwiLFxuICAgIFwic3RhdGljXCIsXG4gICAgXCJzdGRkZXZfcG9wXCIsXG4gICAgXCJzdGRkZXZfc2FtcFwiLFxuICAgIFwic3VibXVsdGlzZXRcIixcbiAgICBcInN1YnNldFwiLFxuICAgIFwic3Vic3RyaW5nXCIsXG4gICAgXCJzdWJzdHJpbmdfcmVnZXhcIixcbiAgICBcInN1Y2NlZWRzXCIsXG4gICAgXCJzdW1cIixcbiAgICBcInN5bW1ldHJpY1wiLFxuICAgIFwic3lzdGVtXCIsXG4gICAgXCJzeXN0ZW1fdGltZVwiLFxuICAgIFwic3lzdGVtX3VzZXJcIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0YWJsZXNhbXBsZVwiLFxuICAgIFwidGFuXCIsXG4gICAgXCJ0YW5oXCIsXG4gICAgXCJ0aGVuXCIsXG4gICAgXCJ0aW1lXCIsXG4gICAgXCJ0aW1lc3RhbXBcIixcbiAgICBcInRpbWV6b25lX2hvdXJcIixcbiAgICBcInRpbWV6b25lX21pbnV0ZVwiLFxuICAgIFwidG9cIixcbiAgICBcInRyYWlsaW5nXCIsXG4gICAgXCJ0cmFuc2xhdGVcIixcbiAgICBcInRyYW5zbGF0ZV9yZWdleFwiLFxuICAgIFwidHJhbnNsYXRpb25cIixcbiAgICBcInRyZWF0XCIsXG4gICAgXCJ0cmlnZ2VyXCIsXG4gICAgXCJ0cmltXCIsXG4gICAgXCJ0cmltX2FycmF5XCIsXG4gICAgXCJ0cnVlXCIsXG4gICAgXCJ0cnVuY2F0ZVwiLFxuICAgIFwidWVzY2FwZVwiLFxuICAgIFwidW5pb25cIixcbiAgICBcInVuaXF1ZVwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwidW5uZXN0XCIsXG4gICAgXCJ1cGRhdGUgICBcIixcbiAgICBcInVwcGVyXCIsXG4gICAgXCJ1c2VyXCIsXG4gICAgXCJ1c2luZ1wiLFxuICAgIFwidmFsdWVcIixcbiAgICBcInZhbHVlc1wiLFxuICAgIFwidmFsdWVfb2ZcIixcbiAgICBcInZhcl9wb3BcIixcbiAgICBcInZhcl9zYW1wXCIsXG4gICAgXCJ2YXJiaW5hcnlcIixcbiAgICBcInZhcmNoYXJcIixcbiAgICBcInZhcnlpbmdcIixcbiAgICBcInZlcnNpb25pbmdcIixcbiAgICBcIndoZW5cIixcbiAgICBcIndoZW5ldmVyXCIsXG4gICAgXCJ3aGVyZVwiLFxuICAgIFwid2lkdGhfYnVja2V0XCIsXG4gICAgXCJ3aW5kb3dcIixcbiAgICBcIndpdGhcIixcbiAgICBcIndpdGhpblwiLFxuICAgIFwid2l0aG91dFwiLFxuICAgIFwieWVhclwiLFxuICBdO1xuXG4gIC8vIHRoZXNlIGFyZSByZXNlcnZlZCB3b3JkcyB3ZSBoYXZlIGlkZW50aWZpZWQgdG8gYmUgZnVuY3Rpb25zXG4gIC8vIGFuZCBzaG91bGQgb25seSBiZSBoaWdobGlnaHRlZCBpbiBhIGRpc3BhdGNoLWxpa2UgY29udGV4dFxuICAvLyBpZSwgYXJyYXlfYWdnKC4uLiksIGV0Yy5cbiAgY29uc3QgUkVTRVJWRURfRlVOQ1RJT05TID0gW1xuICAgIFwiYWJzXCIsXG4gICAgXCJhY29zXCIsXG4gICAgXCJhcnJheV9hZ2dcIixcbiAgICBcImFzaW5cIixcbiAgICBcImF0YW5cIixcbiAgICBcImF2Z1wiLFxuICAgIFwiY2FzdFwiLFxuICAgIFwiY2VpbFwiLFxuICAgIFwiY2VpbGluZ1wiLFxuICAgIFwiY29hbGVzY2VcIixcbiAgICBcImNvcnJcIixcbiAgICBcImNvc1wiLFxuICAgIFwiY29zaFwiLFxuICAgIFwiY291bnRcIixcbiAgICBcImNvdmFyX3BvcFwiLFxuICAgIFwiY292YXJfc2FtcFwiLFxuICAgIFwiY3VtZV9kaXN0XCIsXG4gICAgXCJkZW5zZV9yYW5rXCIsXG4gICAgXCJkZXJlZlwiLFxuICAgIFwiZWxlbWVudFwiLFxuICAgIFwiZXhwXCIsXG4gICAgXCJleHRyYWN0XCIsXG4gICAgXCJmaXJzdF92YWx1ZVwiLFxuICAgIFwiZmxvb3JcIixcbiAgICBcImpzb25fYXJyYXlcIixcbiAgICBcImpzb25fYXJyYXlhZ2dcIixcbiAgICBcImpzb25fZXhpc3RzXCIsXG4gICAgXCJqc29uX29iamVjdFwiLFxuICAgIFwianNvbl9vYmplY3RhZ2dcIixcbiAgICBcImpzb25fcXVlcnlcIixcbiAgICBcImpzb25fdGFibGVcIixcbiAgICBcImpzb25fdGFibGVfcHJpbWl0aXZlXCIsXG4gICAgXCJqc29uX3ZhbHVlXCIsXG4gICAgXCJsYWdcIixcbiAgICBcImxhc3RfdmFsdWVcIixcbiAgICBcImxlYWRcIixcbiAgICBcImxpc3RhZ2dcIixcbiAgICBcImxuXCIsXG4gICAgXCJsb2dcIixcbiAgICBcImxvZzEwXCIsXG4gICAgXCJsb3dlclwiLFxuICAgIFwibWF4XCIsXG4gICAgXCJtaW5cIixcbiAgICBcIm1vZFwiLFxuICAgIFwibnRoX3ZhbHVlXCIsXG4gICAgXCJudGlsZVwiLFxuICAgIFwibnVsbGlmXCIsXG4gICAgXCJwZXJjZW50X3JhbmtcIixcbiAgICBcInBlcmNlbnRpbGVfY29udFwiLFxuICAgIFwicGVyY2VudGlsZV9kaXNjXCIsXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIFwicG9zaXRpb25fcmVnZXhcIixcbiAgICBcInBvd2VyXCIsXG4gICAgXCJyYW5rXCIsXG4gICAgXCJyZWdyX2F2Z3hcIixcbiAgICBcInJlZ3JfYXZneVwiLFxuICAgIFwicmVncl9jb3VudFwiLFxuICAgIFwicmVncl9pbnRlcmNlcHRcIixcbiAgICBcInJlZ3JfcjJcIixcbiAgICBcInJlZ3Jfc2xvcGVcIixcbiAgICBcInJlZ3Jfc3h4XCIsXG4gICAgXCJyZWdyX3N4eVwiLFxuICAgIFwicmVncl9zeXlcIixcbiAgICBcInJvd19udW1iZXJcIixcbiAgICBcInNpblwiLFxuICAgIFwic2luaFwiLFxuICAgIFwic3FydFwiLFxuICAgIFwic3RkZGV2X3BvcFwiLFxuICAgIFwic3RkZGV2X3NhbXBcIixcbiAgICBcInN1YnN0cmluZ1wiLFxuICAgIFwic3Vic3RyaW5nX3JlZ2V4XCIsXG4gICAgXCJzdW1cIixcbiAgICBcInRhblwiLFxuICAgIFwidGFuaFwiLFxuICAgIFwidHJhbnNsYXRlXCIsXG4gICAgXCJ0cmFuc2xhdGVfcmVnZXhcIixcbiAgICBcInRyZWF0XCIsXG4gICAgXCJ0cmltXCIsXG4gICAgXCJ0cmltX2FycmF5XCIsXG4gICAgXCJ1bm5lc3RcIixcbiAgICBcInVwcGVyXCIsXG4gICAgXCJ2YWx1ZV9vZlwiLFxuICAgIFwidmFyX3BvcFwiLFxuICAgIFwidmFyX3NhbXBcIixcbiAgICBcIndpZHRoX2J1Y2tldFwiLFxuICBdO1xuXG4gIC8vIHRoZXNlIGZ1bmN0aW9ucyBjYW5cbiAgY29uc3QgUE9TU0lCTEVfV0lUSE9VVF9QQVJFTlMgPSBbXG4gICAgXCJjdXJyZW50X2NhdGFsb2dcIixcbiAgICBcImN1cnJlbnRfZGF0ZVwiLFxuICAgIFwiY3VycmVudF9kZWZhdWx0X3RyYW5zZm9ybV9ncm91cFwiLFxuICAgIFwiY3VycmVudF9wYXRoXCIsXG4gICAgXCJjdXJyZW50X3JvbGVcIixcbiAgICBcImN1cnJlbnRfc2NoZW1hXCIsXG4gICAgXCJjdXJyZW50X3RyYW5zZm9ybV9ncm91cF9mb3JfdHlwZVwiLFxuICAgIFwiY3VycmVudF91c2VyXCIsXG4gICAgXCJzZXNzaW9uX3VzZXJcIixcbiAgICBcInN5c3RlbV90aW1lXCIsXG4gICAgXCJzeXN0ZW1fdXNlclwiLFxuICAgIFwiY3VycmVudF90aW1lXCIsXG4gICAgXCJsb2NhbHRpbWVcIixcbiAgICBcImN1cnJlbnRfdGltZXN0YW1wXCIsXG4gICAgXCJsb2NhbHRpbWVzdGFtcFwiXG4gIF07XG5cbiAgLy8gdGhvc2UgZXhpc3QgdG8gYm9vc3QgcmVsZXZhbmNlIG1ha2luZyB0aGVzZSB2ZXJ5XG4gIC8vIFwiU1FMIGxpa2VcIiBrZXl3b3JkIGNvbWJvcyB3b3J0aCArMSBleHRyYSByZWxldmFuY2VcbiAgY29uc3QgQ09NQk9TID0gW1xuICAgIFwiY3JlYXRlIHRhYmxlXCIsXG4gICAgXCJpbnNlcnQgaW50b1wiLFxuICAgIFwicHJpbWFyeSBrZXlcIixcbiAgICBcImZvcmVpZ24ga2V5XCIsXG4gICAgXCJub3QgbnVsbFwiLFxuICAgIFwiYWx0ZXIgdGFibGVcIixcbiAgICBcImFkZCBjb25zdHJhaW50XCIsXG4gICAgXCJncm91cGluZyBzZXRzXCIsXG4gICAgXCJvbiBvdmVyZmxvd1wiLFxuICAgIFwiY2hhcmFjdGVyIHNldFwiLFxuICAgIFwicmVzcGVjdCBudWxsc1wiLFxuICAgIFwiaWdub3JlIG51bGxzXCIsXG4gICAgXCJudWxscyBmaXJzdFwiLFxuICAgIFwibnVsbHMgbGFzdFwiLFxuICAgIFwiZGVwdGggZmlyc3RcIixcbiAgICBcImJyZWFkdGggZmlyc3RcIlxuICBdO1xuXG4gIGNvbnN0IEZVTkNUSU9OUyA9IFJFU0VSVkVEX0ZVTkNUSU9OUztcblxuICBjb25zdCBLRVlXT1JEUyA9IFsuLi5SRVNFUlZFRF9XT1JEUywgLi4uTk9OX1JFU0VSVkVEX1dPUkRTXS5maWx0ZXIoKGtleXdvcmQpID0+IHtcbiAgICByZXR1cm4gIVJFU0VSVkVEX0ZVTkNUSU9OUy5pbmNsdWRlcyhrZXl3b3JkKTtcbiAgfSk7XG5cbiAgY29uc3QgVkFSSUFCTEUgPSB7XG4gICAgY2xhc3NOYW1lOiBcInZhcmlhYmxlXCIsXG4gICAgYmVnaW46IC9AW2EtejAtOV0rLyxcbiAgfTtcblxuICBjb25zdCBPUEVSQVRPUiA9IHtcbiAgICBjbGFzc05hbWU6IFwib3BlcmF0b3JcIixcbiAgICBiZWdpbjogL1stKyovPSVefl18JiY/fFxcfFxcfD98IT0/fDwoPzo9Pj98PHw+KT98Pls+PV0/LyxcbiAgICByZWxldmFuY2U6IDAsXG4gIH07XG5cbiAgY29uc3QgRlVOQ1RJT05fQ0FMTCA9IHtcbiAgICBiZWdpbjogY29uY2F0KC9cXGIvLCBlaXRoZXIoLi4uRlVOQ1RJT05TKSwgL1xccypcXCgvKSxcbiAgICBrZXl3b3Jkczoge1xuICAgICAgYnVpbHRfaW46IEZVTkNUSU9OUy5qb2luKFwiIFwiKVxuICAgIH1cbiAgfTtcblxuICAvLyBrZXl3b3JkcyB3aXRoIGxlc3MgdGhhbiAzIGxldHRlcnMgYXJlIHJlZHVjZWQgaW4gcmVsZXZhbmN5XG4gIGZ1bmN0aW9uIHJlZHVjZVJlbGV2YW5jeShsaXN0LCB7ZXhjZXB0aW9ucywgd2hlbn0gPSB7fSkge1xuICAgIGNvbnN0IHF1YWxpZnlGbiA9IHdoZW47XG4gICAgZXhjZXB0aW9ucyA9IGV4Y2VwdGlvbnMgfHwgW107XG4gICAgcmV0dXJuIGxpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5tYXRjaCgvXFx8XFxkKyQvKSB8fCBleGNlcHRpb25zLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSBlbHNlIGlmIChxdWFsaWZ5Rm4oaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2l0ZW19fDBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTUUwnLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgLy8gZG9lcyBub3QgaW5jbHVkZSB7fSBvciBIVE1MIHRhZ3MgYDwvYFxuICAgIGlsbGVnYWw6IC9be31dfDxcXC8vLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICAkcGF0dGVybjogL1xcYltcXHdcXC5dKy8sXG4gICAgICBrZXl3b3JkOlxuICAgICAgICByZWR1Y2VSZWxldmFuY3koS0VZV09SRFMsIHsgd2hlbjogKHgpID0+IHgubGVuZ3RoIDwgMyB9KS5qb2luKFwiIFwiKSxcbiAgICAgIGxpdGVyYWw6IExJVEVSQUxTLmpvaW4oXCIgXCIpLFxuICAgICAgdHlwZTogVFlQRVMuam9pbihcIiBcIiksXG4gICAgICBidWlsdF9pbjogUE9TU0lCTEVfV0lUSE9VVF9QQVJFTlMuam9pbihcIiBcIilcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiBlaXRoZXIoLi4uQ09NQk9TKSxcbiAgICAgICAga2V5d29yZHM6IHtcbiAgICAgICAgICAkcGF0dGVybjogL1tcXHdcXC5dKy8sXG4gICAgICAgICAga2V5d29yZDogS0VZV09SRFMuY29uY2F0KENPTUJPUykuam9pbihcIiBcIiksXG4gICAgICAgICAgbGl0ZXJhbDogTElURVJBTFMuam9pbihcIiBcIiksXG4gICAgICAgICAgdHlwZTogVFlQRVMuam9pbihcIiBcIilcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0eXBlXCIsXG4gICAgICAgIGJlZ2luOiBlaXRoZXIoLi4uTVVMVElfV09SRF9UWVBFUylcbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9DQUxMLFxuICAgICAgVkFSSUFCTEUsXG4gICAgICBTVFJJTkcsXG4gICAgICBRVU9URURfSURFTlRJRklFUixcbiAgICAgIGhsanMuQ19OVU1CRVJfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBDT01NRU5UX01PREUsXG4gICAgICBPUEVSQVRPUlxuICAgIF1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzcWw7XG4iXSwibmFtZXMiOlsic291cmNlIiwicmUiLCJjb25jYXQiLCJhcmdzIiwiam9pbmVkIiwibWFwIiwieCIsImpvaW4iLCJlaXRoZXIiLCJzcWwiLCJobGpzIiwiQ09NTUVOVF9NT0RFIiwiQ09NTUVOVCIsIlNUUklORyIsImNsYXNzTmFtZSIsInZhcmlhbnRzIiwiYmVnaW4iLCJlbmQiLCJjb250YWlucyIsIlFVT1RFRF9JREVOVElGSUVSIiwiTElURVJBTFMiLCJNVUxUSV9XT1JEX1RZUEVTIiwiVFlQRVMiLCJOT05fUkVTRVJWRURfV09SRFMiLCJSRVNFUlZFRF9XT1JEUyIsIlJFU0VSVkVEX0ZVTkNUSU9OUyIsIlBPU1NJQkxFX1dJVEhPVVRfUEFSRU5TIiwiQ09NQk9TIiwiRlVOQ1RJT05TIiwiS0VZV09SRFMiLCJmaWx0ZXIiLCJrZXl3b3JkIiwiaW5jbHVkZXMiLCJWQVJJQUJMRSIsIk9QRVJBVE9SIiwicmVsZXZhbmNlIiwiRlVOQ1RJT05fQ0FMTCIsImtleXdvcmRzIiwiYnVpbHRfaW4iLCJyZWR1Y2VSZWxldmFuY3kiLCJsaXN0IiwiZXhjZXB0aW9ucyIsIndoZW4iLCJxdWFsaWZ5Rm4iLCJpdGVtIiwibWF0Y2giLCJuYW1lIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImlsbGVnYWwiLCIkcGF0dGVybiIsImxlbmd0aCIsImxpdGVyYWwiLCJ0eXBlIiwiQ19OVU1CRVJfTU9ERSIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHLEdBRUg7OztDQUdDLEdBQ0QsU0FBU0EsT0FBT0MsRUFBRTtJQUNoQixJQUFJLENBQUNBLElBQUksT0FBTztJQUNoQixJQUFJLE9BQU9BLE9BQU8sVUFBVSxPQUFPQTtJQUVuQyxPQUFPQSxHQUFHRCxNQUFNO0FBQ2xCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0UsT0FBTyxHQUFHQyxJQUFJO0lBQ3JCLE1BQU1DLFNBQVNELEtBQUtFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNTixPQUFPTSxJQUFJQyxJQUFJLENBQUM7SUFDL0MsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLE9BQU8sR0FBR0wsSUFBSTtJQUNyQixNQUFNQyxTQUFTLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxDQUFDQyxJQUFNTixPQUFPTSxJQUFJQyxJQUFJLENBQUMsT0FBTztJQUM1RCxPQUFPSDtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUVELFNBQVNLLElBQUlDLElBQUk7SUFDZixNQUFNQyxlQUFlRCxLQUFLRSxPQUFPLENBQUMsTUFBTTtJQUN4QyxNQUFNQyxTQUFTO1FBQ2JDLFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUNFQyxPQUFPO2dCQUNQQyxLQUFLO2dCQUNMQyxVQUFVO29CQUNSO3dCQUFDRixPQUFPO29CQUFLO2lCQUNkO1lBQ0g7U0FDRDtJQUNIO0lBQ0EsTUFBTUcsb0JBQW9CO1FBQ3hCSCxPQUFPO1FBQ1BDLEtBQUs7UUFDTEMsVUFBVTtZQUFFO2dCQUFFRixPQUFPO1lBQUs7U0FBRztJQUMvQjtJQUVBLE1BQU1JLFdBQVc7UUFDZjtRQUNBO1FBQ0Esb0dBQW9HO1FBQ3BHLFVBQVU7UUFDVjtLQUNEO0lBRUQsTUFBTUMsbUJBQW1CO1FBQ3ZCO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxRQUFRO1FBQ1o7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxxQkFBcUI7UUFDekI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsMEZBQTBGO0lBQzFGLE1BQU1DLGlCQUFpQjtRQUNyQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELDhEQUE4RDtJQUM5RCw0REFBNEQ7SUFDNUQsMkJBQTJCO0lBQzNCLE1BQU1DLHFCQUFxQjtRQUN6QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBRUQsc0JBQXNCO0lBQ3RCLE1BQU1DLDBCQUEwQjtRQUM5QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELG1EQUFtRDtJQUNuRCxxREFBcUQ7SUFDckQsTUFBTUMsU0FBUztRQUNiO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxZQUFZSDtJQUVsQixNQUFNSSxXQUFXO1dBQUlMO1dBQW1CRDtLQUFtQixDQUFDTyxNQUFNLENBQUMsQ0FBQ0M7UUFDbEUsT0FBTyxDQUFDTixtQkFBbUJPLFFBQVEsQ0FBQ0Q7SUFDdEM7SUFFQSxNQUFNRSxXQUFXO1FBQ2ZuQixXQUFXO1FBQ1hFLE9BQU87SUFDVDtJQUVBLE1BQU1rQixXQUFXO1FBQ2ZwQixXQUFXO1FBQ1hFLE9BQU87UUFDUG1CLFdBQVc7SUFDYjtJQUVBLE1BQU1DLGdCQUFnQjtRQUNwQnBCLE9BQU9kLE9BQU8sTUFBTU0sVUFBVW9CLFlBQVk7UUFDMUNTLFVBQVU7WUFDUkMsVUFBVVYsVUFBVXJCLElBQUksQ0FBQztRQUMzQjtJQUNGO0lBRUEsNkRBQTZEO0lBQzdELFNBQVNnQyxnQkFBZ0JDLElBQUksRUFBRSxFQUFDQyxVQUFVLEVBQUVDLElBQUksRUFBQyxHQUFHLENBQUMsQ0FBQztRQUNwRCxNQUFNQyxZQUFZRDtRQUNsQkQsYUFBYUEsY0FBYyxFQUFFO1FBQzdCLE9BQU9ELEtBQUtuQyxHQUFHLENBQUMsQ0FBQ3VDO1lBQ2YsSUFBSUEsS0FBS0MsS0FBSyxDQUFDLGFBQWFKLFdBQVdULFFBQVEsQ0FBQ1ksT0FBTztnQkFDckQsT0FBT0E7WUFDVCxPQUFPLElBQUlELFVBQVVDLE9BQU87Z0JBQzFCLE9BQU8sQ0FBQyxFQUFFQSxLQUFLLEVBQUUsQ0FBQztZQUNwQixPQUFPO2dCQUNMLE9BQU9BO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMRSxNQUFNO1FBQ05DLGtCQUFrQjtRQUNsQix3Q0FBd0M7UUFDeENDLFNBQVM7UUFDVFgsVUFBVTtZQUNSWSxVQUFVO1lBQ1ZsQixTQUNFUSxnQkFBZ0JWLFVBQVU7Z0JBQUVhLE1BQU0sQ0FBQ3BDLElBQU1BLEVBQUU0QyxNQUFNLEdBQUc7WUFBRSxHQUFHM0MsSUFBSSxDQUFDO1lBQ2hFNEMsU0FBUy9CLFNBQVNiLElBQUksQ0FBQztZQUN2QjZDLE1BQU05QixNQUFNZixJQUFJLENBQUM7WUFDakIrQixVQUFVWix3QkFBd0JuQixJQUFJLENBQUM7UUFDekM7UUFDQVcsVUFBVTtZQUNSO2dCQUNFRixPQUFPUixVQUFVbUI7Z0JBQ2pCVSxVQUFVO29CQUNSWSxVQUFVO29CQUNWbEIsU0FBU0YsU0FBUzNCLE1BQU0sQ0FBQ3lCLFFBQVFwQixJQUFJLENBQUM7b0JBQ3RDNEMsU0FBUy9CLFNBQVNiLElBQUksQ0FBQztvQkFDdkI2QyxNQUFNOUIsTUFBTWYsSUFBSSxDQUFDO2dCQUNuQjtZQUNGO1lBQ0E7Z0JBQ0VPLFdBQVc7Z0JBQ1hFLE9BQU9SLFVBQVVhO1lBQ25CO1lBQ0FlO1lBQ0FIO1lBQ0FwQjtZQUNBTTtZQUNBVCxLQUFLMkMsYUFBYTtZQUNsQjNDLEtBQUs0QyxvQkFBb0I7WUFDekIzQztZQUNBdUI7U0FDRDtJQUNIO0FBQ0Y7QUFFQXFCLE9BQU9DLE9BQU8sR0FBRy9DIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3NxbC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/sql.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/typescript.js":
/*!***************************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/typescript.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("const IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    // JS handles these with a special rule\n    // \"get\",\n    // \"set\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n];\nconst LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n    \"NaN\",\n    \"Infinity\"\n];\nconst TYPES = [\n    \"Intl\",\n    \"DataView\",\n    \"Number\",\n    \"Math\",\n    \"Date\",\n    \"String\",\n    \"RegExp\",\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Error\",\n    \"Symbol\",\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    \"Proxy\",\n    \"Reflect\",\n    \"JSON\",\n    \"Promise\",\n    \"Float64Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Int8Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"Float32Array\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"ArrayBuffer\"\n];\nconst ERROR_TYPES = [\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n];\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n];\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\" // Node.js\n];\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, TYPES, ERROR_TYPES);\n/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function lookahead(re) {\n    return concat(\"(?=\", re, \")\");\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/ /** @type LanguageFn */ function javascript(hljs) {\n    /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */ const hasClosingTag = (match, { after })=>{\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */ isTrulyOpeningTag: (match, response)=>{\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            // nested type?\n            // HTML should not include another raw `<` inside a tag\n            // But a type might: `<Array<Array<number>>`, etc.\n            if (nextChar === \"<\") {\n                response.ignoreMatch();\n                return;\n            }\n            // <something>\n            // This is now either a tag or a type.\n            if (nextChar === \">\") {\n                // if we cannot find a matching closing tag, then we\n                // will ignore it\n                if (!hasClosingTag(match, {\n                    after: afterMatchIndex\n                })) {\n                    response.ignoreMatch();\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS.join(\" \"),\n        literal: LITERALS.join(\" \"),\n        built_in: BUILT_INS.join(\" \")\n    };\n    // https://tc39.es/ecma262/#sec-literals-numeric-literals\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            // DecimalLiteral\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` + `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            {\n                begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b`\n            },\n            // DecimalBigIntegerLiteral\n            {\n                begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b`\n            },\n            // NonDecimalIntegerLiteral\n            {\n                begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\"\n            },\n            // LegacyOctalIntegerLiteral (does not include underscore separators)\n            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n            {\n                begin: \"\\\\b0[0-7]+n?\\\\b\"\n            }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: [] // defined later\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"css\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n        ]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                className: \"doctag\",\n                begin: \"@[A-Za-z]+\",\n                contains: [\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    // eat spaces (not newlines) so we can find\n                    // types or variables\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER,\n        hljs.REGEXP_MODE\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        // we need to pair up {} inside our subst to prevent\n        // it from ending too early by matching another }\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\n            \"self\"\n        ].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        // eat recursive parens in sub expressions\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\n                \"self\"\n            ].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    return {\n        name: \"Javascript\",\n        aliases: [\n            \"js\",\n            \"jsx\",\n            \"mjs\",\n            \"cjs\"\n        ],\n        keywords: KEYWORDS$1,\n        // this will be extended by TypeScript\n        exports: {\n            PARAMS_CONTAINS\n        },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            {\n                label: \"use_strict\",\n                className: \"meta\",\n                relevance: 10,\n                begin: /^\\s*['\"]use (strict|asm)['\"]/\n            },\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            NUMBER,\n            {\n                begin: concat(/[{,\\n]\\s*/, // we need to look ahead to make sure that we actually have an\n                // attribute coming up so we don't steal a comma from a potential\n                // \"value\" container\n                //\n                // NOTE: this might not work how you think.  We don't actually always\n                // enter this mode and stay.  Instead it might merely match `,\n                // <comments up next>` and then immediately end after the , because it\n                // fails to find any actual attrs. But this still does the job because\n                // it prevents the value contain rule from grabbing this instead and\n                // prevening this rule from firing when we actually DO have keys.\n                lookahead(concat(// we also need to allow for multiple possible comments inbetween\n                // the first key:value pairing\n                /(((\\/\\/.*$)|(\\/\\*(\\*[^/]|[^*])*\\*\\/))\\s*)*/, IDENT_RE$1 + \"\\\\s*:\"))),\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"attr\",\n                        begin: IDENT_RE$1 + lookahead(\"\\\\s*:\"),\n                        relevance: 0\n                    }\n                ]\n            },\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        // we have to count the parens to make sure we actually have the\n                        // correct bounding ( ) before the =>.  There could be any number of\n                        // sub-expressions inside also surrounded by parens.\n                        begin: \"(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)|\" + hljs.UNDERSCORE_IDENT_RE + \")\\\\s*=>\",\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        className: \"\",\n                        begin: /\\s/,\n                        end: /\\s*/,\n                        skip: true\n                    },\n                    {\n                        variants: [\n                            {\n                                begin: FRAGMENT.begin,\n                                end: FRAGMENT.end\n                            },\n                            {\n                                begin: XML_TAG.begin,\n                                // we carefully check the opening tag to see if it truly\n                                // is a tag and not a false positive\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\n                                    \"self\"\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                relevance: 0\n            },\n            {\n                className: \"function\",\n                beginKeywords: \"function\",\n                end: /[{;]/,\n                excludeEnd: true,\n                keywords: KEYWORDS$1,\n                contains: [\n                    \"self\",\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    PARAMS\n                ],\n                illegal: /%/\n            },\n            {\n                // prevent this from getting swallowed up by function\n                // since they appear \"function like\"\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                className: \"function\",\n                // we have to count the parens to make sure we actually have the correct\n                // bounding ( ).  There could be any number of sub-expressions inside\n                // also surrounded by parens.\n                begin: hljs.UNDERSCORE_IDENT_RE + \"\\\\(\" + // first parens\n                \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    })\n                ]\n            },\n            // hack: prevents detection of keywords in some circumstances\n            // .keyword()\n            // $keyword = x\n            {\n                variants: [\n                    {\n                        begin: \"\\\\.\" + IDENT_RE$1\n                    },\n                    {\n                        begin: \"\\\\$\" + IDENT_RE$1\n                    }\n                ],\n                relevance: 0\n            },\n            {\n                className: \"class\",\n                beginKeywords: \"class\",\n                end: /[{;=]/,\n                excludeEnd: true,\n                illegal: /[:\"[\\]]/,\n                contains: [\n                    {\n                        beginKeywords: \"extends\"\n                    },\n                    hljs.UNDERSCORE_TITLE_MODE\n                ]\n            },\n            {\n                begin: /\\b(?=constructor)/,\n                end: /[{;]/,\n                excludeEnd: true,\n                contains: [\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    \"self\",\n                    PARAMS\n                ]\n            },\n            {\n                begin: \"(get|set)\\\\s+(?=\" + IDENT_RE$1 + \"\\\\()\",\n                end: /\\{/,\n                keywords: \"get set\",\n                contains: [\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1\n                    }),\n                    {\n                        begin: /\\(\\)/\n                    },\n                    PARAMS\n                ]\n            },\n            {\n                begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n            }\n        ]\n    };\n}\n/*\nLanguage: TypeScript\nAuthor: Panu Horsmalahti <panu.horsmalahti@iki.fi>\nContributors: Ike Ku <dempfi@yahoo.com>\nDescription: TypeScript is a strict superset of JavaScript\nWebsite: https://www.typescriptlang.org\nCategory: common, scripting\n*/ /** @type LanguageFn */ function typescript(hljs) {\n    const IDENT_RE$1 = IDENT_RE;\n    const NAMESPACE = {\n        beginKeywords: \"namespace\",\n        end: /\\{/,\n        excludeEnd: true\n    };\n    const INTERFACE = {\n        beginKeywords: \"interface\",\n        end: /\\{/,\n        excludeEnd: true,\n        keywords: \"interface extends\"\n    };\n    const USE_STRICT = {\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use strict['\"]/\n    };\n    const TYPES = [\n        \"any\",\n        \"void\",\n        \"number\",\n        \"boolean\",\n        \"string\",\n        \"object\",\n        \"never\",\n        \"enum\"\n    ];\n    const TS_SPECIFIC_KEYWORDS = [\n        \"type\",\n        \"namespace\",\n        \"typedef\",\n        \"interface\",\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"implements\",\n        \"declare\",\n        \"abstract\",\n        \"readonly\"\n    ];\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS).join(\" \"),\n        literal: LITERALS.join(\" \"),\n        built_in: BUILT_INS.concat(TYPES).join(\" \")\n    };\n    const DECORATOR = {\n        className: \"meta\",\n        begin: \"@\" + IDENT_RE$1\n    };\n    const swapMode = (mode, label, replacement)=>{\n        const indx = mode.contains.findIndex((m)=>m.label === label);\n        if (indx === -1) {\n            throw new Error(\"can not find mode to replace\");\n        }\n        mode.contains.splice(indx, 1, replacement);\n    };\n    const tsLanguage = javascript(hljs);\n    // this should update anywhere keywords is used since\n    // it will be the same actual JS object\n    Object.assign(tsLanguage.keywords, KEYWORDS$1);\n    tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);\n    tsLanguage.contains = tsLanguage.contains.concat([\n        DECORATOR,\n        NAMESPACE,\n        INTERFACE\n    ]);\n    // TS gets a simpler shebang rule than JS\n    swapMode(tsLanguage, \"shebang\", hljs.SHEBANG());\n    // JS use strict rule purposely excludes `asm` which makes no sense\n    swapMode(tsLanguage, \"use_strict\", USE_STRICT);\n    const functionDeclaration = tsLanguage.contains.find((m)=>m.className === \"function\");\n    functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript\n    Object.assign(tsLanguage, {\n        name: \"TypeScript\",\n        aliases: [\n            \"ts\"\n        ]\n    });\n    return tsLanguage;\n}\nmodule.exports = typescript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3R5cGVzY3JpcHQuanM/MDMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuY29uc3QgS0VZV09SRFMgPSBbXG4gIFwiYXNcIiwgLy8gZm9yIGV4cG9ydHNcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiaWZcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImZpbmFsbHlcIixcbiAgXCJ2YXJcIixcbiAgXCJuZXdcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcImRvXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwidm9pZFwiLFxuICBcImVsc2VcIixcbiAgXCJicmVha1wiLFxuICBcImNhdGNoXCIsXG4gIFwiaW5zdGFuY2VvZlwiLFxuICBcIndpdGhcIixcbiAgXCJ0aHJvd1wiLFxuICBcImNhc2VcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwidHJ5XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwiY29udGludWVcIixcbiAgXCJ0eXBlb2ZcIixcbiAgXCJkZWxldGVcIixcbiAgXCJsZXRcIixcbiAgXCJ5aWVsZFwiLFxuICBcImNvbnN0XCIsXG4gIFwiY2xhc3NcIixcbiAgLy8gSlMgaGFuZGxlcyB0aGVzZSB3aXRoIGEgc3BlY2lhbCBydWxlXG4gIC8vIFwiZ2V0XCIsXG4gIC8vIFwic2V0XCIsXG4gIFwiZGVidWdnZXJcIixcbiAgXCJhc3luY1wiLFxuICBcImF3YWl0XCIsXG4gIFwic3RhdGljXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwiZnJvbVwiLFxuICBcImV4cG9ydFwiLFxuICBcImV4dGVuZHNcIlxuXTtcbmNvbnN0IExJVEVSQUxTID0gW1xuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJOYU5cIixcbiAgXCJJbmZpbml0eVwiXG5dO1xuXG5jb25zdCBUWVBFUyA9IFtcbiAgXCJJbnRsXCIsXG4gIFwiRGF0YVZpZXdcIixcbiAgXCJOdW1iZXJcIixcbiAgXCJNYXRoXCIsXG4gIFwiRGF0ZVwiLFxuICBcIlN0cmluZ1wiLFxuICBcIlJlZ0V4cFwiLFxuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIkVycm9yXCIsXG4gIFwiU3ltYm9sXCIsXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgXCJQcm94eVwiLFxuICBcIlJlZmxlY3RcIixcbiAgXCJKU09OXCIsXG4gIFwiUHJvbWlzZVwiLFxuICBcIkZsb2F0NjRBcnJheVwiLFxuICBcIkludDE2QXJyYXlcIixcbiAgXCJJbnQzMkFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDE2QXJyYXlcIixcbiAgXCJVaW50MzJBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLFxuICBcIkFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiQXJyYXlCdWZmZXJcIlxuXTtcblxuY29uc3QgRVJST1JfVFlQRVMgPSBbXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBCVUlMVF9JTl9WQVJJQUJMRVMsXG4gIFRZUEVTLFxuICBFUlJPUl9UWVBFU1xuKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNvdXJjZShyZSkge1xuICBpZiAoIXJlKSByZXR1cm4gbnVsbDtcbiAgaWYgKHR5cGVvZiByZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlO1xuXG4gIHJldHVybiByZS5zb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va2FoZWFkKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/PScsIHJlLCAnKScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKlxuTGFuZ3VhZ2U6IEphdmFTY3JpcHRcbkRlc2NyaXB0aW9uOiBKYXZhU2NyaXB0IChKUykgaXMgYSBsaWdodHdlaWdodCwgaW50ZXJwcmV0ZWQsIG9yIGp1c3QtaW4tdGltZSBjb21waWxlZCBwcm9ncmFtbWluZyBsYW5ndWFnZSB3aXRoIGZpcnN0LWNsYXNzIGZ1bmN0aW9ucy5cbkNhdGVnb3J5OiBjb21tb24sIHNjcmlwdGluZ1xuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdFxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmFzY3JpcHQoaGxqcykge1xuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgbGlrZSBcIjxCb29nZXJcIiBhbmQgY2hlY2tzIHRvIHNlZVxuICAgKiBpZiB3ZSBjYW4gZmluZCBhIG1hdGNoaW5nIFwiPC9Cb29nZXJcIiBsYXRlciBpbiB0aGVcbiAgICogY29udGVudC5cbiAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgKiBAcGFyYW0ge3thZnRlcjpudW1iZXJ9fSBwYXJhbTFcbiAgICovXG4gIGNvbnN0IGhhc0Nsb3NpbmdUYWcgPSAobWF0Y2gsIHsgYWZ0ZXIgfSkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFwiPC9cIiArIG1hdGNoWzBdLnNsaWNlKDEpO1xuICAgIGNvbnN0IHBvcyA9IG1hdGNoLmlucHV0LmluZGV4T2YodGFnLCBhZnRlcik7XG4gICAgcmV0dXJuIHBvcyAhPT0gLTE7XG4gIH07XG5cbiAgY29uc3QgSURFTlRfUkUkMSA9IElERU5UX1JFO1xuICBjb25zdCBGUkFHTUVOVCA9IHtcbiAgICBiZWdpbjogJzw+JyxcbiAgICBlbmQ6ICc8Lz4nXG4gIH07XG4gIGNvbnN0IFhNTF9UQUcgPSB7XG4gICAgYmVnaW46IC88W0EtWmEtejAtOVxcXFwuXzotXSsvLFxuICAgIGVuZDogL1xcL1tBLVphLXowLTlcXFxcLl86LV0rPnxcXC8+LyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIGlzVHJ1bHlPcGVuaW5nVGFnOiAobWF0Y2gsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1hdGNoSW5kZXggPSBtYXRjaFswXS5sZW5ndGggKyBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2guaW5wdXRbYWZ0ZXJNYXRjaEluZGV4XTtcbiAgICAgIC8vIG5lc3RlZCB0eXBlP1xuICAgICAgLy8gSFRNTCBzaG91bGQgbm90IGluY2x1ZGUgYW5vdGhlciByYXcgYDxgIGluc2lkZSBhIHRhZ1xuICAgICAgLy8gQnV0IGEgdHlwZSBtaWdodDogYDxBcnJheTxBcnJheTxudW1iZXI+PmAsIGV0Yy5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gPHNvbWV0aGluZz5cbiAgICAgIC8vIFRoaXMgaXMgbm93IGVpdGhlciBhIHRhZyBvciBhIHR5cGUuXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBLRVlXT1JEUyQxID0ge1xuICAgICRwYXR0ZXJuOiBJREVOVF9SRSxcbiAgICBrZXl3b3JkOiBLRVlXT1JEUy5qb2luKFwiIFwiKSxcbiAgICBsaXRlcmFsOiBMSVRFUkFMUy5qb2luKFwiIFwiKSxcbiAgICBidWlsdF9pbjogQlVJTFRfSU5TLmpvaW4oXCIgXCIpXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxEaWdpdHMgPSAnWzAtOV0oXz9bMC05XSkqJztcbiAgY29uc3QgZnJhYyA9IGBcXFxcLigke2RlY2ltYWxEaWdpdHN9KWA7XG4gIC8vIERlY2ltYWxJbnRlZ2VyTGl0ZXJhbCwgaW5jbHVkaW5nIEFubmV4IEIgTm9uT2N0YWxEZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gIGNvbnN0IGRlY2ltYWxJbnRlZ2VyID0gYDB8WzEtOV0oXz9bMC05XSkqfDBbMC03XSpbODldWzAtOV0qYDtcbiAgY29uc3QgTlVNQkVSID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIERlY2ltYWxMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgKFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KSgoJHtmcmFjfSl8XFxcXC4pP3woJHtmcmFjfSkpYCArXG4gICAgICAgIGBbZUVdWystXT8oJHtkZWNpbWFsRGlnaXRzfSlcXFxcYmAgfSxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSlcXFxcYigoJHtmcmFjfSlcXFxcYnxcXFxcLik/fCgke2ZyYWN9KVxcXFxiYCB9LFxuXG4gICAgICAvLyBEZWNpbWFsQmlnSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IGBcXFxcYigwfFsxLTldKF8/WzAtOV0pKiluXFxcXGJgIH0sXG5cbiAgICAgIC8vIE5vbkRlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbeFhdWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtiQl1bMC0xXShfP1swLTFdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW29PXVswLTddKF8/WzAtN10pKm4/XFxcXGJcIiB9LFxuXG4gICAgICAvLyBMZWdhY3lPY3RhbEludGVnZXJMaXRlcmFsIChkb2VzIG5vdCBpbmNsdWRlIHVuZGVyc2NvcmUgc2VwYXJhdG9ycylcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbMC03XStuP1xcXFxiXCIgfSxcbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IFNVQlNUID0ge1xuICAgIGNsYXNzTmFtZTogJ3N1YnN0JyxcbiAgICBiZWdpbjogJ1xcXFwkXFxcXHsnLFxuICAgIGVuZDogJ1xcXFx9JyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICBjb250YWluczogW10gLy8gZGVmaW5lZCBsYXRlclxuICB9O1xuICBjb25zdCBIVE1MX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnaHRtbGAnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICd4bWwnXG4gICAgfVxuICB9O1xuICBjb25zdCBDU1NfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdjc3NgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAnY3NzJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgVEVNUExBVEVfU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgYmVnaW46ICdgJyxcbiAgICBlbmQ6ICdgJyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgU1VCU1RcbiAgICBdXG4gIH07XG4gIGNvbnN0IEpTRE9DX0NPTU1FTlQgPSBobGpzLkNPTU1FTlQoXG4gICAgL1xcL1xcKlxcKig/IVxcLykvLFxuICAgICdcXFxcKi8nLFxuICAgIHtcbiAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgICAgIGJlZ2luOiAnQFtBLVphLXpdKycsXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgIGJlZ2luOiAnXFxcXHsnLFxuICAgICAgICAgICAgICBlbmQ6ICdcXFxcfScsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArICcoPz1cXFxccyooLSl8JCknLFxuICAgICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlYXQgc3BhY2VzIChub3QgbmV3bGluZXMpIHNvIHdlIGNhbiBmaW5kXG4gICAgICAgICAgICAvLyB0eXBlcyBvciB2YXJpYWJsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC8oPz1bXlxcbl0pXFxzLyxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICApO1xuICBjb25zdCBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb21tZW50XCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIEpTRE9DX0NPTU1FTlQsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xuICBjb25zdCBTVUJTVF9JTlRFUk5BTFMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgSFRNTF9URU1QTEFURSxcbiAgICBDU1NfVEVNUExBVEUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIE5VTUJFUixcbiAgICBobGpzLlJFR0VYUF9NT0RFXG4gIF07XG4gIFNVQlNULmNvbnRhaW5zID0gU1VCU1RfSU5URVJOQUxTXG4gICAgLmNvbmNhdCh7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHBhaXIgdXAge30gaW5zaWRlIG91ciBzdWJzdCB0byBwcmV2ZW50XG4gICAgICAvLyBpdCBmcm9tIGVuZGluZyB0b28gZWFybHkgYnkgbWF0Y2hpbmcgYW5vdGhlciB9XG4gICAgICBiZWdpbjogL1xcey8sXG4gICAgICBlbmQ6IC9cXH0vLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBcInNlbGZcIlxuICAgICAgXS5jb25jYXQoU1VCU1RfSU5URVJOQUxTKVxuICAgIH0pO1xuICBjb25zdCBTVUJTVF9BTkRfQ09NTUVOVFMgPSBbXS5jb25jYXQoQ09NTUVOVCwgU1VCU1QuY29udGFpbnMpO1xuICBjb25zdCBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVF9BTkRfQ09NTUVOVFMuY29uY2F0KFtcbiAgICAvLyBlYXQgcmVjdXJzaXZlIHBhcmVucyBpbiBzdWIgZXhwcmVzc2lvbnNcbiAgICB7XG4gICAgICBiZWdpbjogL1xcKC8sXG4gICAgICBlbmQ6IC9cXCkvLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1wic2VsZlwiXS5jb25jYXQoU1VCU1RfQU5EX0NPTU1FTlRTKVxuICAgIH1cbiAgXSk7XG4gIGNvbnN0IFBBUkFNUyA9IHtcbiAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdKYXZhc2NyaXB0JyxcbiAgICBhbGlhc2VzOiBbJ2pzJywgJ2pzeCcsICdtanMnLCAnY2pzJ10sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGV4dGVuZGVkIGJ5IFR5cGVTY3JpcHRcbiAgICBleHBvcnRzOiB7IFBBUkFNU19DT05UQUlOUyB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiBcInVzZV9zdHJpY3RcIixcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIHJlbGV2YW5jZTogMTAsXG4gICAgICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgICAgIH0sXG4gICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgICAgSFRNTF9URU1QTEFURSxcbiAgICAgIENTU19URU1QTEFURSxcbiAgICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICAgIENPTU1FTlQsXG4gICAgICBOVU1CRVIsXG4gICAgICB7IC8vIG9iamVjdCBhdHRyIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogY29uY2F0KC9beyxcXG5dXFxzKi8sXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBsb29rIGFoZWFkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGFjdHVhbGx5IGhhdmUgYW5cbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgY29taW5nIHVwIHNvIHdlIGRvbid0IHN0ZWFsIGEgY29tbWEgZnJvbSBhIHBvdGVudGlhbFxuICAgICAgICAgIC8vIFwidmFsdWVcIiBjb250YWluZXJcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5PVEU6IHRoaXMgbWlnaHQgbm90IHdvcmsgaG93IHlvdSB0aGluay4gIFdlIGRvbid0IGFjdHVhbGx5IGFsd2F5c1xuICAgICAgICAgIC8vIGVudGVyIHRoaXMgbW9kZSBhbmQgc3RheS4gIEluc3RlYWQgaXQgbWlnaHQgbWVyZWx5IG1hdGNoIGAsXG4gICAgICAgICAgLy8gPGNvbW1lbnRzIHVwIG5leHQ+YCBhbmQgdGhlbiBpbW1lZGlhdGVseSBlbmQgYWZ0ZXIgdGhlICwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGZhaWxzIHRvIGZpbmQgYW55IGFjdHVhbCBhdHRycy4gQnV0IHRoaXMgc3RpbGwgZG9lcyB0aGUgam9iIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBwcmV2ZW50cyB0aGUgdmFsdWUgY29udGFpbiBydWxlIGZyb20gZ3JhYmJpbmcgdGhpcyBpbnN0ZWFkIGFuZFxuICAgICAgICAgIC8vIHByZXZlbmluZyB0aGlzIHJ1bGUgZnJvbSBmaXJpbmcgd2hlbiB3ZSBhY3R1YWxseSBETyBoYXZlIGtleXMuXG4gICAgICAgICAgbG9va2FoZWFkKGNvbmNhdChcbiAgICAgICAgICAgIC8vIHdlIGFsc28gbmVlZCB0byBhbGxvdyBmb3IgbXVsdGlwbGUgcG9zc2libGUgY29tbWVudHMgaW5iZXR3ZWVuXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3Qga2V5OnZhbHVlIHBhaXJpbmdcbiAgICAgICAgICAgIC8oKChcXC9cXC8uKiQpfChcXC9cXCooXFwqW14vXXxbXipdKSpcXCpcXC8pKVxccyopKi8sXG4gICAgICAgICAgICBJREVOVF9SRSQxICsgJ1xcXFxzKjonKSkpLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYXR0cicsXG4gICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArIGxvb2thaGVhZCgnXFxcXHMqOicpLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBDT01NRU5ULFxuICAgICAgICAgIGhsanMuUkVHRVhQX01PREUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjb3VudCB0aGUgcGFyZW5zIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCBib3VuZGluZyAoICkgYmVmb3JlIHRoZSA9Pi4gIFRoZXJlIGNvdWxkIGJlIGFueSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHN1Yi1leHByZXNzaW9ucyBpbnNpZGUgYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgICAgIGJlZ2luOiAnKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qJyArXG4gICAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAgICdcXFxcKXwnICsgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFICsgJylcXFxccyo9PicsXG4gICAgICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZDogJ1xcXFxzKj0+JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgICBza2lwOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gY291bGQgYmUgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXJhbXMgdG8gYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICBiZWdpbjogLywvLCByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJycsXG4gICAgICAgICAgICBiZWdpbjogL1xccy8sXG4gICAgICAgICAgICBlbmQ6IC9cXHMqLyxcbiAgICAgICAgICAgIHNraXA6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gSlNYXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7IGJlZ2luOiBGUkFHTUVOVC5iZWdpbiwgZW5kOiBGUkFHTUVOVC5lbmQgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiBYTUxfVEFHLmJlZ2luLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhcmVmdWxseSBjaGVjayB0aGUgb3BlbmluZyB0YWcgdG8gc2VlIGlmIGl0IHRydWx5XG4gICAgICAgICAgICAgICAgLy8gaXMgYSB0YWcgYW5kIG5vdCBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgJ29uOmJlZ2luJzogWE1MX1RBRy5pc1RydWx5T3BlbmluZ1RhZyxcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgZW5kOiBYTUxfVEFHLmVuZCxcbiAgICAgICAgICAgICAgICBza2lwOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZW5kOiAvW3s7XS8sXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICdzZWxmJyxcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7IGJlZ2luOiBJREVOVF9SRSQxIH0pLFxuICAgICAgICAgIFBBUkFNU1xuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvJS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhpcyBmcm9tIGdldHRpbmcgc3dhbGxvd2VkIHVwIGJ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgYXBwZWFyIFwiZnVuY3Rpb24gbGlrZVwiXG4gICAgICAgIGJlZ2luS2V5d29yZHM6IFwid2hpbGUgaWYgc3dpdGNoIGNhdGNoIGZvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAvLyBib3VuZGluZyAoICkuICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mIHN1Yi1leHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgLy8gYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArXG4gICAgICAgICAgJ1xcXFwoJyArIC8vIGZpcnN0IHBhcmVuc1xuICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICdbXigpXSooXFxcXCgnICtcbiAgICAgICAgICAgICAgJ1teKCldKicgK1xuICAgICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICdcXFxcKVxcXFxzKlxcXFx7JywgLy8gZW5kIHBhcmVuc1xuICAgICAgICByZXR1cm5CZWdpbjp0cnVlLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFBBUkFNUyxcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7IGJlZ2luOiBJREVOVF9SRSQxIH0pLFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gaGFjazogcHJldmVudHMgZGV0ZWN0aW9uIG9mIGtleXdvcmRzIGluIHNvbWUgY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gLmtleXdvcmQoKVxuICAgICAgLy8gJGtleXdvcmQgPSB4XG4gICAgICB7XG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgeyBiZWdpbjogJ1xcXFwuJyArIElERU5UX1JFJDEgfSxcbiAgICAgICAgICB7IGJlZ2luOiAnXFxcXCQnICsgSURFTlRfUkUkMSB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHsgLy8gRVM2IGNsYXNzXG4gICAgICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ2NsYXNzJyxcbiAgICAgICAgZW5kOiAvW3s7PV0vLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBpbGxlZ2FsOiAvWzpcIltcXF1dLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7IGJlZ2luS2V5d29yZHM6ICdleHRlbmRzJyB9LFxuICAgICAgICAgIGhsanMuVU5ERVJTQ09SRV9USVRMRV9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxiKD89Y29uc3RydWN0b3IpLyxcbiAgICAgICAgZW5kOiAvW3s7XS8sXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwgeyBiZWdpbjogSURFTlRfUkUkMSB9KSxcbiAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgUEFSQU1TXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnKGdldHxzZXQpXFxcXHMrKD89JyArIElERU5UX1JFJDEgKyAnXFxcXCgpJyxcbiAgICAgICAgZW5kOiAvXFx7LyxcbiAgICAgICAga2V5d29yZHM6IFwiZ2V0IHNldFwiLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHsgYmVnaW46IElERU5UX1JFJDEgfSksXG4gICAgICAgICAgeyBiZWdpbjogL1xcKFxcKS8gfSwgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICAgIFBBUkFNU1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG4vKlxuTGFuZ3VhZ2U6IFR5cGVTY3JpcHRcbkF1dGhvcjogUGFudSBIb3JzbWFsYWh0aSA8cGFudS5ob3JzbWFsYWh0aUBpa2kuZmk+XG5Db250cmlidXRvcnM6IElrZSBLdSA8ZGVtcGZpQHlhaG9vLmNvbT5cbkRlc2NyaXB0aW9uOiBUeXBlU2NyaXB0IGlzIGEgc3RyaWN0IHN1cGVyc2V0IG9mIEphdmFTY3JpcHRcbldlYnNpdGU6IGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZ1xuQ2F0ZWdvcnk6IGNvbW1vbiwgc2NyaXB0aW5nXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gdHlwZXNjcmlwdChobGpzKSB7XG4gIGNvbnN0IElERU5UX1JFJDEgPSBJREVOVF9SRTtcbiAgY29uc3QgTkFNRVNQQUNFID0ge1xuICAgIGJlZ2luS2V5d29yZHM6ICduYW1lc3BhY2UnLCBlbmQ6IC9cXHsvLCBleGNsdWRlRW5kOiB0cnVlXG4gIH07XG4gIGNvbnN0IElOVEVSRkFDRSA9IHtcbiAgICBiZWdpbktleXdvcmRzOiAnaW50ZXJmYWNlJywgZW5kOiAvXFx7LywgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICBrZXl3b3JkczogJ2ludGVyZmFjZSBleHRlbmRzJ1xuICB9O1xuICBjb25zdCBVU0VfU1RSSUNUID0ge1xuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIHJlbGV2YW5jZTogMTAsXG4gICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIHN0cmljdFsnXCJdL1xuICB9O1xuICBjb25zdCBUWVBFUyA9IFtcbiAgICBcImFueVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcImVudW1cIlxuICBdO1xuICBjb25zdCBUU19TUEVDSUZJQ19LRVlXT1JEUyA9IFtcbiAgICBcInR5cGVcIixcbiAgICBcIm5hbWVzcGFjZVwiLFxuICAgIFwidHlwZWRlZlwiLFxuICAgIFwiaW50ZXJmYWNlXCIsXG4gICAgXCJwdWJsaWNcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInByb3RlY3RlZFwiLFxuICAgIFwiaW1wbGVtZW50c1wiLFxuICAgIFwiZGVjbGFyZVwiLFxuICAgIFwiYWJzdHJhY3RcIixcbiAgICBcInJlYWRvbmx5XCJcbiAgXTtcbiAgY29uc3QgS0VZV09SRFMkMSA9IHtcbiAgICAkcGF0dGVybjogSURFTlRfUkUsXG4gICAga2V5d29yZDogS0VZV09SRFMuY29uY2F0KFRTX1NQRUNJRklDX0tFWVdPUkRTKS5qb2luKFwiIFwiKSxcbiAgICBsaXRlcmFsOiBMSVRFUkFMUy5qb2luKFwiIFwiKSxcbiAgICBidWlsdF9pbjogQlVJTFRfSU5TLmNvbmNhdChUWVBFUykuam9pbihcIiBcIilcbiAgfTtcbiAgY29uc3QgREVDT1JBVE9SID0ge1xuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIGJlZ2luOiAnQCcgKyBJREVOVF9SRSQxLFxuICB9O1xuXG4gIGNvbnN0IHN3YXBNb2RlID0gKG1vZGUsIGxhYmVsLCByZXBsYWNlbWVudCkgPT4ge1xuICAgIGNvbnN0IGluZHggPSBtb2RlLmNvbnRhaW5zLmZpbmRJbmRleChtID0+IG0ubGFiZWwgPT09IGxhYmVsKTtcbiAgICBpZiAoaW5keCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKFwiY2FuIG5vdCBmaW5kIG1vZGUgdG8gcmVwbGFjZVwiKTsgfVxuICAgIG1vZGUuY29udGFpbnMuc3BsaWNlKGluZHgsIDEsIHJlcGxhY2VtZW50KTtcbiAgfTtcblxuICBjb25zdCB0c0xhbmd1YWdlID0gamF2YXNjcmlwdChobGpzKTtcblxuICAvLyB0aGlzIHNob3VsZCB1cGRhdGUgYW55d2hlcmUga2V5d29yZHMgaXMgdXNlZCBzaW5jZVxuICAvLyBpdCB3aWxsIGJlIHRoZSBzYW1lIGFjdHVhbCBKUyBvYmplY3RcbiAgT2JqZWN0LmFzc2lnbih0c0xhbmd1YWdlLmtleXdvcmRzLCBLRVlXT1JEUyQxKTtcblxuICB0c0xhbmd1YWdlLmV4cG9ydHMuUEFSQU1TX0NPTlRBSU5TLnB1c2goREVDT1JBVE9SKTtcbiAgdHNMYW5ndWFnZS5jb250YWlucyA9IHRzTGFuZ3VhZ2UuY29udGFpbnMuY29uY2F0KFtcbiAgICBERUNPUkFUT1IsXG4gICAgTkFNRVNQQUNFLFxuICAgIElOVEVSRkFDRSxcbiAgXSk7XG5cbiAgLy8gVFMgZ2V0cyBhIHNpbXBsZXIgc2hlYmFuZyBydWxlIHRoYW4gSlNcbiAgc3dhcE1vZGUodHNMYW5ndWFnZSwgXCJzaGViYW5nXCIsIGhsanMuU0hFQkFORygpKTtcbiAgLy8gSlMgdXNlIHN0cmljdCBydWxlIHB1cnBvc2VseSBleGNsdWRlcyBgYXNtYCB3aGljaCBtYWtlcyBubyBzZW5zZVxuICBzd2FwTW9kZSh0c0xhbmd1YWdlLCBcInVzZV9zdHJpY3RcIiwgVVNFX1NUUklDVCk7XG5cbiAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHRzTGFuZ3VhZ2UuY29udGFpbnMuZmluZChtID0+IG0uY2xhc3NOYW1lID09PSBcImZ1bmN0aW9uXCIpO1xuICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlbGV2YW5jZSA9IDA7IC8vICgpID0+IHt9IGlzIG1vcmUgdHlwaWNhbCBpbiBUeXBlU2NyaXB0XG5cbiAgT2JqZWN0LmFzc2lnbih0c0xhbmd1YWdlLCB7XG4gICAgbmFtZTogJ1R5cGVTY3JpcHQnLFxuICAgIGFsaWFzZXM6IFsndHMnXVxuICB9KTtcblxuICByZXR1cm4gdHNMYW5ndWFnZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlc2NyaXB0O1xuIl0sIm5hbWVzIjpbIklERU5UX1JFIiwiS0VZV09SRFMiLCJMSVRFUkFMUyIsIlRZUEVTIiwiRVJST1JfVFlQRVMiLCJCVUlMVF9JTl9HTE9CQUxTIiwiQlVJTFRfSU5fVkFSSUFCTEVTIiwiQlVJTFRfSU5TIiwiY29uY2F0Iiwic291cmNlIiwicmUiLCJsb29rYWhlYWQiLCJhcmdzIiwiam9pbmVkIiwibWFwIiwieCIsImpvaW4iLCJqYXZhc2NyaXB0IiwiaGxqcyIsImhhc0Nsb3NpbmdUYWciLCJtYXRjaCIsImFmdGVyIiwidGFnIiwic2xpY2UiLCJwb3MiLCJpbnB1dCIsImluZGV4T2YiLCJJREVOVF9SRSQxIiwiRlJBR01FTlQiLCJiZWdpbiIsImVuZCIsIlhNTF9UQUciLCJpc1RydWx5T3BlbmluZ1RhZyIsInJlc3BvbnNlIiwiYWZ0ZXJNYXRjaEluZGV4IiwibGVuZ3RoIiwiaW5kZXgiLCJuZXh0Q2hhciIsImlnbm9yZU1hdGNoIiwiS0VZV09SRFMkMSIsIiRwYXR0ZXJuIiwia2V5d29yZCIsImxpdGVyYWwiLCJidWlsdF9pbiIsImRlY2ltYWxEaWdpdHMiLCJmcmFjIiwiZGVjaW1hbEludGVnZXIiLCJOVU1CRVIiLCJjbGFzc05hbWUiLCJ2YXJpYW50cyIsInJlbGV2YW5jZSIsIlNVQlNUIiwia2V5d29yZHMiLCJjb250YWlucyIsIkhUTUxfVEVNUExBVEUiLCJzdGFydHMiLCJyZXR1cm5FbmQiLCJCQUNLU0xBU0hfRVNDQVBFIiwic3ViTGFuZ3VhZ2UiLCJDU1NfVEVNUExBVEUiLCJURU1QTEFURV9TVFJJTkciLCJKU0RPQ19DT01NRU5UIiwiQ09NTUVOVCIsImVuZHNQYXJlbnQiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkNfTElORV9DT01NRU5UX01PREUiLCJTVUJTVF9JTlRFUk5BTFMiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfU1RSSU5HX01PREUiLCJSRUdFWFBfTU9ERSIsIlNVQlNUX0FORF9DT01NRU5UUyIsIlBBUkFNU19DT05UQUlOUyIsIlBBUkFNUyIsImV4Y2x1ZGVCZWdpbiIsImV4Y2x1ZGVFbmQiLCJuYW1lIiwiYWxpYXNlcyIsImV4cG9ydHMiLCJpbGxlZ2FsIiwiU0hFQkFORyIsImxhYmVsIiwiYmluYXJ5IiwiUkVfU1RBUlRFUlNfUkUiLCJVTkRFUlNDT1JFX0lERU5UX1JFIiwicmV0dXJuQmVnaW4iLCJza2lwIiwiYmVnaW5LZXl3b3JkcyIsImluaGVyaXQiLCJUSVRMRV9NT0RFIiwiVU5ERVJTQ09SRV9USVRMRV9NT0RFIiwidHlwZXNjcmlwdCIsIk5BTUVTUEFDRSIsIklOVEVSRkFDRSIsIlVTRV9TVFJJQ1QiLCJUU19TUEVDSUZJQ19LRVlXT1JEUyIsIkRFQ09SQVRPUiIsInN3YXBNb2RlIiwibW9kZSIsInJlcGxhY2VtZW50IiwiaW5keCIsImZpbmRJbmRleCIsIm0iLCJFcnJvciIsInNwbGljZSIsInRzTGFuZ3VhZ2UiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIiwiZnVuY3Rpb25EZWNsYXJhdGlvbiIsImZpbmQiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFdBQVc7QUFDakIsTUFBTUMsV0FBVztJQUNmO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLHVDQUF1QztJQUN2QyxTQUFTO0lBQ1QsU0FBUztJQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELE1BQU1DLFdBQVc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELE1BQU1DLFFBQVE7SUFDWjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNB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QUMsR0FBRztZQUFFLE1BQU0sSUFBSUcsTUFBTTtRQUFpQztRQUNwRUwsS0FBSzVDLFFBQVEsQ0FBQ2tELE1BQU0sQ0FBQ0osTUFBTSxHQUFHRDtJQUNoQztJQUVBLE1BQU1NLGFBQWF2RixXQUFXQztJQUU5QixxREFBcUQ7SUFDckQsdUNBQXVDO0lBQ3ZDdUYsT0FBT0MsTUFBTSxDQUFDRixXQUFXcEQsUUFBUSxFQUFFYjtJQUVuQ2lFLFdBQVczQixPQUFPLENBQUNOLGVBQWUsQ0FBQ29DLElBQUksQ0FBQ1o7SUFDeENTLFdBQVduRCxRQUFRLEdBQUdtRCxXQUFXbkQsUUFBUSxDQUFDN0MsTUFBTSxDQUFDO1FBQy9DdUY7UUFDQUo7UUFDQUM7S0FDRDtJQUVELHlDQUF5QztJQUN6Q0ksU0FBU1EsWUFBWSxXQUFXdEYsS0FBSzZELE9BQU87SUFDNUMsbUVBQW1FO0lBQ25FaUIsU0FBU1EsWUFBWSxjQUFjWDtJQUVuQyxNQUFNZSxzQkFBc0JKLFdBQVduRCxRQUFRLENBQUN3RCxJQUFJLENBQUNSLENBQUFBLElBQUtBLEVBQUVyRCxTQUFTLEtBQUs7SUFDMUU0RCxvQkFBb0IxRCxTQUFTLEdBQUcsR0FBRyx5Q0FBeUM7SUFFNUV1RCxPQUFPQyxNQUFNLENBQUNGLFlBQVk7UUFDeEI3QixNQUFNO1FBQ05DLFNBQVM7WUFBQztTQUFLO0lBQ2pCO0lBRUEsT0FBTzRCO0FBQ1Q7QUFFQU0sT0FBT2pDLE9BQU8sR0FBR2EiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvdHlwZXNjcmlwdC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/typescript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/xml.js":
/*!********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/xml.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function lookahead(re) {\n    return concat(\"(?=\", re, \")\");\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function optional(re) {\n    return concat(\"(\", re, \")?\");\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */ function either(...args) {\n    const joined = \"(\" + args.map((x)=>source(x)).join(\"|\") + \")\";\n    return joined;\n}\n/*\nLanguage: HTML, XML\nWebsite: https://www.w3.org/XML/\nCategory: common\nAudit: 2020\n*/ /** @type LanguageFn */ function xml(hljs) {\n    // Element names can contain letters, digits, hyphens, underscores, and periods\n    const TAG_NAME_RE = concat(/[A-Z_]/, optional(/[A-Z0-9_.-]+:/), /[A-Z0-9_.-]*/);\n    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n    const XML_ENTITIES = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n        begin: /\\s/,\n        contains: [\n            {\n                className: \"meta-keyword\",\n                begin: /#?[a-z_][a-z1-9_-]+/,\n                illegal: /\\n/\n            }\n        ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n        begin: /\\(/,\n        end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n        className: \"meta-string\"\n    });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        className: \"meta-string\"\n    });\n    const TAG_INTERNALS = {\n        endsWithParent: true,\n        illegal: /</,\n        relevance: 0,\n        contains: [\n            {\n                className: \"attr\",\n                begin: XML_IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /=\\s*/,\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"string\",\n                        endsParent: true,\n                        variants: [\n                            {\n                                begin: /\"/,\n                                end: /\"/,\n                                contains: [\n                                    XML_ENTITIES\n                                ]\n                            },\n                            {\n                                begin: /'/,\n                                end: /'/,\n                                contains: [\n                                    XML_ENTITIES\n                                ]\n                            },\n                            {\n                                begin: /[^\\s\"'=<>`]+/\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n    return {\n        name: \"HTML, XML\",\n        aliases: [\n            \"html\",\n            \"xhtml\",\n            \"rss\",\n            \"atom\",\n            \"xjb\",\n            \"xsd\",\n            \"xsl\",\n            \"plist\",\n            \"wsf\",\n            \"svg\"\n        ],\n        case_insensitive: true,\n        contains: [\n            {\n                className: \"meta\",\n                begin: /<![a-z]/,\n                end: />/,\n                relevance: 10,\n                contains: [\n                    XML_META_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE,\n                    XML_META_PAR_KEYWORDS,\n                    {\n                        begin: /\\[/,\n                        end: /\\]/,\n                        contains: [\n                            {\n                                className: \"meta\",\n                                begin: /<![a-z]/,\n                                end: />/,\n                                contains: [\n                                    XML_META_KEYWORDS,\n                                    XML_META_PAR_KEYWORDS,\n                                    QUOTE_META_STRING_MODE,\n                                    APOS_META_STRING_MODE\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            hljs.COMMENT(/<!--/, /-->/, {\n                relevance: 10\n            }),\n            {\n                begin: /<!\\[CDATA\\[/,\n                end: /\\]\\]>/,\n                relevance: 10\n            },\n            XML_ENTITIES,\n            {\n                className: \"meta\",\n                begin: /<\\?xml/,\n                end: /\\?>/,\n                relevance: 10\n            },\n            {\n                className: \"tag\",\n                /*\n        The lookahead pattern (?=...) ensures that 'begin' only matches\n        '<style' as a single word, followed by a whitespace or an\n        ending braket. The '$' is needed for the lexeme to be recognized\n        by hljs.subMode() that tests lexemes outside the stream.\n        */ begin: /<style(?=\\s|>)/,\n                end: />/,\n                keywords: {\n                    name: \"style\"\n                },\n                contains: [\n                    TAG_INTERNALS\n                ],\n                starts: {\n                    end: /<\\/style>/,\n                    returnEnd: true,\n                    subLanguage: [\n                        \"css\",\n                        \"xml\"\n                    ]\n                }\n            },\n            {\n                className: \"tag\",\n                // See the comment in the <style tag about the lookahead pattern\n                begin: /<script(?=\\s|>)/,\n                end: />/,\n                keywords: {\n                    name: \"script\"\n                },\n                contains: [\n                    TAG_INTERNALS\n                ],\n                starts: {\n                    end: /<\\/script>/,\n                    returnEnd: true,\n                    subLanguage: [\n                        \"javascript\",\n                        \"handlebars\",\n                        \"xml\"\n                    ]\n                }\n            },\n            // we need this for now for jSX\n            {\n                className: \"tag\",\n                begin: /<>|<\\/>/\n            },\n            // open tag\n            {\n                className: \"tag\",\n                begin: concat(/</, lookahead(concat(TAG_NAME_RE, // <tag/>\n                // <tag>\n                // <tag ...\n                either(/\\/>/, />/, /\\s/)))),\n                end: /\\/?>/,\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0,\n                        starts: TAG_INTERNALS\n                    }\n                ]\n            },\n            // close tag\n            {\n                className: \"tag\",\n                begin: concat(/<\\//, lookahead(concat(TAG_NAME_RE, />/))),\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0\n                    },\n                    {\n                        begin: />/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    };\n}\nmodule.exports = xml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcz9iMGFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogKi9cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzb3VyY2UocmUpIHtcbiAgaWYgKCFyZSkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgcmUgPT09IFwic3RyaW5nXCIpIHJldHVybiByZTtcblxuICByZXR1cm4gcmUuc291cmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGxvb2thaGVhZChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoPz0nLCByZSwgJyknKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBvcHRpb25hbChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoJywgcmUsICcpPycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Li4uKFJlZ0V4cCB8IHN0cmluZykgfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb25jYXQoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwiXCIpO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKipcbiAqIEFueSBvZiB0aGUgcGFzc2VkIGV4cHJlc3NzaW9ucyBtYXkgbWF0Y2hcbiAqXG4gKiBDcmVhdGVzIGEgaHVnZSB0aGlzIHwgdGhpcyB8IHRoYXQgfCB0aGF0IG1hdGNoXG4gKiBAcGFyYW0geyhSZWdFeHAgfCBzdHJpbmcpW10gfSBhcmdzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlaXRoZXIoLi4uYXJncykge1xuICBjb25zdCBqb2luZWQgPSAnKCcgKyBhcmdzLm1hcCgoeCkgPT4gc291cmNlKHgpKS5qb2luKFwifFwiKSArIFwiKVwiO1xuICByZXR1cm4gam9pbmVkO1xufVxuXG4vKlxuTGFuZ3VhZ2U6IEhUTUwsIFhNTFxuV2Vic2l0ZTogaHR0cHM6Ly93d3cudzMub3JnL1hNTC9cbkNhdGVnb3J5OiBjb21tb25cbkF1ZGl0OiAyMDIwXG4qL1xuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24geG1sKGhsanMpIHtcbiAgLy8gRWxlbWVudCBuYW1lcyBjYW4gY29udGFpbiBsZXR0ZXJzLCBkaWdpdHMsIGh5cGhlbnMsIHVuZGVyc2NvcmVzLCBhbmQgcGVyaW9kc1xuICBjb25zdCBUQUdfTkFNRV9SRSA9IGNvbmNhdCgvW0EtWl9dLywgb3B0aW9uYWwoL1tBLVowLTlfLi1dKzovKSwgL1tBLVowLTlfLi1dKi8pO1xuICBjb25zdCBYTUxfSURFTlRfUkUgPSAvW0EtWmEtejAtOS5fOi1dKy87XG4gIGNvbnN0IFhNTF9FTlRJVElFUyA9IHtcbiAgICBjbGFzc05hbWU6ICdzeW1ib2wnLFxuICAgIGJlZ2luOiAvJlthLXpdKzt8JiNbMC05XSs7fCYjeFthLWYwLTldKzsvXG4gIH07XG4gIGNvbnN0IFhNTF9NRVRBX0tFWVdPUkRTID0ge1xuICAgIGJlZ2luOiAvXFxzLyxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhLWtleXdvcmQnLFxuICAgICAgICBiZWdpbjogLyM/W2Etel9dW2EtejEtOV8tXSsvLFxuICAgICAgICBpbGxlZ2FsOiAvXFxuL1xuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3QgWE1MX01FVEFfUEFSX0tFWVdPUkRTID0gaGxqcy5pbmhlcml0KFhNTF9NRVRBX0tFWVdPUkRTLCB7XG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS9cbiAgfSk7XG4gIGNvbnN0IEFQT1NfTUVUQV9TVFJJTkdfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLkFQT1NfU1RSSU5HX01PREUsIHtcbiAgICBjbGFzc05hbWU6ICdtZXRhLXN0cmluZydcbiAgfSk7XG4gIGNvbnN0IFFVT1RFX01FVEFfU1RSSU5HX01PREUgPSBobGpzLmluaGVyaXQoaGxqcy5RVU9URV9TVFJJTkdfTU9ERSwge1xuICAgIGNsYXNzTmFtZTogJ21ldGEtc3RyaW5nJ1xuICB9KTtcbiAgY29uc3QgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC9cIi8sXG4gICAgICAgICAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICAgICAgICAgIGVuZDogLycvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogL1teXFxzXCInPTw+YF0rL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdIVE1MLCBYTUwnLFxuICAgIGFsaWFzZXM6IFtcbiAgICAgICdodG1sJyxcbiAgICAgICd4aHRtbCcsXG4gICAgICAncnNzJyxcbiAgICAgICdhdG9tJyxcbiAgICAgICd4amInLFxuICAgICAgJ3hzZCcsXG4gICAgICAneHNsJyxcbiAgICAgICdwbGlzdCcsXG4gICAgICAnd3NmJyxcbiAgICAgICdzdmcnXG4gICAgXSxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICBRVU9URV9NRVRBX1NUUklOR19NT0RFLFxuICAgICAgICAgIEFQT1NfTUVUQV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICBYTUxfTUVUQV9QQVJfS0VZV09SRFMsXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXFsvLFxuICAgICAgICAgICAgZW5kOiAvXFxdLyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgICAgICAgICBiZWdpbjogLzwhW2Etel0vLFxuICAgICAgICAgICAgICAgIGVuZDogLz4vLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICAgICBYTUxfTUVUQV9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFhNTF9NRVRBX1BBUl9LRVlXT1JEUyxcbiAgICAgICAgICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREUsXG4gICAgICAgICAgICAgICAgICBBUE9TX01FVEFfU1RSSU5HX01PREVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBobGpzLkNPTU1FTlQoXG4gICAgICAgIC88IS0tLyxcbiAgICAgICAgLy0tPi8sXG4gICAgICAgIHtcbiAgICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPCFcXFtDREFUQVxcWy8sXG4gICAgICAgIGVuZDogL1xcXVxcXT4vLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgWE1MX0VOVElUSUVTLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46IC88XFw/eG1sLyxcbiAgICAgICAgZW5kOiAvXFw/Pi8sXG4gICAgICAgIHJlbGV2YW5jZTogMTBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSBsb29rYWhlYWQgcGF0dGVybiAoPz0uLi4pIGVuc3VyZXMgdGhhdCAnYmVnaW4nIG9ubHkgbWF0Y2hlc1xuICAgICAgICAnPHN0eWxlJyBhcyBhIHNpbmdsZSB3b3JkLCBmb2xsb3dlZCBieSBhIHdoaXRlc3BhY2Ugb3IgYW5cbiAgICAgICAgZW5kaW5nIGJyYWtldC4gVGhlICckJyBpcyBuZWVkZWQgZm9yIHRoZSBsZXhlbWUgdG8gYmUgcmVjb2duaXplZFxuICAgICAgICBieSBobGpzLnN1Yk1vZGUoKSB0aGF0IHRlc3RzIGxleGVtZXMgb3V0c2lkZSB0aGUgc3RyZWFtLlxuICAgICAgICAqL1xuICAgICAgICBiZWdpbjogLzxzdHlsZSg/PVxcc3w+KS8sXG4gICAgICAgIGVuZDogLz4vLFxuICAgICAgICBrZXl3b3Jkczoge1xuICAgICAgICAgIG5hbWU6ICdzdHlsZSdcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbnM6IFsgVEFHX0lOVEVSTkFMUyBdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC88XFwvc3R5bGU+LyxcbiAgICAgICAgICByZXR1cm5FbmQ6IHRydWUsXG4gICAgICAgICAgc3ViTGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgICdjc3MnLFxuICAgICAgICAgICAgJ3htbCdcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3RhZycsXG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgPHN0eWxlIHRhZyBhYm91dCB0aGUgbG9va2FoZWFkIHBhdHRlcm5cbiAgICAgICAgYmVnaW46IC88c2NyaXB0KD89XFxzfD4pLyxcbiAgICAgICAgZW5kOiAvPi8sXG4gICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgbmFtZTogJ3NjcmlwdCdcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbnM6IFsgVEFHX0lOVEVSTkFMUyBdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC88XFwvc2NyaXB0Pi8sXG4gICAgICAgICAgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbXG4gICAgICAgICAgICAnamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnaGFuZGxlYmFycycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHdlIG5lZWQgdGhpcyBmb3Igbm93IGZvciBqU1hcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IC88Pnw8XFwvPi9cbiAgICAgIH0sXG4gICAgICAvLyBvcGVuIHRhZ1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogY29uY2F0KFxuICAgICAgICAgIC88LyxcbiAgICAgICAgICBsb29rYWhlYWQoY29uY2F0KFxuICAgICAgICAgICAgVEFHX05BTUVfUkUsXG4gICAgICAgICAgICAvLyA8dGFnLz5cbiAgICAgICAgICAgIC8vIDx0YWc+XG4gICAgICAgICAgICAvLyA8dGFnIC4uLlxuICAgICAgICAgICAgZWl0aGVyKC9cXC8+LywgLz4vLCAvXFxzLylcbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBlbmQ6IC9cXC8/Pi8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBiZWdpbjogVEFHX05BTUVfUkUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBzdGFydHM6IFRBR19JTlRFUk5BTFNcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBjbG9zZSB0YWdcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IGNvbmNhdChcbiAgICAgICAgICAvPFxcLy8sXG4gICAgICAgICAgbG9va2FoZWFkKGNvbmNhdChcbiAgICAgICAgICAgIFRBR19OQU1FX1JFLCAvPi9cbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgYmVnaW46IFRBR19OQU1FX1JFLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLz4vLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHhtbDtcbiJdLCJuYW1lcyI6WyJzb3VyY2UiLCJyZSIsImxvb2thaGVhZCIsImNvbmNhdCIsIm9wdGlvbmFsIiwiYXJncyIsImpvaW5lZCIsIm1hcCIsIngiLCJqb2luIiwiZWl0aGVyIiwieG1sIiwiaGxqcyIsIlRBR19OQU1FX1JFIiwiWE1MX0lERU5UX1JFIiwiWE1MX0VOVElUSUVTIiwiY2xhc3NOYW1lIiwiYmVnaW4iLCJYTUxfTUVUQV9LRVlXT1JEUyIsImNvbnRhaW5zIiwiaWxsZWdhbCIsIlhNTF9NRVRBX1BBUl9LRVlXT1JEUyIsImluaGVyaXQiLCJlbmQiLCJBUE9TX01FVEFfU1RSSU5HX01PREUiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiVEFHX0lOVEVSTkFMUyIsImVuZHNXaXRoUGFyZW50IiwicmVsZXZhbmNlIiwiZW5kc1BhcmVudCIsInZhcmlhbnRzIiwibmFtZSIsImFsaWFzZXMiLCJjYXNlX2luc2Vuc2l0aXZlIiwiQ09NTUVOVCIsImtleXdvcmRzIiwic3RhcnRzIiwicmV0dXJuRW5kIiwic3ViTGFuZ3VhZ2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0csR0FFSDs7O0NBR0MsR0FDRCxTQUFTQSxPQUFPQyxFQUFFO0lBQ2hCLElBQUksQ0FBQ0EsSUFBSSxPQUFPO0lBQ2hCLElBQUksT0FBT0EsT0FBTyxVQUFVLE9BQU9BO0lBRW5DLE9BQU9BLEdBQUdELE1BQU07QUFDbEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRSxVQUFVRCxFQUFFO0lBQ25CLE9BQU9FLE9BQU8sT0FBT0YsSUFBSTtBQUMzQjtBQUVBOzs7Q0FH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O2lCQUFlO2dCQUMzQlUsUUFBUTtvQkFDTmYsS0FBSztvQkFDTGdCLFdBQVc7b0JBQ1hDLGFBQWE7d0JBQ1g7d0JBQ0E7cUJBQ0Q7Z0JBQ0g7WUFDRjtZQUNBO2dCQUNFeEIsV0FBVztnQkFDWCxnRUFBZ0U7Z0JBQ2hFQyxPQUFPO2dCQUNQTSxLQUFLO2dCQUNMYyxVQUFVO29CQUNSSixNQUFNO2dCQUNSO2dCQUNBZCxVQUFVO29CQUFFUztpQkFBZTtnQkFDM0JVLFFBQVE7b0JBQ05mLEtBQUs7b0JBQ0xnQixXQUFXO29CQUNYQyxhQUFhO3dCQUNYO3dCQUNBO3dCQUNBO3FCQUNEO2dCQUNIO1lBQ0Y7WUFDQSwrQkFBK0I7WUFDL0I7Z0JBQ0V4QixXQUFXO2dCQUNYQyxPQUFPO1lBQ1Q7WUFDQSxXQUFXO1lBQ1g7Z0JBQ0VELFdBQVc7Z0JBQ1hDLE9BQU9kLE9BQ0wsS0FDQUQsVUFBVUMsT0FDUlUsYUFDQSxTQUFTO2dCQUNULFFBQVE7Z0JBQ1IsV0FBVztnQkFDWEgsT0FBTyxPQUFPLEtBQUs7Z0JBR3ZCYSxLQUFLO2dCQUNMSixVQUFVO29CQUNSO3dCQUNFSCxXQUFXO3dCQUNYQyxPQUFPSjt3QkFDUGlCLFdBQVc7d0JBQ1hRLFFBQVFWO29CQUNWO2lCQUNEO1lBQ0g7WUFDQSxZQUFZO1lBQ1o7Z0JBQ0VaLFdBQVc7Z0JBQ1hDLE9BQU9kLE9BQ0wsT0FDQUQsVUFBVUMsT0FDUlUsYUFBYTtnQkFHakJNLFVBQVU7b0JBQ1I7d0JBQ0VILFdBQVc7d0JBQ1hDLE9BQU9KO3dCQUNQaUIsV0FBVztvQkFDYjtvQkFDQTt3QkFDRWIsT0FBTzt3QkFDUGEsV0FBVztvQkFDYjtpQkFDRDtZQUNIO1NBQ0Q7SUFDSDtBQUNGO0FBRUFXLE9BQU9DLE9BQU8sR0FBRy9CIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3htbC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/xml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/lib/languages/yaml.js":
/*!*********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/yaml.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/*\nLanguage: YAML\nDescription: Yet Another Markdown Language\nAuthor: Stefan Wienert <stwienert@gmail.com>\nContributors: Carl Baxter <carl@cbax.tech>\nRequires: ruby.js\nWebsite: https://yaml.org\nCategory: common, config\n*/ function yaml(hljs) {\n    var LITERALS = \"true false yes no null\";\n    // YAML spec allows non-reserved URI characters in tags.\n    var URI_CHARACTERS = \"[\\\\w#;/?:@&=+$,.~*'()[\\\\]]+\";\n    // Define keys as starting with a word character\n    // ...containing word chars, spaces, colons, forward-slashes, hyphens and periods\n    // ...and ending with a colon followed immediately by a space, tab or newline.\n    // The YAML spec allows for much more than this, but this covers most use-cases.\n    var KEY = {\n        className: \"attr\",\n        variants: [\n            {\n                begin: \"\\\\w[\\\\w :\\\\/.-]*:(?=[ \t]|$)\"\n            },\n            {\n                begin: '\"\\\\w[\\\\w :\\\\/.-]*\":(?=[ \t]|$)'\n            },\n            {\n                begin: \"'\\\\w[\\\\w :\\\\/.-]*':(?=[ \t]|$)\"\n            } // single quoted keys\n        ]\n    };\n    var TEMPLATE_VARIABLES = {\n        className: \"template-variable\",\n        variants: [\n            {\n                begin: /\\{\\{/,\n                end: /\\}\\}/\n            },\n            {\n                begin: /%\\{/,\n                end: /\\}/\n            } // Ruby i18n\n        ]\n    };\n    var STRING = {\n        className: \"string\",\n        relevance: 0,\n        variants: [\n            {\n                begin: /'/,\n                end: /'/\n            },\n            {\n                begin: /\"/,\n                end: /\"/\n            },\n            {\n                begin: /\\S+/\n            }\n        ],\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            TEMPLATE_VARIABLES\n        ]\n    };\n    // Strings inside of value containers (objects) can't contain braces,\n    // brackets, or commas\n    var CONTAINER_STRING = hljs.inherit(STRING, {\n        variants: [\n            {\n                begin: /'/,\n                end: /'/\n            },\n            {\n                begin: /\"/,\n                end: /\"/\n            },\n            {\n                begin: /[^\\s,{}[\\]]+/\n            }\n        ]\n    });\n    var DATE_RE = \"[0-9]{4}(-[0-9][0-9]){0,2}\";\n    var TIME_RE = \"([Tt \\\\t][0-9][0-9]?(:[0-9][0-9]){2})?\";\n    var FRACTION_RE = \"(\\\\.[0-9]*)?\";\n    var ZONE_RE = \"([ \\\\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\";\n    var TIMESTAMP = {\n        className: \"number\",\n        begin: \"\\\\b\" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + \"\\\\b\"\n    };\n    var VALUE_CONTAINER = {\n        end: \",\",\n        endsWithParent: true,\n        excludeEnd: true,\n        contains: [],\n        keywords: LITERALS,\n        relevance: 0\n    };\n    var OBJECT = {\n        begin: /\\{/,\n        end: /\\}/,\n        contains: [\n            VALUE_CONTAINER\n        ],\n        illegal: \"\\\\n\",\n        relevance: 0\n    };\n    var ARRAY = {\n        begin: \"\\\\[\",\n        end: \"\\\\]\",\n        contains: [\n            VALUE_CONTAINER\n        ],\n        illegal: \"\\\\n\",\n        relevance: 0\n    };\n    var MODES = [\n        KEY,\n        {\n            className: \"meta\",\n            begin: \"^---\\\\s*$\",\n            relevance: 10\n        },\n        {\n            // Blocks start with a | or > followed by a newline\n            //\n            // Indentation of subsequent lines must be the same to\n            // be considered part of the block\n            className: \"string\",\n            begin: \"[\\\\|>]([1-9]?[+-])?[ ]*\\\\n( +)[^ ][^\\\\n]*\\\\n(\\\\2[^\\\\n]+\\\\n?)*\"\n        },\n        {\n            begin: \"<%[%=-]?\",\n            end: \"[%-]?%>\",\n            subLanguage: \"ruby\",\n            excludeBegin: true,\n            excludeEnd: true,\n            relevance: 0\n        },\n        {\n            className: \"type\",\n            begin: \"!\\\\w+!\" + URI_CHARACTERS\n        },\n        // https://yaml.org/spec/1.2/spec.html#id2784064\n        {\n            className: \"type\",\n            begin: \"!<\" + URI_CHARACTERS + \">\"\n        },\n        {\n            className: \"type\",\n            begin: \"!\" + URI_CHARACTERS\n        },\n        {\n            className: \"type\",\n            begin: \"!!\" + URI_CHARACTERS\n        },\n        {\n            className: \"meta\",\n            begin: \"&\" + hljs.UNDERSCORE_IDENT_RE + \"$\"\n        },\n        {\n            className: \"meta\",\n            begin: \"\\\\*\" + hljs.UNDERSCORE_IDENT_RE + \"$\"\n        },\n        {\n            className: \"bullet\",\n            // TODO: remove |$ hack when we have proper look-ahead support\n            begin: \"-(?=[ ]|$)\",\n            relevance: 0\n        },\n        hljs.HASH_COMMENT_MODE,\n        {\n            beginKeywords: LITERALS,\n            keywords: {\n                literal: LITERALS\n            }\n        },\n        TIMESTAMP,\n        // numbers are any valid C-style number that\n        // sit isolated from other words\n        {\n            className: \"number\",\n            begin: hljs.C_NUMBER_RE + \"\\\\b\",\n            relevance: 0\n        },\n        OBJECT,\n        ARRAY,\n        STRING\n    ];\n    var VALUE_MODES = [\n        ...MODES\n    ];\n    VALUE_MODES.pop();\n    VALUE_MODES.push(CONTAINER_STRING);\n    VALUE_CONTAINER.contains = VALUE_MODES;\n    return {\n        name: \"YAML\",\n        case_insensitive: true,\n        aliases: [\n            \"yml\",\n            \"YAML\"\n        ],\n        contains: MODES\n    };\n}\nmodule.exports = yaml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3lhbWwuanM/ZjIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTGFuZ3VhZ2U6IFlBTUxcbkRlc2NyaXB0aW9uOiBZZXQgQW5vdGhlciBNYXJrZG93biBMYW5ndWFnZVxuQXV0aG9yOiBTdGVmYW4gV2llbmVydCA8c3R3aWVuZXJ0QGdtYWlsLmNvbT5cbkNvbnRyaWJ1dG9yczogQ2FybCBCYXh0ZXIgPGNhcmxAY2JheC50ZWNoPlxuUmVxdWlyZXM6IHJ1YnkuanNcbldlYnNpdGU6IGh0dHBzOi8veWFtbC5vcmdcbkNhdGVnb3J5OiBjb21tb24sIGNvbmZpZ1xuKi9cbmZ1bmN0aW9uIHlhbWwoaGxqcykge1xuICB2YXIgTElURVJBTFMgPSAndHJ1ZSBmYWxzZSB5ZXMgbm8gbnVsbCc7XG5cbiAgLy8gWUFNTCBzcGVjIGFsbG93cyBub24tcmVzZXJ2ZWQgVVJJIGNoYXJhY3RlcnMgaW4gdGFncy5cbiAgdmFyIFVSSV9DSEFSQUNURVJTID0gJ1tcXFxcdyM7Lz86QCY9KyQsLn4qXFwnKClbXFxcXF1dKyc7XG5cbiAgLy8gRGVmaW5lIGtleXMgYXMgc3RhcnRpbmcgd2l0aCBhIHdvcmQgY2hhcmFjdGVyXG4gIC8vIC4uLmNvbnRhaW5pbmcgd29yZCBjaGFycywgc3BhY2VzLCBjb2xvbnMsIGZvcndhcmQtc2xhc2hlcywgaHlwaGVucyBhbmQgcGVyaW9kc1xuICAvLyAuLi5hbmQgZW5kaW5nIHdpdGggYSBjb2xvbiBmb2xsb3dlZCBpbW1lZGlhdGVseSBieSBhIHNwYWNlLCB0YWIgb3IgbmV3bGluZS5cbiAgLy8gVGhlIFlBTUwgc3BlYyBhbGxvd3MgZm9yIG11Y2ggbW9yZSB0aGFuIHRoaXMsIGJ1dCB0aGlzIGNvdmVycyBtb3N0IHVzZS1jYXNlcy5cbiAgdmFyIEtFWSA9IHtcbiAgICBjbGFzc05hbWU6ICdhdHRyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgeyBiZWdpbjogJ1xcXFx3W1xcXFx3IDpcXFxcLy4tXSo6KD89WyBcXHRdfCQpJyB9LFxuICAgICAgeyBiZWdpbjogJ1wiXFxcXHdbXFxcXHcgOlxcXFwvLi1dKlwiOig/PVsgXFx0XXwkKScgfSwgLy8gZG91YmxlIHF1b3RlZCBrZXlzXG4gICAgICB7IGJlZ2luOiAnXFwnXFxcXHdbXFxcXHcgOlxcXFwvLi1dKlxcJzooPz1bIFxcdF18JCknIH0gLy8gc2luZ2xlIHF1b3RlZCBrZXlzXG4gICAgXVxuICB9O1xuXG4gIHZhciBURU1QTEFURV9WQVJJQUJMRVMgPSB7XG4gICAgY2xhc3NOYW1lOiAndGVtcGxhdGUtdmFyaWFibGUnLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAvXFx7XFx7LywgZW5kOiAvXFx9XFx9LyB9LCAvLyBqaW5qYSB0ZW1wbGF0ZXMgQW5zaWJsZVxuICAgICAgeyBiZWdpbjogLyVcXHsvLCBlbmQ6IC9cXH0vIH0gLy8gUnVieSBpMThuXG4gICAgXVxuICB9O1xuICB2YXIgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAvJy8sIGVuZDogLycvIH0sXG4gICAgICB7IGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8gfSxcbiAgICAgIHsgYmVnaW46IC9cXFMrLyB9XG4gICAgXSxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgVEVNUExBVEVfVkFSSUFCTEVTXG4gICAgXVxuICB9O1xuXG4gIC8vIFN0cmluZ3MgaW5zaWRlIG9mIHZhbHVlIGNvbnRhaW5lcnMgKG9iamVjdHMpIGNhbid0IGNvbnRhaW4gYnJhY2VzLFxuICAvLyBicmFja2V0cywgb3IgY29tbWFzXG4gIHZhciBDT05UQUlORVJfU1RSSU5HID0gaGxqcy5pbmhlcml0KFNUUklORywge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAvJy8sIGVuZDogLycvIH0sXG4gICAgICB7IGJlZ2luOiAvXCIvLCBlbmQ6IC9cIi8gfSxcbiAgICAgIHsgYmVnaW46IC9bXlxccyx7fVtcXF1dKy8gfVxuICAgIF1cbiAgfSk7XG5cbiAgdmFyIERBVEVfUkUgPSAnWzAtOV17NH0oLVswLTldWzAtOV0pezAsMn0nO1xuICB2YXIgVElNRV9SRSA9ICcoW1R0IFxcXFx0XVswLTldWzAtOV0/KDpbMC05XVswLTldKXsyfSk/JztcbiAgdmFyIEZSQUNUSU9OX1JFID0gJyhcXFxcLlswLTldKik/JztcbiAgdmFyIFpPTkVfUkUgPSAnKFsgXFxcXHRdKSooWnxbLStdWzAtOV1bMC05XT8oOlswLTldWzAtOV0pPyk/JztcbiAgdmFyIFRJTUVTVEFNUCA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIGJlZ2luOiAnXFxcXGInICsgREFURV9SRSArIFRJTUVfUkUgKyBGUkFDVElPTl9SRSArIFpPTkVfUkUgKyAnXFxcXGInXG4gIH07XG5cbiAgdmFyIFZBTFVFX0NPTlRBSU5FUiA9IHtcbiAgICBlbmQ6ICcsJyxcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbXSxcbiAgICBrZXl3b3JkczogTElURVJBTFMsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBPQkpFQ1QgPSB7XG4gICAgYmVnaW46IC9cXHsvLFxuICAgIGVuZDogL1xcfS8sXG4gICAgY29udGFpbnM6IFtWQUxVRV9DT05UQUlORVJdLFxuICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIHZhciBBUlJBWSA9IHtcbiAgICBiZWdpbjogJ1xcXFxbJyxcbiAgICBlbmQ6ICdcXFxcXScsXG4gICAgY29udGFpbnM6IFtWQUxVRV9DT05UQUlORVJdLFxuICAgIGlsbGVnYWw6ICdcXFxcbicsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgdmFyIE1PREVTID0gW1xuICAgIEtFWSxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgIGJlZ2luOiAnXi0tLVxcXFxzKiQnLFxuICAgICAgcmVsZXZhbmNlOiAxMFxuICAgIH0sXG4gICAgeyAvLyBtdWx0aSBsaW5lIHN0cmluZ1xuICAgICAgLy8gQmxvY2tzIHN0YXJ0IHdpdGggYSB8IG9yID4gZm9sbG93ZWQgYnkgYSBuZXdsaW5lXG4gICAgICAvL1xuICAgICAgLy8gSW5kZW50YXRpb24gb2Ygc3Vic2VxdWVudCBsaW5lcyBtdXN0IGJlIHRoZSBzYW1lIHRvXG4gICAgICAvLyBiZSBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGJsb2NrXG4gICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgYmVnaW46ICdbXFxcXHw+XShbMS05XT9bKy1dKT9bIF0qXFxcXG4oICspW14gXVteXFxcXG5dKlxcXFxuKFxcXFwyW15cXFxcbl0rXFxcXG4/KSonXG4gICAgfSxcbiAgICB7IC8vIFJ1YnkvUmFpbHMgZXJiXG4gICAgICBiZWdpbjogJzwlWyU9LV0/JyxcbiAgICAgIGVuZDogJ1slLV0/JT4nLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICdydWJ5JyxcbiAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIHsgLy8gbmFtZWQgdGFnc1xuICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICBiZWdpbjogJyFcXFxcdyshJyArIFVSSV9DSEFSQUNURVJTXG4gICAgfSxcbiAgICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3ODQwNjRcbiAgICB7IC8vIHZlcmJhdGltIHRhZ3NcbiAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgYmVnaW46ICchPCcgKyBVUklfQ0hBUkFDVEVSUyArIFwiPlwiXG4gICAgfSxcbiAgICB7IC8vIHByaW1hcnkgdGFnc1xuICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICBiZWdpbjogJyEnICsgVVJJX0NIQVJBQ1RFUlNcbiAgICB9LFxuICAgIHsgLy8gc2Vjb25kYXJ5IHRhZ3NcbiAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgYmVnaW46ICchIScgKyBVUklfQ0hBUkFDVEVSU1xuICAgIH0sXG4gICAgeyAvLyBmcmFnbWVudCBpZCAmcmVmXG4gICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgIGJlZ2luOiAnJicgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnJCdcbiAgICB9LFxuICAgIHsgLy8gZnJhZ21lbnQgcmVmZXJlbmNlICpyZWZcbiAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgYmVnaW46ICdcXFxcKicgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnJCdcbiAgICB9LFxuICAgIHsgLy8gYXJyYXkgbGlzdGluZ1xuICAgICAgY2xhc3NOYW1lOiAnYnVsbGV0JyxcbiAgICAgIC8vIFRPRE86IHJlbW92ZSB8JCBoYWNrIHdoZW4gd2UgaGF2ZSBwcm9wZXIgbG9vay1haGVhZCBzdXBwb3J0XG4gICAgICBiZWdpbjogJy0oPz1bIF18JCknLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSxcbiAgICBobGpzLkhBU0hfQ09NTUVOVF9NT0RFLFxuICAgIHtcbiAgICAgIGJlZ2luS2V5d29yZHM6IExJVEVSQUxTLFxuICAgICAga2V5d29yZHM6IHsgbGl0ZXJhbDogTElURVJBTFMgfVxuICAgIH0sXG4gICAgVElNRVNUQU1QLFxuICAgIC8vIG51bWJlcnMgYXJlIGFueSB2YWxpZCBDLXN0eWxlIG51bWJlciB0aGF0XG4gICAgLy8gc2l0IGlzb2xhdGVkIGZyb20gb3RoZXIgd29yZHNcbiAgICB7XG4gICAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgICAgYmVnaW46IGhsanMuQ19OVU1CRVJfUkUgKyAnXFxcXGInLFxuICAgICAgcmVsZXZhbmNlOiAwXG4gICAgfSxcbiAgICBPQkpFQ1QsXG4gICAgQVJSQVksXG4gICAgU1RSSU5HXG4gIF07XG5cbiAgdmFyIFZBTFVFX01PREVTID0gWy4uLk1PREVTXTtcbiAgVkFMVUVfTU9ERVMucG9wKCk7XG4gIFZBTFVFX01PREVTLnB1c2goQ09OVEFJTkVSX1NUUklORyk7XG4gIFZBTFVFX0NPTlRBSU5FUi5jb250YWlucyA9IFZBTFVFX01PREVTO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1lBTUwnLFxuICAgIGNhc2VfaW5zZW5zaXRpdmU6IHRydWUsXG4gICAgYWxpYXNlczogWyd5bWwnLCAnWUFNTCddLFxuICAgIGNvbnRhaW5zOiBNT0RFU1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iXSwibmFtZXMiOlsieWFtbCIsImhsanMiLCJMSVRFUkFMUyIsIlVSSV9DSEFSQUNURVJTIiwiS0VZIiwiY2xhc3NOYW1lIiwidmFyaWFudHMiLCJiZWdpbiIsIlRFTVBMQVRFX1ZBUklBQkxFUyIsImVuZCIsIlNUUklORyIsInJlbGV2YW5jZSIsImNvbnRhaW5zIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkNPTlRBSU5FUl9TVFJJTkciLCJpbmhlcml0IiwiREFURV9SRSIsIlRJTUVfUkUiLCJGUkFDVElPTl9SRSIsIlpPTkVfUkUiLCJUSU1FU1RBTVAiLCJWQUxVRV9DT05UQUlORVIiLCJlbmRzV2l0aFBhcmVudCIsImV4Y2x1ZGVFbmQiLCJrZXl3b3JkcyIsIk9CSkVDVCIsImlsbGVnYWwiLCJBUlJBWSIsIk1PREVTIiwic3ViTGFuZ3VhZ2UiLCJleGNsdWRlQmVnaW4iLCJVTkRFUlNDT1JFX0lERU5UX1JFIiwiSEFTSF9DT01NRU5UX01PREUiLCJiZWdpbktleXdvcmRzIiwibGl0ZXJhbCIsIkNfTlVNQkVSX1JFIiwiVkFMVUVfTU9ERVMiLCJwb3AiLCJwdXNoIiwibmFtZSIsImNhc2VfaW5zZW5zaXRpdmUiLCJhbGlhc2VzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBUUEsR0FDQSxTQUFTQSxLQUFLQyxJQUFJO0lBQ2hCLElBQUlDLFdBQVc7SUFFZix3REFBd0Q7SUFDeEQsSUFBSUMsaUJBQWlCO0lBRXJCLGdEQUFnRDtJQUNoRCxpRkFBaUY7SUFDakYsOEVBQThFO0lBQzlFLGdGQUFnRjtJQUNoRixJQUFJQyxNQUFNO1FBQ1JDLFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUFFQyxPQUFPO1lBQStCO1lBQ3hDO2dCQUFFQSxPQUFPO1lBQWlDO1lBQzFDO2dCQUFFQSxPQUFPO1lBQW1DLEVBQUUscUJBQXFCO1NBQ3BFO0lBQ0g7SUFFQSxJQUFJQyxxQkFBcUI7UUFDdkJILFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUFFQyxPQUFPO2dCQUFRRSxLQUFLO1lBQU87WUFDN0I7Z0JBQUVGLE9BQU87Z0JBQU9FLEtBQUs7WUFBSyxFQUFFLFlBQVk7U0FDekM7SUFDSDtJQUNBLElBQUlDLFNBQVM7UUFDWEwsV0FBVztRQUNYTSxXQUFXO1FBQ1hMLFVBQVU7WUFDUjtnQkFBRUMsT0FBTztnQkFBS0UsS0FBSztZQUFJO1lBQ3ZCO2dCQUFFRixPQUFPO2dCQUFLRSxLQUFLO1lBQUk7WUFDdkI7Z0JBQUVGLE9BQU87WUFBTTtTQUNoQjtRQUNESyxVQUFVO1lBQ1JYLEtBQUtZLGdCQUFnQjtZQUNyQkw7U0FDRDtJQUNIO0lBRUEscUVBQXFFO0lBQ3JFLHNCQUFzQjtJQUN0QixJQUFJTSxtQkFBbUJiLEtBQUtjLE9BQU8sQ0FBQ0wsUUFBUTtRQUMxQ0osVUFBVTtZQUNSO2dCQUFFQyxPQUFPO2dCQUFLRSxLQUFLO1lBQUk7WUFDdkI7Z0JBQUVGLE9BQU87Z0JBQUtFLEtBQUs7WUFBSTtZQUN2QjtnQkFBRUYsT0FBTztZQUFlO1NBQ3pCO0lBQ0g7SUFFQSxJQUFJUyxVQUFVO0lBQ2QsSUFBSUMsVUFBVTtJQUNkLElBQUlDLGNBQWM7SUFDbEIsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFlBQVk7UUFDZGYsV0FBVztRQUNYRSxPQUFPLFFBQVFTLFVBQVVDLFVBQVVDLGNBQWNDLFVBQVU7SUFDN0Q7SUFFQSxJQUFJRSxrQkFBa0I7UUFDcEJaLEtBQUs7UUFDTGEsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pYLFVBQVUsRUFBRTtRQUNaWSxVQUFVdEI7UUFDVlMsV0FBVztJQUNiO0lBQ0EsSUFBSWMsU0FBUztRQUNYbEIsT0FBTztRQUNQRSxLQUFLO1FBQ0xHLFVBQVU7WUFBQ1M7U0FBZ0I7UUFDM0JLLFNBQVM7UUFDVGYsV0FBVztJQUNiO0lBQ0EsSUFBSWdCLFFBQVE7UUFDVnBCLE9BQU87UUFDUEUsS0FBSztRQUNMRyxVQUFVO1lBQUNTO1NBQWdCO1FBQzNCSyxTQUFTO1FBQ1RmLFdBQVc7SUFDYjtJQUVBLElBQUlpQixRQUFRO1FBQ1Z4QjtRQUNBO1lBQ0VDLFdBQVc7WUFDWEUsT0FBTztZQUNQSSxXQUFXO1FBQ2I7UUFDQTtZQUNFLG1EQUFtRDtZQUNuRCxFQUFFO1lBQ0Ysc0RBQXNEO1lBQ3RELGtDQUFrQztZQUNsQ04sV0FBVztZQUNYRSxPQUFPO1FBQ1Q7UUFDQTtZQUNFQSxPQUFPO1lBQ1BFLEtBQUs7WUFDTG9CLGFBQWE7WUFDYkMsY0FBYztZQUNkUCxZQUFZO1lBQ1paLFdBQVc7UUFDYjtRQUNBO1lBQ0VOLFdBQVc7WUFDWEUsT0FBTyxXQUFXSjtRQUNwQjtRQUNBLGdEQUFnRDtRQUNoRDtZQUNFRSxXQUFXO1lBQ1hFLE9BQU8sT0FBT0osaUJBQWlCO1FBQ2pDO1FBQ0E7WUFDRUUsV0FBVztZQUNYRSxPQUFPLE1BQU1KO1FBQ2Y7UUFDQTtZQUNFRSxXQUFXO1lBQ1hFLE9BQU8sT0FBT0o7UUFDaEI7UUFDQTtZQUNFRSxXQUFXO1lBQ1hFLE9BQU8sTUFBTU4sS0FBSzhCLG1CQUFtQixHQUFHO1FBQzFDO1FBQ0E7WUFDRTFCLFdBQVc7WUFDWEUsT0FBTyxRQUFRTixLQUFLOEIsbUJBQW1CLEdBQUc7UUFDNUM7UUFDQTtZQUNFMUIsV0FBVztZQUNYLDhEQUE4RDtZQUM5REUsT0FBTztZQUNQSSxXQUFXO1FBQ2I7UUFDQVYsS0FBSytCLGlCQUFpQjtRQUN0QjtZQUNFQyxlQUFlL0I7WUFDZnNCLFVBQVU7Z0JBQUVVLFNBQVNoQztZQUFTO1FBQ2hDO1FBQ0FrQjtRQUNBLDRDQUE0QztRQUM1QyxnQ0FBZ0M7UUFDaEM7WUFDRWYsV0FBVztZQUNYRSxPQUFPTixLQUFLa0MsV0FBVyxHQUFHO1lBQzFCeEIsV0FBVztRQUNiO1FBQ0FjO1FBQ0FFO1FBQ0FqQjtLQUNEO0lBRUQsSUFBSTBCLGNBQWM7V0FBSVI7S0FBTTtJQUM1QlEsWUFBWUMsR0FBRztJQUNmRCxZQUFZRSxJQUFJLENBQUN4QjtJQUNqQk8sZ0JBQWdCVCxRQUFRLEdBQUd3QjtJQUUzQixPQUFPO1FBQ0xHLE1BQU07UUFDTkMsa0JBQWtCO1FBQ2xCQyxTQUFTO1lBQUM7WUFBTztTQUFPO1FBQ3hCN0IsVUFBVWdCO0lBQ1o7QUFDRjtBQUVBYyxPQUFPQyxPQUFPLEdBQUczQyIsImZpbGUiOiIoc3NyKS8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvbGliL2xhbmd1YWdlcy95YW1sLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/languages/yaml.js\n");

/***/ })

};
;