"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polished";
exports.ids = ["vendor-chunks/polished"];
exports.modules = {

/***/ "(ssr)/./node_modules/polished/dist/polished.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/polished/dist/polished.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustHue: () => (/* binding */ curriedAdjustHue$1),\n/* harmony export */   animation: () => (/* binding */ animation),\n/* harmony export */   backgroundImages: () => (/* binding */ backgroundImages),\n/* harmony export */   backgrounds: () => (/* binding */ backgrounds),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   border: () => (/* binding */ border),\n/* harmony export */   borderColor: () => (/* binding */ borderColor),\n/* harmony export */   borderRadius: () => (/* binding */ borderRadius),\n/* harmony export */   borderStyle: () => (/* binding */ borderStyle),\n/* harmony export */   borderWidth: () => (/* binding */ borderWidth),\n/* harmony export */   buttons: () => (/* binding */ buttons),\n/* harmony export */   clearFix: () => (/* binding */ clearFix),\n/* harmony export */   complement: () => (/* binding */ complement),\n/* harmony export */   cover: () => (/* binding */ cover),\n/* harmony export */   cssVar: () => (/* binding */ cssVar),\n/* harmony export */   darken: () => (/* binding */ curriedDarken$1),\n/* harmony export */   desaturate: () => (/* binding */ curriedDesaturate$1),\n/* harmony export */   directionalProperty: () => (/* binding */ directionalProperty),\n/* harmony export */   easeIn: () => (/* binding */ easeIn),\n/* harmony export */   easeInOut: () => (/* binding */ easeInOut),\n/* harmony export */   easeOut: () => (/* binding */ easeOut),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   em: () => (/* binding */ em$1),\n/* harmony export */   fluidRange: () => (/* binding */ fluidRange),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   getContrast: () => (/* binding */ getContrast),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   getValueAndUnit: () => (/* binding */ getValueAndUnit),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   hiDPI: () => (/* binding */ hiDPI),\n/* harmony export */   hideText: () => (/* binding */ hideText),\n/* harmony export */   hideVisually: () => (/* binding */ hideVisually),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hslToColorString: () => (/* binding */ hslToColorString),\n/* harmony export */   hsla: () => (/* binding */ hsla),\n/* harmony export */   important: () => (/* binding */ important),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   lighten: () => (/* binding */ curriedLighten$1),\n/* harmony export */   linearGradient: () => (/* binding */ linearGradient),\n/* harmony export */   margin: () => (/* binding */ margin),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   meetsContrastGuidelines: () => (/* binding */ meetsContrastGuidelines),\n/* harmony export */   mix: () => (/* binding */ mix$1),\n/* harmony export */   modularScale: () => (/* binding */ modularScale),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   opacify: () => (/* binding */ curriedOpacify$1),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   parseToHsl: () => (/* binding */ parseToHsl),\n/* harmony export */   parseToRgb: () => (/* binding */ parseToRgb),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   radialGradient: () => (/* binding */ radialGradient),\n/* harmony export */   readableColor: () => (/* binding */ readableColor),\n/* harmony export */   rem: () => (/* binding */ rem$1),\n/* harmony export */   remToPx: () => (/* binding */ remToPx),\n/* harmony export */   retinaImage: () => (/* binding */ retinaImage),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   rgbToColorString: () => (/* binding */ rgbToColorString),\n/* harmony export */   rgba: () => (/* binding */ rgba),\n/* harmony export */   saturate: () => (/* binding */ curriedSaturate$1),\n/* harmony export */   setHue: () => (/* binding */ curriedSetHue$1),\n/* harmony export */   setLightness: () => (/* binding */ curriedSetLightness$1),\n/* harmony export */   setSaturation: () => (/* binding */ curriedSetSaturation$1),\n/* harmony export */   shade: () => (/* binding */ curriedShade$1),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stripUnit: () => (/* binding */ stripUnit),\n/* harmony export */   textInputs: () => (/* binding */ textInputs),\n/* harmony export */   timingFunctions: () => (/* binding */ timingFunctions),\n/* harmony export */   tint: () => (/* binding */ curriedTint$1),\n/* harmony export */   toColorString: () => (/* binding */ toColorString),\n/* harmony export */   transitions: () => (/* binding */ transitions),\n/* harmony export */   transparentize: () => (/* binding */ curriedTransparentize$1),\n/* harmony export */   triangle: () => (/* binding */ triangle),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteralLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\");\n\n\n\n\n\nfunction last() {\n    var _ref;\n    return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n    return -a;\n}\nfunction addition(a, b) {\n    return a + b;\n}\nfunction subtraction(a, b) {\n    return a - b;\n}\nfunction multiplication(a, b) {\n    return a * b;\n}\nfunction division(a, b) {\n    return a / b;\n}\nfunction max() {\n    return Math.max.apply(Math, arguments);\n}\nfunction min() {\n    return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n    return Array.of.apply(Array, arguments);\n}\nvar defaultSymbols = {\n    symbols: {\n        \"*\": {\n            infix: {\n                symbol: \"*\",\n                f: multiplication,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"*\",\n            regSymbol: \"\\\\*\"\n        },\n        \"/\": {\n            infix: {\n                symbol: \"/\",\n                f: division,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"/\",\n            regSymbol: \"/\"\n        },\n        \"+\": {\n            infix: {\n                symbol: \"+\",\n                f: addition,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"+\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"+\",\n            regSymbol: \"\\\\+\"\n        },\n        \"-\": {\n            infix: {\n                symbol: \"-\",\n                f: subtraction,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"-\",\n                f: negation,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"-\",\n            regSymbol: \"-\"\n        },\n        \",\": {\n            infix: {\n                symbol: \",\",\n                f: comma,\n                notation: \"infix\",\n                precedence: 1,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \",\",\n            regSymbol: \",\"\n        },\n        \"(\": {\n            prefix: {\n                symbol: \"(\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"(\",\n            regSymbol: \"\\\\(\"\n        },\n        \")\": {\n            postfix: {\n                symbol: \")\",\n                f: undefined,\n                notation: \"postfix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \")\",\n            regSymbol: \"\\\\)\"\n        },\n        min: {\n            func: {\n                symbol: \"min\",\n                f: min,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"min\",\n            regSymbol: \"min\\\\b\"\n        },\n        max: {\n            func: {\n                symbol: \"max\",\n                f: max,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"max\",\n            regSymbol: \"max\\\\b\"\n        }\n    }\n};\nvar defaultSymbolMap = defaultSymbols;\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */ var ERRORS = {\n    \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n    \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n    \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n    \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n    \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n    \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n    \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n    \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n    \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"11\": 'Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\\n\\n',\n    \"12\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\\n\\n',\n    \"13\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n    \"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"15\": 'Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"16\": \"You must provide a template to this method.\\n\\n\",\n    \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n    \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"35\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"36\": \"Property must be a string value.\\n\\n\",\n    \"37\": \"Syntax Error at %s.\\n\\n\",\n    \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n    \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n    \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n    \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n    \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n    \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n    \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n    \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"61\": \"Property must be a string value.\\n\\n\",\n    \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"63\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n    \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"67\": \"You must provide a template to this method.\\n\\n\",\n    \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"69\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\\n\\n',\n    \"70\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\\n\\n',\n    \"71\": 'Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"72\": 'Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"73\": \"Please provide a valid CSS variable.\\n\\n\",\n    \"74\": \"CSS variable not found and no default was provided.\\n\\n\",\n    \"75\": \"important requires a valid style object, got a %s instead.\\n\\n\",\n    \"76\": \"fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\\n\\n\",\n    \"77\": 'remToPx expects a value in \"rem\" but you provided it in \"%s\".\\n\\n',\n    \"78\": 'base must be set in \"px\" or \"%\" but you set it in \"%s\".\\n'\n};\n/**\n * super basic version of sprintf\n * @private\n */ function format() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var a = args[0];\n    var b = [];\n    var c;\n    for(c = 1; c < args.length; c += 1){\n        b.push(args[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */ var PolishedError = /*#__PURE__*/ function(_Error) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PolishedError, _Error);\n    function PolishedError(code) {\n        var _this;\n        if (false) {} else {\n            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                args[_key2 - 1] = arguments[_key2];\n            }\n            _this = _Error.call(this, format.apply(void 0, [\n                ERRORS[code]\n            ].concat(args))) || this;\n        }\n        return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this);\n    }\n    return PolishedError;\n}(/*#__PURE__*/ (0,_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Error));\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g; // Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n    var symbolMap = {};\n    symbolMap.symbols = additionalSymbols ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols);\n    return symbolMap;\n}\nfunction exec(operators, values) {\n    var _ref;\n    var op = operators.pop();\n    values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n    return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n    var symbolMap = mergeSymbolMaps(additionalSymbols);\n    var match;\n    var operators = [\n        symbolMap.symbols[\"(\"].prefix\n    ];\n    var values = [];\n    var pattern = new RegExp(\"\\\\d+(?:\\\\.\\\\d+)?|\" + // ...and patterns for individual operators/function names\n    Object.keys(symbolMap.symbols).map(function(key) {\n        return symbolMap.symbols[key];\n    }) // longer symbols should be listed first\n    // $FlowFixMe\n    .sort(function(a, b) {\n        return b.symbol.length - a.symbol.length;\n    }) // $FlowFixMe\n    .map(function(val) {\n        return val.regSymbol;\n    }).join(\"|\") + \"|(\\\\S)\", \"g\");\n    pattern.lastIndex = 0; // Reset regular expression object\n    var afterValue = false;\n    do {\n        match = pattern.exec(expression);\n        var _ref2 = match || [\n            \")\",\n            undefined\n        ], token = _ref2[0], bad = _ref2[1];\n        var notNumber = symbolMap.symbols[token];\n        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix; // Check for syntax errors:\n        if (bad || (afterValue ? notAfterValue : notNewValue)) {\n            throw new PolishedError(37, match ? match.index : expression.length, expression);\n        }\n        if (afterValue) {\n            // We either have an infix or postfix operator (they should be mutually exclusive)\n            var curr = notNumber.postfix || notNumber.infix;\n            do {\n                var prev = operators[operators.length - 1];\n                if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break; // Apply previous operator, since it has precedence over current one\n            }while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n            afterValue = curr.notation === \"postfix\";\n            if (curr.symbol !== \")\") {\n                operators.push(curr); // Postfix always has precedence over any operator that follows after it\n                if (afterValue) exec(operators, values);\n            }\n        } else if (notNumber) {\n            // prefix operator or function\n            operators.push(notNumber.prefix || notNumber.func);\n            if (notNumber.func) {\n                // Require an opening parenthesis\n                match = pattern.exec(expression);\n                if (!match || match[0] !== \"(\") {\n                    throw new PolishedError(38, match ? match.index : expression.length, expression);\n                }\n            }\n        } else {\n            // number\n            values.push(+token);\n            afterValue = true;\n        }\n    }while (match && operators.length);\n    if (operators.length) {\n        throw new PolishedError(39, match ? match.index : expression.length, expression);\n    } else if (match) {\n        throw new PolishedError(40, match ? match.index : expression.length, expression);\n    } else {\n        return values.pop();\n    }\n}\nfunction reverseString(str) {\n    return str.split(\"\").reverse().join(\"\");\n}\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */ function math(formula, additionalSymbols) {\n    var reversedFormula = reverseString(formula);\n    var formulaMatch = reversedFormula.match(unitRegExp); // Check that all units are the same\n    if (formulaMatch && !formulaMatch.every(function(unit) {\n        return unit === formulaMatch[0];\n    })) {\n        throw new PolishedError(41);\n    }\n    var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, \"\"));\n    return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : \"\");\n}\nvar cssVariableRegex = /--[\\S]*/g;\n/**\n * Fetches the value of a passed CSS Variable in the :root scope, or otherwise returns a defaultValue if provided.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'background': cssVar('--background-color'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${cssVar('--background-color')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'background': 'red'\n * }\n */ function cssVar(cssVariable, defaultValue) {\n    if (!cssVariable || !cssVariable.match(cssVariableRegex)) {\n        throw new PolishedError(73);\n    }\n    var variableValue;\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);\n    }\n    /* eslint-enable */ if (variableValue) {\n        return variableValue.trim();\n    } else if (defaultValue) {\n        return defaultValue;\n    }\n    throw new PolishedError(74);\n}\n// @private\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nvar positionMap$1 = [\n    \"Top\",\n    \"Right\",\n    \"Bottom\",\n    \"Left\"\n];\nfunction generateProperty(property, position) {\n    if (!property) return position.toLowerCase();\n    var splitProperty = property.split(\"-\");\n    if (splitProperty.length > 1) {\n        splitProperty.splice(1, 0, position);\n        return splitProperty.reduce(function(acc, val) {\n            return \"\" + acc + capitalizeString(val);\n        });\n    }\n    var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n    return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n    var styles = {};\n    for(var i = 0; i < valuesWithDefaults.length; i += 1){\n        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n            styles[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];\n        }\n    }\n    return styles;\n}\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function directionalProperty(property) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    //  prettier-ignore\n    var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n    var valuesWithDefaults = [\n        firstValue,\n        secondValue,\n        thirdValue,\n        fourthValue\n    ];\n    return generateStyles(property, valuesWithDefaults);\n}\n/**\n * Check if a string ends with something\n * @private\n */ function endsWith(string, suffix) {\n    return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value minus its unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100\n * }\n */ function stripUnit(value) {\n    if (typeof value !== \"string\") return value;\n    var matchedValue = value.match(cssRegex$1);\n    return matchedValue ? parseFloat(value) : value;\n}\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */ var pxtoFactory = function pxtoFactory(to) {\n    return function(pxval, base) {\n        if (base === void 0) {\n            base = \"16px\";\n        }\n        var newPxval = pxval;\n        var newBase = base;\n        if (typeof pxval === \"string\") {\n            if (!endsWith(pxval, \"px\")) {\n                throw new PolishedError(69, to, pxval);\n            }\n            newPxval = stripUnit(pxval);\n        }\n        if (typeof base === \"string\") {\n            if (!endsWith(base, \"px\")) {\n                throw new PolishedError(70, to, base);\n            }\n            newBase = stripUnit(base);\n        }\n        if (typeof newPxval === \"string\") {\n            throw new PolishedError(71, pxval, to);\n        }\n        if (typeof newBase === \"string\") {\n            throw new PolishedError(72, base, to);\n        }\n        return \"\" + newPxval / newBase + to;\n    };\n};\nvar pixelsto = pxtoFactory;\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */ var em = /*#__PURE__*/ pixelsto(\"em\");\nvar em$1 = em;\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function getValueAndUnit(value) {\n    if (typeof value !== \"string\") return [\n        value,\n        \"\"\n    ];\n    var matchedValue = value.match(cssRegex);\n    if (matchedValue) return [\n        parseFloat(value),\n        matchedValue[2]\n    ];\n    return [\n        value,\n        undefined\n    ];\n}\n/**\n * Helper for targeting rules in a style block generated by polished modules that need !important-level specificity. Can optionally specify a rule (or rules) to target specific rules.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...important(cover())\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${important(cover())}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute !important',\n *   'top': '0 !important',\n *   'right: '0 !important',\n *   'bottom': '0 !important',\n *   'left: '0 !important'\n * }\n */ function important(styleBlock, rules) {\n    if (typeof styleBlock !== \"object\" || styleBlock === null) {\n        throw new PolishedError(75, typeof styleBlock);\n    }\n    var newStyleBlock = {};\n    Object.keys(styleBlock).forEach(function(key) {\n        if (typeof styleBlock[key] === \"object\" && styleBlock[key] !== null) {\n            newStyleBlock[key] = important(styleBlock[key], rules);\n        } else if (!rules || rules && (rules === key || rules.indexOf(key) >= 0)) {\n            newStyleBlock[key] = styleBlock[key] + \" !important\";\n        } else {\n            newStyleBlock[key] = styleBlock[key];\n        }\n    });\n    return newStyleBlock;\n}\nvar ratioNames = {\n    minorSecond: 1.067,\n    majorSecond: 1.125,\n    minorThird: 1.2,\n    majorThird: 1.25,\n    perfectFourth: 1.333,\n    augFourth: 1.414,\n    perfectFifth: 1.5,\n    minorSixth: 1.6,\n    goldenSection: 1.618,\n    majorSixth: 1.667,\n    minorSeventh: 1.778,\n    majorSeventh: 1.875,\n    octave: 2,\n    majorTenth: 2.5,\n    majorEleventh: 2.667,\n    majorTwelfth: 3,\n    doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n    return ratioNames[ratioName];\n}\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */ function modularScale(steps, base, ratio) {\n    if (base === void 0) {\n        base = \"1em\";\n    }\n    if (ratio === void 0) {\n        ratio = 1.333;\n    }\n    if (typeof steps !== \"number\") {\n        throw new PolishedError(42);\n    }\n    if (typeof ratio === \"string\" && !ratioNames[ratio]) {\n        throw new PolishedError(43);\n    }\n    var _ref = typeof base === \"string\" ? getValueAndUnit(base) : [\n        base,\n        \"\"\n    ], realBase = _ref[0], unit = _ref[1];\n    var realRatio = typeof ratio === \"string\" ? getRatio(ratio) : ratio;\n    if (typeof realBase === \"string\") {\n        throw new PolishedError(44, base);\n    }\n    return \"\" + realBase * Math.pow(realRatio, steps) + (unit || \"\");\n}\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */ var rem = /*#__PURE__*/ pixelsto(\"rem\");\nvar rem$1 = rem;\nvar defaultFontSize = 16;\nfunction convertBase(base) {\n    var deconstructedValue = getValueAndUnit(base);\n    if (deconstructedValue[1] === \"px\") {\n        return parseFloat(base);\n    }\n    if (deconstructedValue[1] === \"%\") {\n        return parseFloat(base) / 100 * defaultFontSize;\n    }\n    throw new PolishedError(78, deconstructedValue[1]);\n}\nfunction getBaseFromDoc() {\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        var rootFontSize = getComputedStyle(document.documentElement).fontSize;\n        return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;\n    }\n    /* eslint-enable */ /* istanbul ignore next */ return defaultFontSize;\n}\n/**\n * Convert rem values to px. By default, the base value is pulled from the font-size property on the root element (if it is set in % or px). It defaults to 16px if not found on the root. You can also override the base value by providing your own base in % or px.\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': remToPx('1.6rem')\n *   'height': remToPx('1.6rem', '10px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${remToPx('1.6rem')}\n *   height: ${remToPx('1.6rem', '10px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '25.6px',\n *   'height': '16px',\n * }\n */ function remToPx(value, base) {\n    var deconstructedValue = getValueAndUnit(value);\n    if (deconstructedValue[1] !== \"rem\" && deconstructedValue[1] !== \"\") {\n        throw new PolishedError(77, deconstructedValue[1]);\n    }\n    var newBase = base ? convertBase(base) : getBaseFromDoc();\n    return deconstructedValue[0] * newBase + \"px\";\n}\nvar functionsMap$3 = {\n    back: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    circ: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    cubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    expo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    quad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    quart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    quint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    sine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeIn('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeIn('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function easeIn(functionName) {\n    return functionsMap$3[functionName.toLowerCase().trim()];\n}\nvar functionsMap$2 = {\n    back: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    circ: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    cubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    expo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    quad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    quart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    quint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    sine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeInOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeInOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n * }\n */ function easeInOut(functionName) {\n    return functionsMap$2[functionName.toLowerCase().trim()];\n}\nvar functionsMap$1 = {\n    back: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    cubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    circ: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    expo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    quad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    quart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    quint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    sine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n * }\n */ function easeOut(functionName) {\n    return functionsMap$1[functionName.toLowerCase().trim()];\n}\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */ function between(fromSize, toSize, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];\n    var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];\n    var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];\n    var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];\n    if (typeof unitlessMinScreen !== \"number\" || typeof unitlessMaxScreen !== \"number\" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n        throw new PolishedError(47);\n    }\n    if (typeof unitlessFromSize !== \"number\" || typeof unitlessToSize !== \"number\" || fromSizeUnit !== toSizeUnit) {\n        throw new PolishedError(48);\n    }\n    if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {\n        throw new PolishedError(76);\n    }\n    var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n    var base = unitlessToSize - slope * unitlessMaxScreen;\n    return \"calc(\" + base.toFixed(2) + (fromSizeUnit || \"\") + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */ function clearFix(parent) {\n    var _ref;\n    if (parent === void 0) {\n        parent = \"&\";\n    }\n    var pseudoSelector = parent + \"::after\";\n    return _ref = {}, _ref[pseudoSelector] = {\n        clear: \"both\",\n        content: '\"\"',\n        display: \"table\"\n    }, _ref;\n}\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */ function cover(offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    return {\n        position: \"absolute\",\n        top: offset,\n        right: offset,\n        bottom: offset,\n        left: offset\n    };\n}\n/**\n * CSS to represent truncated text with an ellipsis. You can optionally pass a max-width and number of lines before truncating.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */ function ellipsis(width, lines) {\n    if (lines === void 0) {\n        lines = 1;\n    }\n    var styles = {\n        display: \"inline-block\",\n        maxWidth: width || \"100%\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n    };\n    return lines > 1 ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, styles, {\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: lines,\n        display: \"-webkit-box\",\n        whiteSpace: \"normal\"\n    }) : styles;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */ function fluidRange(cssProp, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    if (!Array.isArray(cssProp) && typeof cssProp !== \"object\" || cssProp === null) {\n        throw new PolishedError(49);\n    }\n    if (Array.isArray(cssProp)) {\n        var mediaQueries = {};\n        var fallbacks = {};\n        for(var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done;){\n            var _extends2, _extends3;\n            var obj = _step.value;\n            if (!obj.prop || !obj.fromSize || !obj.toSize) {\n                throw new PolishedError(50);\n            }\n            fallbacks[obj.prop] = obj.fromSize;\n            mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n            mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, fallbacks, mediaQueries);\n    } else {\n        var _ref, _ref2, _ref3;\n        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n            throw new PolishedError(51);\n        }\n        return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3[\"@media (min-width: \" + minScreen + \")\"] = (_ref = {}, _ref[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref), _ref3[\"@media (min-width: \" + maxScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = cssProp.toSize, _ref2), _ref3;\n    }\n}\nvar dataURIRegex = /^\\s*data:([a-z]+\\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\\-._~:@/?%\\s]*\\s*$/i;\nvar formatHintMap = {\n    woff: \"woff\",\n    woff2: \"woff2\",\n    ttf: \"truetype\",\n    otf: \"opentype\",\n    eot: \"embedded-opentype\",\n    svg: \"svg\",\n    svgz: \"svg\"\n};\nfunction generateFormatHint(format, formatHint) {\n    if (!formatHint) return \"\";\n    return ' format(\"' + formatHintMap[format] + '\")';\n}\nfunction isDataURI(fontFilePath) {\n    return !!fontFilePath.replace(/\\s+/g, \" \").match(dataURIRegex);\n}\nfunction generateFileReferences(fontFilePath, fileFormats, formatHint) {\n    if (isDataURI(fontFilePath)) {\n        return 'url(\"' + fontFilePath + '\")' + generateFormatHint(fileFormats[0], formatHint);\n    }\n    var fileFontReferences = fileFormats.map(function(format) {\n        return 'url(\"' + fontFilePath + \".\" + format + '\")' + generateFormatHint(format, formatHint);\n    });\n    return fileFontReferences.join(\", \");\n}\nfunction generateLocalReferences(localFonts) {\n    var localFontReferences = localFonts.map(function(font) {\n        return 'local(\"' + font + '\")';\n    });\n    return localFontReferences.join(\", \");\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats, formatHint) {\n    var fontReferences = [];\n    if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n    if (fontFilePath) {\n        fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));\n    }\n    return fontReferences.join(\", \");\n}\n/**\n * CSS for a @font-face declaration. Defaults to check for local copies of the font on the user's machine. You can disable this by passing `null` to localFonts.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */ function fontFace(_ref) {\n    var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? [\n        \"eot\",\n        \"woff2\",\n        \"woff\",\n        \"ttf\",\n        \"svg\"\n    ] : _ref$fileFormats, _ref$formatHint = _ref.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref.localFonts, localFonts = _ref$localFonts === void 0 ? [\n        fontFamily\n    ] : _ref$localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;\n    // Error Handling\n    if (!fontFamily) throw new PolishedError(55);\n    if (!fontFilePath && !localFonts) {\n        throw new PolishedError(52);\n    }\n    if (localFonts && !Array.isArray(localFonts)) {\n        throw new PolishedError(53);\n    }\n    if (!Array.isArray(fileFormats)) {\n        throw new PolishedError(54);\n    }\n    var fontFaceDeclaration = {\n        \"@font-face\": {\n            fontFamily: fontFamily,\n            src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),\n            unicodeRange: unicodeRange,\n            fontStretch: fontStretch,\n            fontStyle: fontStyle,\n            fontVariant: fontVariant,\n            fontWeight: fontWeight,\n            fontDisplay: fontDisplay,\n            fontVariationSettings: fontVariationSettings,\n            fontFeatureSettings: fontFeatureSettings\n        }\n    }; // Removes undefined fields for cleaner css object.\n    return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */ function hideText() {\n    return {\n        textIndent: \"101%\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\"\n    };\n}\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */ function hideVisually() {\n    return {\n        border: \"0\",\n        clip: \"rect(0 0 0 0)\",\n        height: \"1px\",\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        padding: \"0\",\n        position: \"absolute\",\n        whiteSpace: \"nowrap\",\n        width: \"1px\"\n    };\n}\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */ function hiDPI(ratio) {\n    if (ratio === void 0) {\n        ratio = 1.3;\n    }\n    return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\nfunction constructGradientValue(literals) {\n    var template = \"\";\n    for(var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        substitutions[_key - 1] = arguments[_key];\n    }\n    for(var i = 0; i < literals.length; i += 1){\n        template += literals[i];\n        if (i === substitutions.length - 1 && substitutions[i]) {\n            var definedValues = substitutions.filter(function(substitute) {\n                return !!substitute;\n            }); // Adds leading coma if properties preceed color-stops\n            if (definedValues.length > 1) {\n                template = template.slice(0, -1);\n                template += \", \" + substitutions[i]; // No trailing space if color-stops is the only param provided\n            } else if (definedValues.length === 1) {\n                template += \"\" + substitutions[i];\n            }\n        } else if (substitutions[i]) {\n            template += substitutions[i] + \" \";\n        }\n    }\n    return template.trim();\n}\nvar _templateObject$1;\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function linearGradient(_ref) {\n    var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? \"\" : _ref$toDirection;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(56);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].replace(/,\\s+/g, \",\").split(\" \")[0].replace(/,(?=\\S)/g, \", \"),\n        backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"linear-gradient(\",\n            \"\",\n            \")\"\n        ])), toDirection, colorStops.join(\", \").replace(/,(?=\\S)/g, \", \"))\n    };\n}\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */ function normalize() {\n    var _ref;\n    return [\n        (_ref = {\n            html: {\n                lineHeight: \"1.15\",\n                textSizeAdjust: \"100%\"\n            },\n            body: {\n                margin: \"0\"\n            },\n            main: {\n                display: \"block\"\n            },\n            h1: {\n                fontSize: \"2em\",\n                margin: \"0.67em 0\"\n            },\n            hr: {\n                boxSizing: \"content-box\",\n                height: \"0\",\n                overflow: \"visible\"\n            },\n            pre: {\n                fontFamily: \"monospace, monospace\",\n                fontSize: \"1em\"\n            },\n            a: {\n                backgroundColor: \"transparent\"\n            },\n            \"abbr[title]\": {\n                borderBottom: \"none\",\n                textDecoration: \"underline\"\n            }\n        }, _ref[\"b,\\n    strong\"] = {\n            fontWeight: \"bolder\"\n        }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n            fontFamily: \"monospace, monospace\",\n            fontSize: \"1em\"\n        }, _ref.small = {\n            fontSize: \"80%\"\n        }, _ref[\"sub,\\n    sup\"] = {\n            fontSize: \"75%\",\n            lineHeight: \"0\",\n            position: \"relative\",\n            verticalAlign: \"baseline\"\n        }, _ref.sub = {\n            bottom: \"-0.25em\"\n        }, _ref.sup = {\n            top: \"-0.5em\"\n        }, _ref.img = {\n            borderStyle: \"none\"\n        }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n            fontFamily: \"inherit\",\n            fontSize: \"100%\",\n            lineHeight: \"1.15\",\n            margin: \"0\"\n        }, _ref[\"button,\\n    input\"] = {\n            overflow: \"visible\"\n        }, _ref[\"button,\\n    select\"] = {\n            textTransform: \"none\"\n        }, _ref['button,\\n    html [type=\"button\"],\\n    [type=\"reset\"],\\n    [type=\"submit\"]'] = {\n            WebkitAppearance: \"button\"\n        }, _ref['button::-moz-focus-inner,\\n    [type=\"button\"]::-moz-focus-inner,\\n    [type=\"reset\"]::-moz-focus-inner,\\n    [type=\"submit\"]::-moz-focus-inner'] = {\n            borderStyle: \"none\",\n            padding: \"0\"\n        }, _ref['button:-moz-focusring,\\n    [type=\"button\"]:-moz-focusring,\\n    [type=\"reset\"]:-moz-focusring,\\n    [type=\"submit\"]:-moz-focusring'] = {\n            outline: \"1px dotted ButtonText\"\n        }, _ref.fieldset = {\n            padding: \"0.35em 0.625em 0.75em\"\n        }, _ref.legend = {\n            boxSizing: \"border-box\",\n            color: \"inherit\",\n            display: \"table\",\n            maxWidth: \"100%\",\n            padding: \"0\",\n            whiteSpace: \"normal\"\n        }, _ref.progress = {\n            verticalAlign: \"baseline\"\n        }, _ref.textarea = {\n            overflow: \"auto\"\n        }, _ref['[type=\"checkbox\"],\\n    [type=\"radio\"]'] = {\n            boxSizing: \"border-box\",\n            padding: \"0\"\n        }, _ref['[type=\"number\"]::-webkit-inner-spin-button,\\n    [type=\"number\"]::-webkit-outer-spin-button'] = {\n            height: \"auto\"\n        }, _ref['[type=\"search\"]'] = {\n            WebkitAppearance: \"textfield\",\n            outlineOffset: \"-2px\"\n        }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n            WebkitAppearance: \"none\"\n        }, _ref[\"::-webkit-file-upload-button\"] = {\n            WebkitAppearance: \"button\",\n            font: \"inherit\"\n        }, _ref.details = {\n            display: \"block\"\n        }, _ref.summary = {\n            display: \"list-item\"\n        }, _ref.template = {\n            display: \"none\"\n        }, _ref[\"[hidden]\"] = {\n            display: \"none\"\n        }, _ref),\n        {\n            \"abbr[title]\": {\n                textDecoration: \"underline dotted\"\n            }\n        }\n    ];\n}\nvar _templateObject;\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function radialGradient(_ref) {\n    var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? \"\" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position = _ref$position === void 0 ? \"\" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? \"\" : _ref$shape;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(57);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject || (_templateObject = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"radial-gradient(\",\n            \"\",\n            \"\",\n            \"\",\n            \")\"\n        ])), position, shape, extent, colorStops.join(\", \"))\n    };\n}\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */ function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n    var _ref;\n    if (extension === void 0) {\n        extension = \"png\";\n    }\n    if (retinaSuffix === void 0) {\n        retinaSuffix = \"_2x\";\n    }\n    if (!filename) {\n        throw new PolishedError(58);\n    } // Replace the dot at the beginning of the passed extension if one exists\n    var ext = extension.replace(/^\\./, \"\");\n    var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n    return _ref = {\n        backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n    }, _ref[hiDPI()] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        backgroundImage: \"url(\" + rFilename + \")\"\n    }, backgroundSize ? {\n        backgroundSize: backgroundSize\n    } : {}), _ref;\n}\n/* eslint-disable key-spacing */ var functionsMap = {\n    easeInBack: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    easeInCirc: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    easeInCubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    easeInExpo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    easeInQuad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    easeInQuart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    easeInQuint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    easeInSine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\",\n    easeOutBack: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    easeOutCubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    easeOutCirc: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    easeOutExpo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    easeOutQuad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    easeOutQuart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    easeOutQuint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    easeOutSine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\",\n    easeInOutBack: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    easeInOutCirc: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    easeInOutCubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    easeInOutExpo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    easeInOutQuad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    easeInOutQuart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    easeInOutQuint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    easeInOutSine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/* eslint-enable key-spacing */ function getTimingFunction(functionName) {\n    return functionsMap[functionName];\n}\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @deprecated - This will be deprecated in v5 in favor of `easeIn`, `easeOut`, `easeInOut`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function timingFunctions(timingFunction) {\n    return getTimingFunction(timingFunction);\n}\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n    var fullWidth = \"\" + width[0] + (width[1] || \"\");\n    var halfWidth = \"\" + width[0] / 2 + (width[1] || \"\");\n    var fullHeight = \"\" + height[0] + (height[1] || \"\");\n    var halfHeight = \"\" + height[0] / 2 + (height[1] || \"\");\n    switch(pointingDirection){\n        case \"top\":\n            return \"0 \" + halfWidth + \" \" + fullHeight + \" \" + halfWidth;\n        case \"topLeft\":\n            return fullWidth + \" \" + fullHeight + \" 0 0\";\n        case \"left\":\n            return halfHeight + \" \" + fullWidth + \" \" + halfHeight + \" 0\";\n        case \"bottomLeft\":\n            return fullWidth + \" 0 0 \" + fullHeight;\n        case \"bottom\":\n            return fullHeight + \" \" + halfWidth + \" 0 \" + halfWidth;\n        case \"bottomRight\":\n            return \"0 0 \" + fullWidth + \" \" + fullHeight;\n        case \"right\":\n            return halfHeight + \" 0 \" + halfHeight + \" \" + fullWidth;\n        case \"topRight\":\n        default:\n            return \"0 \" + fullWidth + \" \" + fullHeight + \" 0\";\n    }\n};\nvar getBorderColor = function getBorderColor(pointingDirection, foregroundColor) {\n    switch(pointingDirection){\n        case \"top\":\n        case \"bottomRight\":\n            return {\n                borderBottomColor: foregroundColor\n            };\n        case \"right\":\n        case \"bottomLeft\":\n            return {\n                borderLeftColor: foregroundColor\n            };\n        case \"bottom\":\n        case \"topLeft\":\n            return {\n                borderTopColor: foregroundColor\n            };\n        case \"left\":\n        case \"topRight\":\n            return {\n                borderRightColor: foregroundColor\n            };\n        default:\n            throw new PolishedError(59);\n    }\n};\n/**\n * CSS to represent triangle with any pointing direction with an optional background color.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent transparent transparent red',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */ function triangle(_ref) {\n    var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? \"transparent\" : _ref$backgroundColor;\n    var widthAndUnit = getValueAndUnit(width);\n    var heightAndUnit = getValueAndUnit(height);\n    if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n        throw new PolishedError(60);\n    }\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        width: \"0\",\n        height: \"0\",\n        borderColor: backgroundColor\n    }, getBorderColor(pointingDirection, foregroundColor), {\n        borderStyle: \"solid\",\n        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)\n    });\n}\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */ function wordWrap(wrap) {\n    if (wrap === void 0) {\n        wrap = \"break-word\";\n    }\n    var wordBreak = wrap === \"break-word\" ? \"break-all\" : wrap;\n    return {\n        overflowWrap: wrap,\n        wordWrap: wrap,\n        wordBreak: wordBreak\n    };\n}\nfunction colorToInt(color) {\n    return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n    return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n    if (convert === void 0) {\n        convert = convertToInt;\n    }\n    if (saturation === 0) {\n        // achromatic\n        return convert(lightness, lightness, lightness);\n    } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV\n    var huePrime = (hue % 360 + 360) % 360 / 60;\n    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n    var red = 0;\n    var green = 0;\n    var blue = 0;\n    if (huePrime >= 0 && huePrime < 1) {\n        red = chroma;\n        green = secondComponent;\n    } else if (huePrime >= 1 && huePrime < 2) {\n        red = secondComponent;\n        green = chroma;\n    } else if (huePrime >= 2 && huePrime < 3) {\n        green = chroma;\n        blue = secondComponent;\n    } else if (huePrime >= 3 && huePrime < 4) {\n        green = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 4 && huePrime < 5) {\n        red = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 5 && huePrime < 6) {\n        red = chroma;\n        blue = secondComponent;\n    }\n    var lightnessModification = lightness - chroma / 2;\n    var finalRed = red + lightnessModification;\n    var finalGreen = green + lightnessModification;\n    var finalBlue = blue + lightnessModification;\n    return convert(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"639\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n * @private\n */ function nameToHex(color) {\n    if (typeof color !== \"string\") return color;\n    var normalizedColorName = color.toLowerCase();\n    return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*\\)$/i;\nvar rgbaRegex = /^rgb(?:a)?\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*\\)$/i;\nvar hslaRegex = /^hsl(?:a)?\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */ function parseToRgb(color) {\n    if (typeof color !== \"string\") {\n        throw new PolishedError(3);\n    }\n    var normalizedColor = nameToHex(color);\n    if (normalizedColor.match(hexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n        };\n    }\n    if (normalizedColor.match(hexRgbaRegex)) {\n        var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n            alpha: alpha\n        };\n    }\n    if (normalizedColor.match(reducedHexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n        };\n    }\n    if (normalizedColor.match(reducedRgbaHexRegex)) {\n        var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n            alpha: _alpha\n        };\n    }\n    var rgbMatched = rgbRegex.exec(normalizedColor);\n    if (rgbMatched) {\n        return {\n            red: parseInt(\"\" + rgbMatched[1], 10),\n            green: parseInt(\"\" + rgbMatched[2], 10),\n            blue: parseInt(\"\" + rgbMatched[3], 10)\n        };\n    }\n    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));\n    if (rgbaMatched) {\n        return {\n            red: parseInt(\"\" + rgbaMatched[1], 10),\n            green: parseInt(\"\" + rgbaMatched[2], 10),\n            blue: parseInt(\"\" + rgbaMatched[3], 10),\n            alpha: parseFloat(\"\" + rgbaMatched[4]) > 1 ? parseFloat(\"\" + rgbaMatched[4]) / 100 : parseFloat(\"\" + rgbaMatched[4])\n        };\n    }\n    var hslMatched = hslRegex.exec(normalizedColor);\n    if (hslMatched) {\n        var hue = parseInt(\"\" + hslMatched[1], 10);\n        var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n        var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n        var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n        var hslRgbMatched = rgbRegex.exec(rgbColorString);\n        if (!hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + hslRgbMatched[1], 10),\n            green: parseInt(\"\" + hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + hslRgbMatched[3], 10)\n        };\n    }\n    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));\n    if (hslaMatched) {\n        var _hue = parseInt(\"\" + hslaMatched[1], 10);\n        var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n        var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n        var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n        if (!_hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, _rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + _hslRgbMatched[1], 10),\n            green: parseInt(\"\" + _hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n            alpha: parseFloat(\"\" + hslaMatched[4]) > 1 ? parseFloat(\"\" + hslaMatched[4]) / 100 : parseFloat(\"\" + hslaMatched[4])\n        };\n    }\n    throw new PolishedError(5);\n}\nfunction rgbToHsl(color) {\n    // make sure rgb are contained in a set of [0, 255]\n    var red = color.red / 255;\n    var green = color.green / 255;\n    var blue = color.blue / 255;\n    var max = Math.max(red, green, blue);\n    var min = Math.min(red, green, blue);\n    var lightness = (max + min) / 2;\n    if (max === min) {\n        // achromatic\n        if (color.alpha !== undefined) {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness,\n                alpha: color.alpha\n            };\n        } else {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness\n            };\n        }\n    }\n    var hue;\n    var delta = max - min;\n    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    switch(max){\n        case red:\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            break;\n        case green:\n            hue = (blue - red) / delta + 2;\n            break;\n        default:\n            // blue case\n            hue = (red - green) / delta + 4;\n            break;\n    }\n    hue *= 60;\n    if (color.alpha !== undefined) {\n        return {\n            hue: hue,\n            saturation: saturation,\n            lightness: lightness,\n            alpha: color.alpha\n        };\n    }\n    return {\n        hue: hue,\n        saturation: saturation,\n        lightness: lightness\n    };\n}\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */ function parseToHsl(color) {\n    // Note: At a later stage we can optimize this function as right now a hsl\n    // color would be parsed converted to rgb values and converted back to hsl.\n    return rgbToHsl(parseToRgb(color));\n}\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */ var reduceHexValue = function reduceHexValue(value) {\n    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n        return \"#\" + value[1] + value[3] + value[5];\n    }\n    return value;\n};\nvar reduceHexValue$1 = reduceHexValue;\nfunction numberToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nfunction colorToHex(color) {\n    return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n    return reduceHexValue$1(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n    return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */ function hsl(value, saturation, lightness) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\") {\n        return hslToHex(value, saturation, lightness);\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined) {\n        return hslToHex(value.hue, value.saturation, value.lightness);\n    }\n    throw new PolishedError(1);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */ function hsla(value, saturation, lightness, alpha) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\" && typeof alpha === \"number\") {\n        return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined && alpha === undefined) {\n        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n    }\n    throw new PolishedError(2);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */ function rgb(value, green, blue) {\n    if (typeof value === \"number\" && typeof green === \"number\" && typeof blue === \"number\") {\n        return reduceHexValue$1(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n    } else if (typeof value === \"object\" && green === undefined && blue === undefined) {\n        return reduceHexValue$1(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n    }\n    throw new PolishedError(6);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */ function rgba(firstValue, secondValue, thirdValue, fourthValue) {\n    if (typeof firstValue === \"string\" && typeof secondValue === \"number\") {\n        var rgbValue = parseToRgb(firstValue);\n        return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n    } else if (typeof firstValue === \"number\" && typeof secondValue === \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \"number\") {\n        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n    } else if (typeof firstValue === \"object\" && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n    }\n    throw new PolishedError(7);\n}\nvar isRgb = function isRgb(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isRgba = function isRgba(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && typeof color.alpha === \"number\";\n};\nvar isHsl = function isHsl(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isHsla = function isHsla(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && typeof color.alpha === \"number\";\n};\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function toColorString(color) {\n    if (typeof color !== \"object\") throw new PolishedError(8);\n    if (isRgba(color)) return rgba(color);\n    if (isRgb(color)) return rgb(color);\n    if (isHsla(color)) return hsla(color);\n    if (isHsl(color)) return hsl(color);\n    throw new PolishedError(8);\n}\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n    return function fn() {\n        // eslint-disable-next-line prefer-rest-params\n        var combined = acc.concat(Array.prototype.slice.call(arguments));\n        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n    };\n} // eslint-disable-next-line no-redeclare\nfunction curry(f) {\n    // eslint-disable-line no-redeclare\n    return curried(f, f.length, []);\n}\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated around\n * the color wheel, always producing a positive hue value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */ function adjustHue(degree, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: hslColor.hue + parseFloat(degree)\n    }));\n} // prettier-ignore\nvar curriedAdjustHue = /*#__PURE__*/ curry(adjustHue);\nvar curriedAdjustHue$1 = curriedAdjustHue;\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function complement(color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + 180) % 360\n    }));\n}\nfunction guard(lowerBoundary, upperBoundary, value) {\n    return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */ function darken(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDarken = /*#__PURE__*/ curry(darken);\nvar curriedDarken$1 = curriedDarken;\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */ function desaturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedDesaturate = /*#__PURE__*/ curry(desaturate);\nvar curriedDesaturate$1 = curriedDesaturate;\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */ function getLuminance(color) {\n    if (color === \"transparent\") return 0;\n    var rgbColor = parseToRgb(color);\n    var _Object$keys$map = Object.keys(rgbColor).map(function(key) {\n        var channel = rgbColor[key] / 255;\n        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];\n    return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n/**\n * Returns the contrast ratio between two colors based on\n * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).\n *\n * @example\n * const contrastRatio = getContrast('#444', '#fff');\n */ function getContrast(color1, color2) {\n    var luminance1 = getLuminance(color1);\n    var luminance2 = getLuminance(color2);\n    return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));\n}\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function grayscale(color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: 0\n    }));\n}\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function hslToColorString(color) {\n    if (typeof color === \"object\" && typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return hsla({\n                hue: color.hue,\n                saturation: color.saturation,\n                lightness: color.lightness,\n                alpha: color.alpha\n            });\n        }\n        return hsl({\n            hue: color.hue,\n            saturation: color.saturation,\n            lightness: color.lightness\n        });\n    }\n    throw new PolishedError(45);\n}\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */ function invert(color) {\n    if (color === \"transparent\") return color; // parse color string to rgb\n    var value = parseToRgb(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, value, {\n        red: 255 - value.red,\n        green: 255 - value.green,\n        blue: 255 - value.blue\n    }));\n}\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */ function lighten(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedLighten = /*#__PURE__*/ curry(lighten);\nvar curriedLighten$1 = curriedLighten;\n/**\n * Determines which contrast guidelines have been met for two colors.\n * Based on the [contrast calculations recommended by W3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html).\n *\n * @example\n * const scores = meetsContrastGuidelines('#444', '#fff');\n */ function meetsContrastGuidelines(color1, color2) {\n    var contrastRatio = getContrast(color1, color2);\n    return {\n        AA: contrastRatio >= 4.5,\n        AALarge: contrastRatio >= 3,\n        AAA: contrastRatio >= 7,\n        AAALarge: contrastRatio >= 4.5\n    };\n}\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */ function mix(weight, color, otherColor) {\n    if (color === \"transparent\") return otherColor;\n    if (otherColor === \"transparent\") return color;\n    if (weight === 0) return otherColor;\n    var parsedColor1 = parseToRgb(color);\n    var color1 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor1, {\n        alpha: typeof parsedColor1.alpha === \"number\" ? parsedColor1.alpha : 1\n    });\n    var parsedColor2 = parseToRgb(otherColor);\n    var color2 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor2, {\n        alpha: typeof parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1\n    }); // The formula is copied from the original Sass implementation:\n    // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n    var alphaDelta = color1.alpha - color2.alpha;\n    var x = parseFloat(weight) * 2 - 1;\n    var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n    var z = 1 + x * alphaDelta;\n    var weight1 = (y / z + 1) / 2.0;\n    var weight2 = 1 - weight1;\n    var mixedColor = {\n        red: Math.floor(color1.red * weight1 + color2.red * weight2),\n        green: Math.floor(color1.green * weight1 + color2.green * weight2),\n        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n        alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))\n    };\n    return rgba(mixedColor);\n} // prettier-ignore\nvar curriedMix = /*#__PURE__*/ curry(mix);\nvar mix$1 = curriedMix;\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */ function opacify(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedOpacify = /*#__PURE__*/ curry(opacify);\nvar curriedOpacify$1 = curriedOpacify;\nvar defaultReturnIfLightColor = \"#000\";\nvar defaultReturnIfDarkColor = \"#fff\";\n/**\n * Returns black or white (or optional passed colors) for best\n * contrast depending on the luminosity of the given color.\n * When passing custom return colors, strict mode ensures that the\n * return color always meets or exceeds WCAG level AA or greater. If this test\n * fails, the default return color (black or white) is returned in place of the\n * custom return color. You can optionally turn off strict mode.\n *\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n *   color: readableColor('red', '#333', '#ddd', true)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n *   color: ${readableColor('red', '#333', '#ddd', true)};\n * `\n *\n * // CSS in JS Output\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n *   color: \"#000\";\n * }\n */ function readableColor(color, returnIfLightColor, returnIfDarkColor, strict) {\n    if (returnIfLightColor === void 0) {\n        returnIfLightColor = defaultReturnIfLightColor;\n    }\n    if (returnIfDarkColor === void 0) {\n        returnIfDarkColor = defaultReturnIfDarkColor;\n    }\n    if (strict === void 0) {\n        strict = true;\n    }\n    var isColorLight = getLuminance(color) > 0.179;\n    var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;\n    if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {\n        return preferredReturnColor;\n    }\n    return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;\n}\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */ function rgbToColorString(color) {\n    if (typeof color === \"object\" && typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\") {\n        if (typeof color.alpha === \"number\") {\n            return rgba({\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha\n            });\n        }\n        return rgb({\n            red: color.red,\n            green: color.green,\n            blue: color.blue\n        });\n    }\n    throw new PolishedError(46);\n}\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */ function saturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n    }));\n} // prettier-ignore\nvar curriedSaturate = /*#__PURE__*/ curry(saturate);\nvar curriedSaturate$1 = curriedSaturate;\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */ function setHue(hue, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        hue: parseFloat(hue)\n    }));\n} // prettier-ignore\nvar curriedSetHue = /*#__PURE__*/ curry(setHue);\nvar curriedSetHue$1 = curriedSetHue;\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */ function setLightness(lightness, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        lightness: parseFloat(lightness)\n    }));\n} // prettier-ignore\nvar curriedSetLightness = /*#__PURE__*/ curry(setLightness);\nvar curriedSetLightness$1 = curriedSetLightness;\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */ function setSaturation(saturation, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: parseFloat(saturation)\n    }));\n} // prettier-ignore\nvar curriedSetSaturation = /*#__PURE__*/ curry(setSaturation);\nvar curriedSetSaturation$1 = curriedSetSaturation;\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */ function shade(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(0, 0, 0)\", color);\n} // prettier-ignore\nvar curriedShade = /*#__PURE__*/ curry(shade);\nvar curriedShade$1 = curriedShade;\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */ function tint(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(255, 255, 255)\", color);\n} // prettier-ignore\nvar curriedTint = /*#__PURE__*/ curry(tint);\nvar curriedTint$1 = curriedTint;\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff'),\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */ function transparentize(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)\n    });\n    return rgba(colorWithAlpha);\n} // prettier-ignore\nvar curriedTransparentize = /*#__PURE__*/ curry(transparentize);\nvar curriedTransparentize$1 = curriedTransparentize;\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */ function animation() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Allow single or multiple animations passed\n    var multiMode = Array.isArray(args[0]);\n    if (!multiMode && args.length > 8) {\n        throw new PolishedError(64);\n    }\n    var code = args.map(function(arg) {\n        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n            throw new PolishedError(65);\n        }\n        if (Array.isArray(arg) && arg.length > 8) {\n            throw new PolishedError(66);\n        }\n        return Array.isArray(arg) ? arg.join(\" \") : arg;\n    }).join(\", \");\n    return {\n        animation: code\n    };\n}\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */ function backgroundImages() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        backgroundImage: properties.join(\", \")\n    };\n}\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */ function backgrounds() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        background: properties.join(\", \")\n    };\n}\nvar sideMap = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */ function border(sideKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (typeof sideKeyword === \"string\" && sideMap.indexOf(sideKeyword) >= 0) {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n    } else {\n        values.unshift(sideKeyword);\n        return {\n            borderWidth: values[0],\n            borderStyle: values[1],\n            borderColor: values[2]\n        };\n    }\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */ function borderColor() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderColor\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */ function borderRadius(side, radius) {\n    var uppercaseSide = capitalizeString(side);\n    if (!radius && radius !== 0) {\n        throw new PolishedError(62);\n    }\n    if (uppercaseSide === \"Top\" || uppercaseSide === \"Bottom\") {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n    }\n    if (uppercaseSide === \"Left\" || uppercaseSide === \"Right\") {\n        var _ref2;\n        return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n    }\n    throw new PolishedError(63);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */ function borderStyle() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderStyle\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */ function borderWidth() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderWidth\"\n    ].concat(values));\n}\nfunction generateSelectors(template, state) {\n    var stateSuffix = state ? \":\" + state : \"\";\n    return template(stateSuffix);\n}\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */ function statefulSelectors(states, template, stateMap) {\n    if (!template) throw new PolishedError(67);\n    if (states.length === 0) return generateSelectors(template, null);\n    var selectors = [];\n    for(var i = 0; i < states.length; i += 1){\n        if (stateMap && stateMap.indexOf(states[i]) < 0) {\n            throw new PolishedError(68);\n        }\n        selectors.push(generateSelectors(template, states[i]));\n    }\n    selectors = selectors.join(\",\");\n    return selectors;\n}\nvar stateMap$1 = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template$1(state) {\n    return \"button\" + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */ function buttons() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template$1, stateMap$1);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */ function margin() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"margin\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function padding() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"padding\"\n    ].concat(values));\n}\nvar positionMap = [\n    \"absolute\",\n    \"fixed\",\n    \"relative\",\n    \"static\",\n    \"sticky\"\n];\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */ function position(firstValue) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (positionMap.indexOf(firstValue) >= 0 && firstValue) {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, directionalProperty.apply(void 0, [\n            \"\"\n        ].concat(values)), {\n            position: firstValue\n        });\n    } else {\n        return directionalProperty.apply(void 0, [\n            \"\",\n            firstValue\n        ].concat(values));\n    }\n}\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */ function size(height, width) {\n    if (width === void 0) {\n        width = height;\n    }\n    return {\n        height: height,\n        width: width\n    };\n}\nvar stateMap = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template(state) {\n    return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */ function textInputs() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template, stateMap);\n}\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same transition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */ function transitions() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    if (Array.isArray(properties[0]) && properties.length === 2) {\n        var value = properties[1];\n        if (typeof value !== \"string\") {\n            throw new PolishedError(61);\n        }\n        var transitionsString = properties[0].map(function(property) {\n            return property + \" \" + value;\n        }).join(\", \");\n        return {\n            transition: transitionsString\n        };\n    } else {\n        return {\n            transition: properties.join(\", \")\n        };\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzRCO0FBQ2hCO0FBQ0k7QUFDc0I7QUFFaEcsU0FBU0s7SUFDUCxJQUFJQztJQUVKLE9BQU9BLE9BQU9DLFVBQVVDLE1BQU0sR0FBRyxHQUFHRixPQUFPLEtBQUtDLFVBQVVDLE1BQU0sSUFBSUYsT0FBT0csWUFBWUYsU0FBUyxDQUFDRCxLQUFLO0FBQ3hHO0FBRUEsU0FBU0ksU0FBU0MsQ0FBQztJQUNqQixPQUFPLENBQUNBO0FBQ1Y7QUFFQSxTQUFTQyxTQUFTRCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNDLFlBQVlILENBQUMsRUFBRUUsQ0FBQztJQUN2QixPQUFPRixJQUFJRTtBQUNiO0FBRUEsU0FBU0UsZUFBZUosQ0FBQyxFQUFFRSxDQUFDO0lBQzFCLE9BQU9GLElBQUlFO0FBQ2I7QUFFQSxTQUFTRyxTQUFTTCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUVBLFNBQVNJO0lBQ1AsT0FBT0MsS0FBS0QsR0FBRyxDQUFDRSxLQUFLLENBQUNELE1BQU1YO0FBQzlCO0FBRUEsU0FBU2E7SUFDUCxPQUFPRixLQUFLRSxHQUFHLENBQUNELEtBQUssQ0FBQ0QsTUFBTVg7QUFDOUI7QUFFQSxTQUFTYztJQUNQLE9BQU9DLE1BQU1DLEVBQUUsQ0FBQ0osS0FBSyxDQUFDRyxPQUFPZjtBQUMvQjtBQUVBLElBQUlpQixpQkFBaUI7SUFDbkJDLFNBQVM7UUFDUCxLQUFLO1lBQ0hDLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLEdBQUdiO2dCQUNIYyxVQUFVO2dCQUNWQyxZQUFZO2dCQUNaQyxhQUFhO2dCQUNiQyxVQUFVO1lB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Ozs7Ozs7Ozs7OztDQXFDQyxHQUdELFNBQVNXO0lBQ1AsSUFBSyxJQUFJbHVCLE9BQU9qQyxVQUFVQyxNQUFNLEVBQUUwdkIsU0FBUyxJQUFJNXVCLE1BQU1rQixPQUFPRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7UUFDekZ3dEIsTUFBTSxDQUFDeHRCLEtBQUssR0FBR25DLFNBQVMsQ0FBQ21DLEtBQUs7SUFDaEM7SUFFQSxPQUFPdXRCLGtCQUFrQkMsUUFBUTlhLFVBQVUrYTtBQUM3QztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FFRCxTQUFTUTtJQUNQLElBQUssSUFBSW51QixPQUFPakMsVUFBVUMsTUFBTSxFQUFFNHVCLGFBQWEsSUFBSTl0QixNQUFNa0IsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzdGMHNCLFVBQVUsQ0FBQzFzQixLQUFLLEdBQUduQyxTQUFTLENBQUNtQyxLQUFLO0lBQ3BDO0lBRUEsSUFBSXBCLE1BQU0rTyxPQUFPLENBQUMrZSxVQUFVLENBQUMsRUFBRSxLQUFLQSxXQUFXNXVCLE1BQU0sS0FBSyxHQUFHO1FBQzNELElBQUl1SSxRQUFRcW1CLFVBQVUsQ0FBQyxFQUFFO1FBRXpCLElBQUksT0FBT3JtQixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJL0YsY0FBYztRQUMxQjtRQUVBLElBQUk0dEIsb0JBQW9CeEIsVUFBVSxDQUFDLEVBQUUsQ0FBQ3pxQixHQUFHLENBQUMsU0FBVTRDLFFBQVE7WUFDMUQsT0FBT0EsV0FBVyxNQUFNd0I7UUFDMUIsR0FBR2hFLElBQUksQ0FBQztRQUNSLE9BQU87WUFDTDhyQixZQUFZRDtRQUNkO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTEMsWUFBWXpCLFdBQVdycUIsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7QUFDRjtBQUVnbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL3BvbGlzaGVkL2Rpc3QvcG9saXNoZWQuZXNtLmpzP2M3YzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBfd3JhcE5hdGl2ZVN1cGVyIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3dyYXBOYXRpdmVTdXBlcic7XG5pbXBvcnQgX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlJztcblxuZnVuY3Rpb24gbGFzdCgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgcmV0dXJuIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSwgX3JlZiA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBfcmVmID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW19yZWZdO1xufVxuXG5mdW5jdGlvbiBuZWdhdGlvbihhKSB7XG4gIHJldHVybiAtYTtcbn1cblxuZnVuY3Rpb24gYWRkaXRpb24oYSwgYikge1xuICByZXR1cm4gYSArIGI7XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsaWNhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhICogYjtcbn1cblxuZnVuY3Rpb24gZGl2aXNpb24oYSwgYikge1xuICByZXR1cm4gYSAvIGI7XG59XG5cbmZ1bmN0aW9uIG1heCgpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1pbigpIHtcbiAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1hKCkge1xuICByZXR1cm4gQXJyYXkub2YuYXBwbHkoQXJyYXksIGFyZ3VtZW50cyk7XG59XG5cbnZhciBkZWZhdWx0U3ltYm9scyA9IHtcbiAgc3ltYm9sczoge1xuICAgICcqJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKicsXG4gICAgICAgIGY6IG11bHRpcGxpY2F0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKicsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKidcbiAgICB9LFxuICAgICcvJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLycsXG4gICAgICAgIGY6IGRpdmlzaW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogNCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnLycsXG4gICAgICByZWdTeW1ib2w6ICcvJ1xuICAgIH0sXG4gICAgJysnOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcrJyxcbiAgICAgICAgZjogYWRkaXRpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKycsXG4gICAgICAgIGY6IGxhc3QsXG4gICAgICAgIG5vdGF0aW9uOiAncHJlZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMyxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKycsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKydcbiAgICB9LFxuICAgICctJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLScsXG4gICAgICAgIGY6IHN1YnRyYWN0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMixcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJy0nLFxuICAgICAgICBmOiBuZWdhdGlvbixcbiAgICAgICAgbm90YXRpb246ICdwcmVmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAzLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICctJyxcbiAgICAgIHJlZ1N5bWJvbDogJy0nXG4gICAgfSxcbiAgICAnLCc6IHtcbiAgICAgIGluZml4OiB7XG4gICAgICAgIHN5bWJvbDogJywnLFxuICAgICAgICBmOiBjb21tYSxcbiAgICAgICAgbm90YXRpb246ICdpbmZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDEsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMlxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJywnLFxuICAgICAgcmVnU3ltYm9sOiAnLCdcbiAgICB9LFxuICAgICcoJzoge1xuICAgICAgcHJlZml4OiB7XG4gICAgICAgIHN5bWJvbDogJygnLFxuICAgICAgICBmOiBsYXN0LFxuICAgICAgICBub3RhdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJygnLFxuICAgICAgcmVnU3ltYm9sOiAnXFxcXCgnXG4gICAgfSxcbiAgICAnKSc6IHtcbiAgICAgIHBvc3RmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKScsXG4gICAgICAgIGY6IHVuZGVmaW5lZCxcbiAgICAgICAgbm90YXRpb246ICdwb3N0Zml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKScsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKSdcbiAgICB9LFxuICAgIG1pbjoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtaW4nLFxuICAgICAgICBmOiBtaW4sXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21pbicsXG4gICAgICByZWdTeW1ib2w6ICdtaW5cXFxcYidcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgZnVuYzoge1xuICAgICAgICBzeW1ib2w6ICdtYXgnLFxuICAgICAgICBmOiBtYXgsXG4gICAgICAgIG5vdGF0aW9uOiAnZnVuYycsXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJ21heCcsXG4gICAgICByZWdTeW1ib2w6ICdtYXhcXFxcYidcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFN5bWJvbE1hcCA9IGRlZmF1bHRTeW1ib2xzO1xuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvYmxvYi9mY2Y2ZjM4MDRjNTdhMTRkZDc5ODRkZmFiN2JjMDZlZTJlZGNhMDQ0L3NyYy91dGlscy9lcnJvci5qc1xuXG4vKipcbiAqIFBhcnNlIGVycm9ycy5tZCBhbmQgdHVybiBpdCBpbnRvIGEgc2ltcGxlIGhhc2ggb2YgY29kZTogbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xudmFyIEVSUk9SUyA9IHtcbiAgXCIxXCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbCwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbCgzNjAsIDAuNzUsIDAuNCkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgaHVlOiAyNTUsIHNhdHVyYXRpb246IDAuNCwgbGlnaHRuZXNzOiAwLjc1IH0pLlxcblxcblwiLFxuICBcIjJcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gaHNsYSwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbGEoMzYwLCAwLjc1LCAwLjQsIDAuNykgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgaHVlOiAyNTUsIHNhdHVyYXRpb246IDAuNCwgbGlnaHRuZXNzOiAwLjc1LCBhbHBoYTogMC43IH0pLlxcblxcblwiLFxuICBcIjNcIjogXCJQYXNzZWQgYW4gaW5jb3JyZWN0IGFyZ3VtZW50IHRvIGEgY29sb3IgZnVuY3Rpb24sIHBsZWFzZSBwYXNzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXFxuXFxuXCIsXG4gIFwiNFwiOiBcIkNvdWxkbid0IGdlbmVyYXRlIHZhbGlkIHJnYiBzdHJpbmcgZnJvbSAlcywgaXQgcmV0dXJuZWQgJXMuXFxuXFxuXCIsXG4gIFwiNVwiOiBcIkNvdWxkbid0IHBhcnNlIHRoZSBjb2xvciBzdHJpbmcuIFBsZWFzZSBwcm92aWRlIHRoZSBjb2xvciBhcyBhIHN0cmluZyBpbiBoZXgsIHJnYiwgcmdiYSwgaHNsIG9yIGhzbGEgbm90YXRpb24uXFxuXFxuXCIsXG4gIFwiNlwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2IsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiByZ2IoMjU1LCAyMDUsIDEwMCkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KS5cXG5cXG5cIixcbiAgXCI3XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIHJnYmEsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiByZ2IoMjU1LCAyMDUsIDEwMCwgMC43NSkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzUgfSkuXFxuXFxuXCIsXG4gIFwiOFwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgUmdiQ29sb3IsIFJnYmFDb2xvciwgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI5XCI6IFwiUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb2Ygc3RlcHMgdG8gdGhlIG1vZHVsYXJTY2FsZSBoZWxwZXIuXFxuXFxuXCIsXG4gIFwiMTBcIjogXCJQbGVhc2UgcGFzcyBhIG51bWJlciBvciBvbmUgb2YgdGhlIHByZWRlZmluZWQgc2NhbGVzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyIGFzIHRoZSByYXRpby5cXG5cXG5cIixcbiAgXCIxMVwiOiBcIkludmFsaWQgdmFsdWUgcGFzc2VkIGFzIGJhc2UgdG8gbW9kdWxhclNjYWxlLCBleHBlY3RlZCBudW1iZXIgb3IgZW0gc3RyaW5nIGJ1dCBnb3QgXFxcIiVzXFxcIlxcblxcblwiLFxuICBcIjEyXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAlcygpLCBnb3QgXFxcIiVzXFxcIiBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjEzXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gJXMoKSwgZ290IFxcXCIlc1xcXCIgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCIxNFwiOiBcIlBhc3NlZCBpbnZhbGlkIHBpeGVsIHZhbHVlIChcXFwiJXNcXFwiKSB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjE1XCI6IFwiUGFzc2VkIGludmFsaWQgYmFzZSB2YWx1ZSAoXFxcIiVzXFxcIikgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCIxNlwiOiBcIllvdSBtdXN0IHByb3ZpZGUgYSB0ZW1wbGF0ZSB0byB0aGlzIG1ldGhvZC5cXG5cXG5cIixcbiAgXCIxN1wiOiBcIllvdSBwYXNzZWQgYW4gdW5zdXBwb3J0ZWQgc2VsZWN0b3Igc3RhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiMThcIjogXCJtaW5TY3JlZW4gYW5kIG1heFNjcmVlbiBtdXN0IGJlIHByb3ZpZGVkIGFzIHN0cmluZ2lmaWVkIG51bWJlcnMgd2l0aCB0aGUgc2FtZSB1bml0cy5cXG5cXG5cIixcbiAgXCIxOVwiOiBcImZyb21TaXplIGFuZCB0b1NpemUgbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiMjBcIjogXCJleHBlY3RzIGVpdGhlciBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGEgc2luZ2xlIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHByb3AsIGZyb21TaXplLCBhbmQgdG9TaXplLlxcblxcblwiLFxuICBcIjIxXCI6IFwiZXhwZWN0cyB0aGUgb2JqZWN0cyBpbiB0aGUgZmlyc3QgYXJndW1lbnQgYXJyYXkgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBgcHJvcGAsIGBmcm9tU2l6ZWAsIGFuZCBgdG9TaXplYC5cXG5cXG5cIixcbiAgXCIyMlwiOiBcImV4cGVjdHMgdGhlIGZpcnN0IGFyZ3VtZW50IG9iamVjdCB0byBoYXZlIHRoZSBwcm9wZXJ0aWVzIGBwcm9wYCwgYGZyb21TaXplYCwgYW5kIGB0b1NpemVgLlxcblxcblwiLFxuICBcIjIzXCI6IFwiZm9udEZhY2UgZXhwZWN0cyBhIG5hbWUgb2YgYSBmb250LWZhbWlseS5cXG5cXG5cIixcbiAgXCIyNFwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZWl0aGVyIHRoZSBwYXRoIHRvIHRoZSBmb250IGZpbGUocykgb3IgYSBuYW1lIG9mIGEgbG9jYWwgY29weS5cXG5cXG5cIixcbiAgXCIyNVwiOiBcImZvbnRGYWNlIGV4cGVjdHMgbG9jYWxGb250cyB0byBiZSBhbiBhcnJheS5cXG5cXG5cIixcbiAgXCIyNlwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZmlsZUZvcm1hdHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiMjdcIjogXCJyYWRpYWxHcmFkaWVudCByZXF1cmllcyBhdCBsZWFzdCAyIGNvbG9yLXN0b3BzIHRvIHByb3Blcmx5IHJlbmRlci5cXG5cXG5cIixcbiAgXCIyOFwiOiBcIlBsZWFzZSBzdXBwbHkgYSBmaWxlbmFtZSB0byByZXRpbmFJbWFnZSgpIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIyOVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRyaWFuZ2xlLCBwbGVhc2UgcGFzcyBjb3JyZWN0IHBvaW50aW5nRGlyZWN0aW9uIGUuZy4gJ3JpZ2h0Jy5cXG5cXG5cIixcbiAgXCIzMFwiOiBcIlBhc3NlZCBhbiBpbnZhbGlkIHZhbHVlIHRvIGBoZWlnaHRgIG9yIGB3aWR0aGAuIFBsZWFzZSBwcm92aWRlIGEgcGl4ZWwgYmFzZWQgdW5pdC5cXG5cXG5cIixcbiAgXCIzMVwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIG9ubHkgdGFrZXMgOCBhcmd1bWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb25cXG5cXG5cIixcbiAgXCIzMlwiOiBcIlRvIHBhc3MgbXVsdGlwbGUgYW5pbWF0aW9ucyBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gYXJyYXlzLCBlLmcuIGFuaW1hdGlvbihbJ3JvdGF0ZScsICcycyddLCBbJ21vdmUnLCAnMXMnXSlcXG5UbyBwYXNzIGEgc2luZ2xlIGFuaW1hdGlvbiBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gc2ltcGxlIHZhbHVlcywgZS5nLiBhbmltYXRpb24oJ3JvdGF0ZScsICcycycpXFxuXFxuXCIsXG4gIFwiMzNcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBhcnJheXMgY2FuIG9ubHkgaGF2ZSA4IGVsZW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uXFxuXFxuXCIsXG4gIFwiMzRcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBhIHJhZGl1cyB2YWx1ZSBhcyBhIHN0cmluZyBvciBudW1iZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIzNVwiOiBcImJvcmRlclJhZGl1cyBleHBlY3RzIG9uZSBvZiBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiBvciBcXFwicmlnaHRcXFwiIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIzNlwiOiBcIlByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgdmFsdWUuXFxuXFxuXCIsXG4gIFwiMzdcIjogXCJTeW50YXggRXJyb3IgYXQgJXMuXFxuXFxuXCIsXG4gIFwiMzhcIjogXCJGb3JtdWxhIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBuZWVkcyBwYXJlbnRoZXNlcyBhdCAlcy5cXG5cXG5cIixcbiAgXCIzOVwiOiBcIkZvcm11bGEgaXMgbWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGF0ICVzLlxcblxcblwiLFxuICBcIjQwXCI6IFwiRm9ybXVsYSBoYXMgdG9vIG1hbnkgY2xvc2luZyBwYXJlbnRoZXNlcyBhdCAlcy5cXG5cXG5cIixcbiAgXCI0MVwiOiBcIkFsbCB2YWx1ZXMgaW4gYSBmb3JtdWxhIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0IG9yIGJlIHVuaXRsZXNzLlxcblxcblwiLFxuICBcIjQyXCI6IFwiUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb2Ygc3RlcHMgdG8gdGhlIG1vZHVsYXJTY2FsZSBoZWxwZXIuXFxuXFxuXCIsXG4gIFwiNDNcIjogXCJQbGVhc2UgcGFzcyBhIG51bWJlciBvciBvbmUgb2YgdGhlIHByZWRlZmluZWQgc2NhbGVzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyIGFzIHRoZSByYXRpby5cXG5cXG5cIixcbiAgXCI0NFwiOiBcIkludmFsaWQgdmFsdWUgcGFzc2VkIGFzIGJhc2UgdG8gbW9kdWxhclNjYWxlLCBleHBlY3RlZCBudW1iZXIgb3IgZW0vcmVtIHN0cmluZyBidXQgZ290ICVzLlxcblxcblwiLFxuICBcIjQ1XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnQgdG8gaHNsVG9Db2xvclN0cmluZywgcGxlYXNlIHBhc3MgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LlxcblxcblwiLFxuICBcIjQ2XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnQgdG8gcmdiVG9Db2xvclN0cmluZywgcGxlYXNlIHBhc3MgYSBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0LlxcblxcblwiLFxuICBcIjQ3XCI6IFwibWluU2NyZWVuIGFuZCBtYXhTY3JlZW4gbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiNDhcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjQ5XCI6IFwiRXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCI1MFwiOiBcIkV4cGVjdHMgdGhlIG9iamVjdHMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFycmF5IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTFcIjogXCJFeHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCBvYmplY3QgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCI1MlwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZWl0aGVyIHRoZSBwYXRoIHRvIHRoZSBmb250IGZpbGUocykgb3IgYSBuYW1lIG9mIGEgbG9jYWwgY29weS5cXG5cXG5cIixcbiAgXCI1M1wiOiBcImZvbnRGYWNlIGV4cGVjdHMgbG9jYWxGb250cyB0byBiZSBhbiBhcnJheS5cXG5cXG5cIixcbiAgXCI1NFwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZmlsZUZvcm1hdHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiNTVcIjogXCJmb250RmFjZSBleHBlY3RzIGEgbmFtZSBvZiBhIGZvbnQtZmFtaWx5LlxcblxcblwiLFxuICBcIjU2XCI6IFwibGluZWFyR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiNTdcIjogXCJyYWRpYWxHcmFkaWVudCByZXF1cmllcyBhdCBsZWFzdCAyIGNvbG9yLXN0b3BzIHRvIHByb3Blcmx5IHJlbmRlci5cXG5cXG5cIixcbiAgXCI1OFwiOiBcIlBsZWFzZSBzdXBwbHkgYSBmaWxlbmFtZSB0byByZXRpbmFJbWFnZSgpIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI1OVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRyaWFuZ2xlLCBwbGVhc2UgcGFzcyBjb3JyZWN0IHBvaW50aW5nRGlyZWN0aW9uIGUuZy4gJ3JpZ2h0Jy5cXG5cXG5cIixcbiAgXCI2MFwiOiBcIlBhc3NlZCBhbiBpbnZhbGlkIHZhbHVlIHRvIGBoZWlnaHRgIG9yIGB3aWR0aGAuIFBsZWFzZSBwcm92aWRlIGEgcGl4ZWwgYmFzZWQgdW5pdC5cXG5cXG5cIixcbiAgXCI2MVwiOiBcIlByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgdmFsdWUuXFxuXFxuXCIsXG4gIFwiNjJcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBhIHJhZGl1cyB2YWx1ZSBhcyBhIHN0cmluZyBvciBudW1iZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI2M1wiOiBcImJvcmRlclJhZGl1cyBleHBlY3RzIG9uZSBvZiBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiBvciBcXFwicmlnaHRcXFwiIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI2NFwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIG9ubHkgdGFrZXMgOCBhcmd1bWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb24uXFxuXFxuXCIsXG4gIFwiNjVcIjogXCJUbyBwYXNzIG11bHRpcGxlIGFuaW1hdGlvbnMgcGxlYXNlIHN1cHBseSB0aGVtIGluIGFycmF5cywgZS5nLiBhbmltYXRpb24oWydyb3RhdGUnLCAnMnMnXSwgWydtb3ZlJywgJzFzJ10pXFxcXG5UbyBwYXNzIGEgc2luZ2xlIGFuaW1hdGlvbiBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gc2ltcGxlIHZhbHVlcywgZS5nLiBhbmltYXRpb24oJ3JvdGF0ZScsICcycycpLlxcblxcblwiLFxuICBcIjY2XCI6IFwiVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvbi5cXG5cXG5cIixcbiAgXCI2N1wiOiBcIllvdSBtdXN0IHByb3ZpZGUgYSB0ZW1wbGF0ZSB0byB0aGlzIG1ldGhvZC5cXG5cXG5cIixcbiAgXCI2OFwiOiBcIllvdSBwYXNzZWQgYW4gdW5zdXBwb3J0ZWQgc2VsZWN0b3Igc3RhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiNjlcIjogXCJFeHBlY3RlZCBhIHN0cmluZyBlbmRpbmcgaW4gXFxcInB4XFxcIiBvciBhIG51bWJlciBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvICVzKCksIGdvdCAlcyBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjcwXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gJXMoKSwgZ290ICVzIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiNzFcIjogXCJQYXNzZWQgaW52YWxpZCBwaXhlbCB2YWx1ZSAlcyB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjcyXCI6IFwiUGFzc2VkIGludmFsaWQgYmFzZSB2YWx1ZSAlcyB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjczXCI6IFwiUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBDU1MgdmFyaWFibGUuXFxuXFxuXCIsXG4gIFwiNzRcIjogXCJDU1MgdmFyaWFibGUgbm90IGZvdW5kIGFuZCBubyBkZWZhdWx0IHdhcyBwcm92aWRlZC5cXG5cXG5cIixcbiAgXCI3NVwiOiBcImltcG9ydGFudCByZXF1aXJlcyBhIHZhbGlkIHN0eWxlIG9iamVjdCwgZ290IGEgJXMgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCI3NlwiOiBcImZyb21TaXplIGFuZCB0b1NpemUgbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMgYXMgbWluU2NyZWVuIGFuZCBtYXhTY3JlZW4uXFxuXFxuXCIsXG4gIFwiNzdcIjogXCJyZW1Ub1B4IGV4cGVjdHMgYSB2YWx1ZSBpbiBcXFwicmVtXFxcIiBidXQgeW91IHByb3ZpZGVkIGl0IGluIFxcXCIlc1xcXCIuXFxuXFxuXCIsXG4gIFwiNzhcIjogXCJiYXNlIG11c3QgYmUgc2V0IGluIFxcXCJweFxcXCIgb3IgXFxcIiVcXFwiIGJ1dCB5b3Ugc2V0IGl0IGluIFxcXCIlc1xcXCIuXFxuXCJcbn07XG4vKipcbiAqIHN1cGVyIGJhc2ljIHZlcnNpb24gb2Ygc3ByaW50ZlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXQoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgYSA9IGFyZ3NbMF07XG4gIHZhciBiID0gW107XG4gIHZhciBjO1xuXG4gIGZvciAoYyA9IDE7IGMgPCBhcmdzLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgYi5wdXNoKGFyZ3NbY10pO1xuICB9XG5cbiAgYi5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgYSA9IGEucmVwbGFjZSgvJVthLXpdLywgZCk7XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIGZpbGUgb3V0IG9mIGVycm9ycy5tZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGEgc2ltcGxlIHdlYiBsaW5rIHRvIHRoZSBmdWxsIGVycm9yc1xuICogaW4gcHJvZHVjdGlvbiBtb2RlLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBQb2xpc2hlZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9saXNoZWRFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBQb2xpc2hlZEVycm9yKGNvZGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBcIkFuIGVycm9yIG9jY3VycmVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3BvbGlzaGVkL2Jsb2IvbWFpbi9zcmMvaW50ZXJuYWxIZWxwZXJzL2Vycm9ycy5tZCNcIiArIGNvZGUgKyBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikgfHwgdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBmb3JtYXQuYXBwbHkodm9pZCAwLCBbRVJST1JTW2NvZGVdXS5jb25jYXQoYXJncykpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgfVxuXG4gIHJldHVybiBQb2xpc2hlZEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIHVuaXRSZWdFeHAgPSAvKCg/IVxcdylhfG5hfGhjfG1jfGRnfG1lW3JdP3x4ZXxuaSg/IVthLXpBLVpdKXxtbXxjcHx0cHx4cHxxKD8hcyl8aHZ8eGFtdnxuaW12fHd2fHNtfHMoPyFcXER8JCl8Z2VkfGRhcmc/fG5ydXQpL2c7IC8vIE1lcmdlcyBhZGRpdGlvbmFsIG1hdGggZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBkZWZhdWx0cy5cblxuZnVuY3Rpb24gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKSB7XG4gIHZhciBzeW1ib2xNYXAgPSB7fTtcbiAgc3ltYm9sTWFwLnN5bWJvbHMgPSBhZGRpdGlvbmFsU3ltYm9scyA/IF9leHRlbmRzKHt9LCBkZWZhdWx0U3ltYm9sTWFwLnN5bWJvbHMsIGFkZGl0aW9uYWxTeW1ib2xzLnN5bWJvbHMpIDogX2V4dGVuZHMoe30sIGRlZmF1bHRTeW1ib2xNYXAuc3ltYm9scyk7XG4gIHJldHVybiBzeW1ib2xNYXA7XG59XG5cbmZ1bmN0aW9uIGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpIHtcbiAgdmFyIF9yZWY7XG5cbiAgdmFyIG9wID0gb3BlcmF0b3JzLnBvcCgpO1xuICB2YWx1ZXMucHVzaChvcC5mLmFwcGx5KG9wLCAoX3JlZiA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZiwgdmFsdWVzLnNwbGljZSgtb3AuYXJnQ291bnQpKSkpO1xuICByZXR1cm4gb3AucHJlY2VkZW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlKGV4cHJlc3Npb24sIGFkZGl0aW9uYWxTeW1ib2xzKSB7XG4gIHZhciBzeW1ib2xNYXAgPSBtZXJnZVN5bWJvbE1hcHMoYWRkaXRpb25hbFN5bWJvbHMpO1xuICB2YXIgbWF0Y2g7XG4gIHZhciBvcGVyYXRvcnMgPSBbc3ltYm9sTWFwLnN5bWJvbHNbJygnXS5wcmVmaXhdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggLy8gUGF0dGVybiBmb3IgbnVtYmVyc1xuICBcIlxcXFxkKyg/OlxcXFwuXFxcXGQrKT98XCIgKyAvLyAuLi5hbmQgcGF0dGVybnMgZm9yIGluZGl2aWR1YWwgb3BlcmF0b3JzL2Z1bmN0aW9uIG5hbWVzXG4gIE9iamVjdC5rZXlzKHN5bWJvbE1hcC5zeW1ib2xzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzeW1ib2xNYXAuc3ltYm9sc1trZXldO1xuICB9KSAvLyBsb25nZXIgc3ltYm9scyBzaG91bGQgYmUgbGlzdGVkIGZpcnN0XG4gIC8vICRGbG93Rml4TWVcbiAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5zeW1ib2wubGVuZ3RoIC0gYS5zeW1ib2wubGVuZ3RoO1xuICB9KSAvLyAkRmxvd0ZpeE1lXG4gIC5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVnU3ltYm9sO1xuICB9KS5qb2luKCd8JykgKyBcInwoXFxcXFMpXCIsICdnJyk7XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gMDsgLy8gUmVzZXQgcmVndWxhciBleHByZXNzaW9uIG9iamVjdFxuXG4gIHZhciBhZnRlclZhbHVlID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIG1hdGNoID0gcGF0dGVybi5leGVjKGV4cHJlc3Npb24pO1xuXG4gICAgdmFyIF9yZWYyID0gbWF0Y2ggfHwgWycpJywgdW5kZWZpbmVkXSxcbiAgICAgICAgdG9rZW4gPSBfcmVmMlswXSxcbiAgICAgICAgYmFkID0gX3JlZjJbMV07XG5cbiAgICB2YXIgbm90TnVtYmVyID0gc3ltYm9sTWFwLnN5bWJvbHNbdG9rZW5dO1xuICAgIHZhciBub3ROZXdWYWx1ZSA9IG5vdE51bWJlciAmJiAhbm90TnVtYmVyLnByZWZpeCAmJiAhbm90TnVtYmVyLmZ1bmM7XG4gICAgdmFyIG5vdEFmdGVyVmFsdWUgPSAhbm90TnVtYmVyIHx8ICFub3ROdW1iZXIucG9zdGZpeCAmJiAhbm90TnVtYmVyLmluZml4OyAvLyBDaGVjayBmb3Igc3ludGF4IGVycm9yczpcblxuICAgIGlmIChiYWQgfHwgKGFmdGVyVmFsdWUgPyBub3RBZnRlclZhbHVlIDogbm90TmV3VmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzNywgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJWYWx1ZSkge1xuICAgICAgLy8gV2UgZWl0aGVyIGhhdmUgYW4gaW5maXggb3IgcG9zdGZpeCBvcGVyYXRvciAodGhleSBzaG91bGQgYmUgbXV0dWFsbHkgZXhjbHVzaXZlKVxuICAgICAgdmFyIGN1cnIgPSBub3ROdW1iZXIucG9zdGZpeCB8fCBub3ROdW1iZXIuaW5maXg7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHByZXYgPSBvcGVyYXRvcnNbb3BlcmF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoKGN1cnIucHJlY2VkZW5jZSAtIHByZXYucHJlY2VkZW5jZSB8fCBwcmV2LnJpZ2h0VG9MZWZ0KSA+IDApIGJyZWFrOyAvLyBBcHBseSBwcmV2aW91cyBvcGVyYXRvciwgc2luY2UgaXQgaGFzIHByZWNlZGVuY2Ugb3ZlciBjdXJyZW50IG9uZVxuICAgICAgfSB3aGlsZSAoZXhlYyhvcGVyYXRvcnMsIHZhbHVlcykpOyAvLyBFeGl0IGxvb3AgYWZ0ZXIgZXhlY3V0aW5nIGFuIG9wZW5pbmcgcGFyZW50aGVzaXMgb3IgZnVuY3Rpb25cblxuXG4gICAgICBhZnRlclZhbHVlID0gY3Vyci5ub3RhdGlvbiA9PT0gJ3Bvc3RmaXgnO1xuXG4gICAgICBpZiAoY3Vyci5zeW1ib2wgIT09ICcpJykge1xuICAgICAgICBvcGVyYXRvcnMucHVzaChjdXJyKTsgLy8gUG9zdGZpeCBhbHdheXMgaGFzIHByZWNlZGVuY2Ugb3ZlciBhbnkgb3BlcmF0b3IgdGhhdCBmb2xsb3dzIGFmdGVyIGl0XG5cbiAgICAgICAgaWYgKGFmdGVyVmFsdWUpIGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm90TnVtYmVyKSB7XG4gICAgICAvLyBwcmVmaXggb3BlcmF0b3Igb3IgZnVuY3Rpb25cbiAgICAgIG9wZXJhdG9ycy5wdXNoKG5vdE51bWJlci5wcmVmaXggfHwgbm90TnVtYmVyLmZ1bmMpO1xuXG4gICAgICBpZiAobm90TnVtYmVyLmZ1bmMpIHtcbiAgICAgICAgLy8gUmVxdWlyZSBhbiBvcGVuaW5nIHBhcmVudGhlc2lzXG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMF0gIT09ICcoJykge1xuICAgICAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDM4LCBtYXRjaCA/IG1hdGNoLmluZGV4IDogZXhwcmVzc2lvbi5sZW5ndGgsIGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG51bWJlclxuICAgICAgdmFsdWVzLnB1c2goK3Rva2VuKTtcbiAgICAgIGFmdGVyVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSB3aGlsZSAobWF0Y2ggJiYgb3BlcmF0b3JzLmxlbmd0aCk7XG5cbiAgaWYgKG9wZXJhdG9ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzOSwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQwLCBtYXRjaCA/IG1hdGNoLmluZGV4IDogZXhwcmVzc2lvbi5sZW5ndGgsIGV4cHJlc3Npb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZXMucG9wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIGRvaW5nIG1hdGggd2l0aCBDU1MgVW5pdHMuIEFjY2VwdHMgYSBmb3JtdWxhIGFzIGEgc3RyaW5nLiBBbGwgdmFsdWVzIGluIHRoZSBmb3JtdWxhIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0IChvciBiZSB1bml0bGVzcykuIFN1cHBvcnRzIGNvbXBsZXggZm9ybXVsYXMgdXRsaXppaW5nIGFkZGl0aW9uLCBzdWJ0cmFjdGlvbiwgbXVsdGlwbGljYXRpb24sIGRpdmlzaW9uLCBzcXVhcmUgcm9vdCwgcG93ZXJzLCBmYWN0b3JpYWwsIG1pbiwgbWF4LCBhcyB3ZWxsIGFzIHBhcmVudGhlc2VzIGZvciBvcmRlciBvZiBvcGVyYXRpb24uXG4gKlxuICpJbiBjYXNlcyB3aGVyZSB5b3UgbmVlZCB0byBkbyBjYWxjdWxhdGlvbnMgd2l0aCBtaXhlZCB1bml0cyB3aGVyZSBvbmUgdW5pdCBpcyBhIFtyZWxhdGl2ZSBsZW5ndGggdW5pdF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xlbmd0aCNSZWxhdGl2ZV9sZW5ndGhfdW5pdHMpLCB5b3Ugd2lsbCB3YW50IHRvIHVzZSBbQ1NTIENhbGNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jYWxjKS5cbiAqXG4gKiAqd2FybmluZyogV2hpbGUgd2UndmUgZG9uZSBldmVyeXRoaW5nIHBvc3NpYmxlIHRvIGVuc3VyZSBtYXRoIHNhZmVseSBldmFsdXRlcyBmb3JtdWxhcyBleHByZXNzZWQgYXMgc3RyaW5ncywgeW91IHNob3VsZCBhbHdheXMgdXNlIGV4dHJlbWUgY2F1dGlvbiB3aGVuIHBhc3NpbmcgYG1hdGhgIHVzZXIgcHJvdmlkZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgZm9udFNpemU6IG1hdGgoJzEycmVtICsgOHJlbScpLFxuICogICBmb250U2l6ZTogbWF0aCgnKDEycHggKyAycHgpICogMycpLFxuICogICBmb250U2l6ZTogbWF0aCgnM3B4XjIgKyBzcXJ0KDQpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGZvbnRTaXplOiAke21hdGgoJzEycmVtICsgOHJlbScpfTtcbiAqICAgZm9udFNpemU6ICR7bWF0aCgnKDEycHggKyAycHgpICogMycpfTtcbiAqICAgZm9udFNpemU6ICR7bWF0aCgnM3B4XjIgKyBzcXJ0KDQpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgZm9udFNpemU6ICcyMHJlbScsXG4gKiAgIGZvbnRTaXplOiAnNDJweCcsXG4gKiAgIGZvbnRTaXplOiAnMTFweCcsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBtYXRoKGZvcm11bGEsIGFkZGl0aW9uYWxTeW1ib2xzKSB7XG4gIHZhciByZXZlcnNlZEZvcm11bGEgPSByZXZlcnNlU3RyaW5nKGZvcm11bGEpO1xuICB2YXIgZm9ybXVsYU1hdGNoID0gcmV2ZXJzZWRGb3JtdWxhLm1hdGNoKHVuaXRSZWdFeHApOyAvLyBDaGVjayB0aGF0IGFsbCB1bml0cyBhcmUgdGhlIHNhbWVcblxuICBpZiAoZm9ybXVsYU1hdGNoICYmICFmb3JtdWxhTWF0Y2guZXZlcnkoZnVuY3Rpb24gKHVuaXQpIHtcbiAgICByZXR1cm4gdW5pdCA9PT0gZm9ybXVsYU1hdGNoWzBdO1xuICB9KSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQxKTtcbiAgfVxuXG4gIHZhciBjbGVhbkZvcm11bGEgPSByZXZlcnNlU3RyaW5nKHJldmVyc2VkRm9ybXVsYS5yZXBsYWNlKHVuaXRSZWdFeHAsICcnKSk7XG4gIHJldHVybiBcIlwiICsgY2FsY3VsYXRlKGNsZWFuRm9ybXVsYSwgYWRkaXRpb25hbFN5bWJvbHMpICsgKGZvcm11bGFNYXRjaCA/IHJldmVyc2VTdHJpbmcoZm9ybXVsYU1hdGNoWzBdKSA6ICcnKTtcbn1cblxudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvLS1bXFxTXSovZztcbi8qKlxuICogRmV0Y2hlcyB0aGUgdmFsdWUgb2YgYSBwYXNzZWQgQ1NTIFZhcmlhYmxlIGluIHRoZSA6cm9vdCBzY29wZSwgb3Igb3RoZXJ3aXNlIHJldHVybnMgYSBkZWZhdWx0VmFsdWUgaWYgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2JhY2tncm91bmQnOiBjc3NWYXIoJy0tYmFja2dyb3VuZC1jb2xvcicpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2Nzc1ZhcignLS1iYWNrZ3JvdW5kLWNvbG9yJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2JhY2tncm91bmQnOiAncmVkJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGNzc1Zhcihjc3NWYXJpYWJsZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghY3NzVmFyaWFibGUgfHwgIWNzc1ZhcmlhYmxlLm1hdGNoKGNzc1ZhcmlhYmxlUmVnZXgpKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzMpO1xuICB9XG5cbiAgdmFyIHZhcmlhYmxlVmFsdWU7XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICB2YXJpYWJsZVZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoY3NzVmFyaWFibGUpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuXG4gIGlmICh2YXJpYWJsZVZhbHVlKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUudHJpbSgpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3NCk7XG59XG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBjYXBpdGFsaXplU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG52YXIgcG9zaXRpb25NYXAkMSA9IFsnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdMZWZ0J107XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvcGVydHkocHJvcGVydHksIHBvc2l0aW9uKSB7XG4gIGlmICghcHJvcGVydHkpIHJldHVybiBwb3NpdGlvbi50b0xvd2VyQ2FzZSgpO1xuICB2YXIgc3BsaXRQcm9wZXJ0eSA9IHByb3BlcnR5LnNwbGl0KCctJyk7XG5cbiAgaWYgKHNwbGl0UHJvcGVydHkubGVuZ3RoID4gMSkge1xuICAgIHNwbGl0UHJvcGVydHkuc3BsaWNlKDEsIDAsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gc3BsaXRQcm9wZXJ0eS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGFjYyArIGNhcGl0YWxpemVTdHJpbmcodmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBqb2luZWRQcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDFcIiArIHBvc2l0aW9uICsgXCIkMlwiKTtcbiAgcmV0dXJuIHByb3BlcnR5ID09PSBqb2luZWRQcm9wZXJ0eSA/IFwiXCIgKyBwcm9wZXJ0eSArIHBvc2l0aW9uIDogam9pbmVkUHJvcGVydHk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3R5bGVzKHByb3BlcnR5LCB2YWx1ZXNXaXRoRGVmYXVsdHMpIHtcbiAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzV2l0aERlZmF1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHZhbHVlc1dpdGhEZWZhdWx0c1tpXSB8fCB2YWx1ZXNXaXRoRGVmYXVsdHNbaV0gPT09IDApIHtcbiAgICAgIHN0eWxlc1tnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbk1hcCQxW2ldKV0gPSB2YWx1ZXNXaXRoRGVmYXVsdHNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cbi8qKlxuICogRW5hYmxlcyBzaG9ydGhhbmQgZm9yIGRpcmVjdGlvbi1iYXNlZCBwcm9wZXJ0aWVzLiBJdCBhY2NlcHRzIGEgcHJvcGVydHkgKGh5cGhlbmF0ZWQgb3IgY2FtZWxDYXNlZCkgYW5kIHVwIHRvIGZvdXIgdmFsdWVzIHRoYXQgbWFwIHRvIHRvcCwgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQsIHJlc3BlY3RpdmVseS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZW1wdHkgc3RyaW5nIHRvIGdldCBvbmx5IHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgYXMgcHJvcGVydGllcy4gWW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgcGFzcyBhIG51bGwgYXJndW1lbnQgZm9yIGEgZGlyZWN0aW9uYWwgdmFsdWUgdG8gaWdub3JlIGl0LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZGlyZWN0aW9uYWxQcm9wZXJ0eSgncGFkZGluZycsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtkaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3BhZGRpbmdUb3AnOiAnMTJweCcsXG4gKiAgICdwYWRkaW5nUmlnaHQnOiAnMjRweCcsXG4gKiAgICdwYWRkaW5nQm90dG9tJzogJzM2cHgnLFxuICogICAncGFkZGluZ0xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpcmVjdGlvbmFsUHJvcGVydHkocHJvcGVydHkpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIC8vICBwcmV0dGllci1pZ25vcmVcbiAgdmFyIGZpcnN0VmFsdWUgPSB2YWx1ZXNbMF0sXG4gICAgICBfdmFsdWVzJCA9IHZhbHVlc1sxXSxcbiAgICAgIHNlY29uZFZhbHVlID0gX3ZhbHVlcyQgPT09IHZvaWQgMCA/IGZpcnN0VmFsdWUgOiBfdmFsdWVzJCxcbiAgICAgIF92YWx1ZXMkMiA9IHZhbHVlc1syXSxcbiAgICAgIHRoaXJkVmFsdWUgPSBfdmFsdWVzJDIgPT09IHZvaWQgMCA/IGZpcnN0VmFsdWUgOiBfdmFsdWVzJDIsXG4gICAgICBfdmFsdWVzJDMgPSB2YWx1ZXNbM10sXG4gICAgICBmb3VydGhWYWx1ZSA9IF92YWx1ZXMkMyA9PT0gdm9pZCAwID8gc2Vjb25kVmFsdWUgOiBfdmFsdWVzJDM7XG4gIHZhciB2YWx1ZXNXaXRoRGVmYXVsdHMgPSBbZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUsIGZvdXJ0aFZhbHVlXTtcbiAgcmV0dXJuIGdlbmVyYXRlU3R5bGVzKHByb3BlcnR5LCB2YWx1ZXNXaXRoRGVmYXVsdHMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGVuZHMgd2l0aCBzb21ldGhpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgc3VmZml4KSB7XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyKC1zdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4O1xufVxuXG52YXIgY3NzUmVnZXgkMSA9IC9eKFsrLV0/KD86XFxkK3xcXGQqXFwuXFxkKykpKFthLXpdKnwlKSQvO1xuLyoqXG4gKiBSZXR1cm5zIGEgZ2l2ZW4gQ1NTIHZhbHVlIG1pbnVzIGl0cyB1bml0IG9mIG1lYXN1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJy0tZGltZW5zaW9uJzogc3RyaXBVbml0KCcxMDBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIC0tZGltZW5zaW9uOiAke3N0cmlwVW5pdCgnMTAwcHgnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnLS1kaW1lbnNpb24nOiAxMDBcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcFVuaXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZTtcbiAgdmFyIG1hdGNoZWRWYWx1ZSA9IHZhbHVlLm1hdGNoKGNzc1JlZ2V4JDEpO1xuICByZXR1cm4gbWF0Y2hlZFZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBwaXhlbC10by14IGNvbnZlcnRlcnNcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHB4dG9GYWN0b3J5ID0gZnVuY3Rpb24gcHh0b0ZhY3RvcnkodG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChweHZhbCwgYmFzZSkge1xuICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgIGJhc2UgPSAnMTZweCc7XG4gICAgfVxuXG4gICAgdmFyIG5ld1B4dmFsID0gcHh2YWw7XG4gICAgdmFyIG5ld0Jhc2UgPSBiYXNlO1xuXG4gICAgaWYgKHR5cGVvZiBweHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghZW5kc1dpdGgocHh2YWwsICdweCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY5LCB0bywgcHh2YWwpO1xuICAgICAgfVxuXG4gICAgICBuZXdQeHZhbCA9IHN0cmlwVW5pdChweHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFlbmRzV2l0aChiYXNlLCAncHgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3MCwgdG8sIGJhc2UpO1xuICAgICAgfVxuXG4gICAgICBuZXdCYXNlID0gc3RyaXBVbml0KGJhc2UpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3UHh2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3MSwgcHh2YWwsIHRvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0Jhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3MiwgYmFzZSwgdG8pO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiICsgbmV3UHh2YWwgLyBuZXdCYXNlICsgdG87XG4gIH07XG59O1xuXG52YXIgcGl4ZWxzdG8gPSBweHRvRmFjdG9yeTtcblxuLyoqXG4gKiBDb252ZXJ0IHBpeGVsIHZhbHVlIHRvIGVtcy4gVGhlIGRlZmF1bHQgYmFzZSB2YWx1ZSBpcyAxNnB4LCBidXQgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhXG4gKiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHB4dmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtiYXNlPScxNnB4J11cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdoZWlnaHQnOiBlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtlbSgnMTZweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2hlaWdodCc6ICcxZW0nXG4gKiB9XG4gKi9cblxudmFyIGVtID0gLyojX19QVVJFX18qL3BpeGVsc3RvKCdlbScpO1xudmFyIGVtJDEgPSBlbTtcblxudmFyIGNzc1JlZ2V4ID0gL14oWystXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSkoW2Etel0qfCUpJC87XG4vKipcbiAqIFJldHVybnMgYSBnaXZlbiBDU1MgdmFsdWUgYW5kIGl0cyB1bml0IGFzIGVsZW1lbnRzIG9mIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICctLWRpbWVuc2lvbic6IGdldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVswXSxcbiAqICAgJy0tdW5pdCc6IGdldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVsxXSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgLS1kaW1lbnNpb246ICR7Z2V0VmFsdWVBbmRVbml0KCcxMDBweCcpWzBdfTtcbiAqICAgLS11bml0OiAke2dldFZhbHVlQW5kVW5pdCgnMTAwcHgnKVsxXX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnLS1kaW1lbnNpb24nOiAxMDAsXG4gKiAgICctLXVuaXQnOiAncHgnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlQW5kVW5pdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIFt2YWx1ZSwgJyddO1xuICB2YXIgbWF0Y2hlZFZhbHVlID0gdmFsdWUubWF0Y2goY3NzUmVnZXgpO1xuICBpZiAobWF0Y2hlZFZhbHVlKSByZXR1cm4gW3BhcnNlRmxvYXQodmFsdWUpLCBtYXRjaGVkVmFsdWVbMl1dO1xuICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGFyZ2V0aW5nIHJ1bGVzIGluIGEgc3R5bGUgYmxvY2sgZ2VuZXJhdGVkIGJ5IHBvbGlzaGVkIG1vZHVsZXMgdGhhdCBuZWVkICFpbXBvcnRhbnQtbGV2ZWwgc3BlY2lmaWNpdHkuIENhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBydWxlIChvciBydWxlcykgdG8gdGFyZ2V0IHNwZWNpZmljIHJ1bGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmltcG9ydGFudChjb3ZlcigpKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2ltcG9ydGFudChjb3ZlcigpKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZSAhaW1wb3J0YW50JyxcbiAqICAgJ3RvcCc6ICcwICFpbXBvcnRhbnQnLFxuICogICAncmlnaHQ6ICcwICFpbXBvcnRhbnQnLFxuICogICAnYm90dG9tJzogJzAgIWltcG9ydGFudCcsXG4gKiAgICdsZWZ0OiAnMCAhaW1wb3J0YW50J1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGltcG9ydGFudChzdHlsZUJsb2NrLCBydWxlcykge1xuICBpZiAodHlwZW9mIHN0eWxlQmxvY2sgIT09ICdvYmplY3QnIHx8IHN0eWxlQmxvY2sgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3NSwgdHlwZW9mIHN0eWxlQmxvY2spO1xuICB9XG5cbiAgdmFyIG5ld1N0eWxlQmxvY2sgPSB7fTtcbiAgT2JqZWN0LmtleXMoc3R5bGVCbG9jaykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZUJsb2NrW2tleV0gPT09ICdvYmplY3QnICYmIHN0eWxlQmxvY2tba2V5XSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3R5bGVCbG9ja1trZXldID0gaW1wb3J0YW50KHN0eWxlQmxvY2tba2V5XSwgcnVsZXMpO1xuICAgIH0gZWxzZSBpZiAoIXJ1bGVzIHx8IHJ1bGVzICYmIChydWxlcyA9PT0ga2V5IHx8IHJ1bGVzLmluZGV4T2Yoa2V5KSA+PSAwKSkge1xuICAgICAgbmV3U3R5bGVCbG9ja1trZXldID0gc3R5bGVCbG9ja1trZXldICsgXCIgIWltcG9ydGFudFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZUJsb2NrW2tleV0gPSBzdHlsZUJsb2NrW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld1N0eWxlQmxvY2s7XG59XG5cbnZhciByYXRpb05hbWVzID0ge1xuICBtaW5vclNlY29uZDogMS4wNjcsXG4gIG1ham9yU2Vjb25kOiAxLjEyNSxcbiAgbWlub3JUaGlyZDogMS4yLFxuICBtYWpvclRoaXJkOiAxLjI1LFxuICBwZXJmZWN0Rm91cnRoOiAxLjMzMyxcbiAgYXVnRm91cnRoOiAxLjQxNCxcbiAgcGVyZmVjdEZpZnRoOiAxLjUsXG4gIG1pbm9yU2l4dGg6IDEuNixcbiAgZ29sZGVuU2VjdGlvbjogMS42MTgsXG4gIG1ham9yU2l4dGg6IDEuNjY3LFxuICBtaW5vclNldmVudGg6IDEuNzc4LFxuICBtYWpvclNldmVudGg6IDEuODc1LFxuICBvY3RhdmU6IDIsXG4gIG1ham9yVGVudGg6IDIuNSxcbiAgbWFqb3JFbGV2ZW50aDogMi42NjcsXG4gIG1ham9yVHdlbGZ0aDogMyxcbiAgZG91YmxlT2N0YXZlOiA0XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpbyhyYXRpb05hbWUpIHtcbiAgcmV0dXJuIHJhdGlvTmFtZXNbcmF0aW9OYW1lXTtcbn1cbi8qKlxuICogRXN0YWJsaXNoIGNvbnNpc3RlbnQgbWVhc3VyZW1lbnRzIGFuZCBzcGFjaWFsIHJlbGF0aW9uc2hpcHMgdGhyb3VnaG91dCB5b3VyIHByb2plY3RzIGJ5IGluY3JlbWVudGluZyBhbiBlbSBvciByZW0gdmFsdWUgdXAgb3IgZG93biBhIGRlZmluZWQgc2NhbGUuIFdlIHByb3ZpZGUgYSBsaXN0IG9mIGNvbW1vbmx5IHVzZWQgc2NhbGVzIGFzIHByZS1kZWZpbmVkIHZhcmlhYmxlcy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAvLyBJbmNyZW1lbnQgdHdvIHN0ZXBzIHVwIHRoZSBkZWZhdWx0IHNjYWxlXG4gKiAgICdmb250U2l6ZSc6IG1vZHVsYXJTY2FsZSgyKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAgLy8gSW5jcmVtZW50IHR3byBzdGVwcyB1cCB0aGUgZGVmYXVsdCBzY2FsZVxuICogICBmb250U2l6ZTogJHttb2R1bGFyU2NhbGUoMil9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnZm9udFNpemUnOiAnMS43NzY4OWVtJ1xuICogfVxuICovXG5cblxuZnVuY3Rpb24gbW9kdWxhclNjYWxlKHN0ZXBzLCBiYXNlLCByYXRpbykge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZSA9ICcxZW0nO1xuICB9XG5cbiAgaWYgKHJhdGlvID09PSB2b2lkIDApIHtcbiAgICByYXRpbyA9IDEuMzMzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGVwcyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0Mik7XG4gIH1cblxuICBpZiAodHlwZW9mIHJhdGlvID09PSAnc3RyaW5nJyAmJiAhcmF0aW9OYW1lc1tyYXRpb10pIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0Myk7XG4gIH1cblxuICB2YXIgX3JlZiA9IHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJyA/IGdldFZhbHVlQW5kVW5pdChiYXNlKSA6IFtiYXNlLCAnJ10sXG4gICAgICByZWFsQmFzZSA9IF9yZWZbMF0sXG4gICAgICB1bml0ID0gX3JlZlsxXTtcblxuICB2YXIgcmVhbFJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAnc3RyaW5nJyA/IGdldFJhdGlvKHJhdGlvKSA6IHJhdGlvO1xuXG4gIGlmICh0eXBlb2YgcmVhbEJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDQsIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIgKyByZWFsQmFzZSAqIE1hdGgucG93KHJlYWxSYXRpbywgc3RlcHMpICsgKHVuaXQgfHwgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgcGl4ZWwgdmFsdWUgdG8gcmVtcy4gVGhlIGRlZmF1bHQgYmFzZSB2YWx1ZSBpcyAxNnB4LCBidXQgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhXG4gKiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHB4dmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtiYXNlPScxNnB4J11cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdoZWlnaHQnOiByZW0oJzE2cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBoZWlnaHQ6ICR7cmVtKCcxNnB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnaGVpZ2h0JzogJzFyZW0nXG4gKiB9XG4gKi9cblxudmFyIHJlbSA9IC8qI19fUFVSRV9fKi9waXhlbHN0bygncmVtJyk7XG52YXIgcmVtJDEgPSByZW07XG5cbnZhciBkZWZhdWx0Rm9udFNpemUgPSAxNjtcblxuZnVuY3Rpb24gY29udmVydEJhc2UoYmFzZSkge1xuICB2YXIgZGVjb25zdHJ1Y3RlZFZhbHVlID0gZ2V0VmFsdWVBbmRVbml0KGJhc2UpO1xuXG4gIGlmIChkZWNvbnN0cnVjdGVkVmFsdWVbMV0gPT09ICdweCcpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNlKTtcbiAgfVxuXG4gIGlmIChkZWNvbnN0cnVjdGVkVmFsdWVbMV0gPT09ICclJykge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2UpIC8gMTAwICogZGVmYXVsdEZvbnRTaXplO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzgsIGRlY29uc3RydWN0ZWRWYWx1ZVsxXSk7XG59XG5cbmZ1bmN0aW9uIGdldEJhc2VGcm9tRG9jKCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHZhciByb290Rm9udFNpemUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZm9udFNpemU7XG4gICAgcmV0dXJuIHJvb3RGb250U2l6ZSA/IGNvbnZlcnRCYXNlKHJvb3RGb250U2l6ZSkgOiBkZWZhdWx0Rm9udFNpemU7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICByZXR1cm4gZGVmYXVsdEZvbnRTaXplO1xufVxuLyoqXG4gKiBDb252ZXJ0IHJlbSB2YWx1ZXMgdG8gcHguIEJ5IGRlZmF1bHQsIHRoZSBiYXNlIHZhbHVlIGlzIHB1bGxlZCBmcm9tIHRoZSBmb250LXNpemUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudCAoaWYgaXQgaXMgc2V0IGluICUgb3IgcHgpLiBJdCBkZWZhdWx0cyB0byAxNnB4IGlmIG5vdCBmb3VuZCBvbiB0aGUgcm9vdC4gWW91IGNhbiBhbHNvIG92ZXJyaWRlIHRoZSBiYXNlIHZhbHVlIGJ5IHByb3ZpZGluZyB5b3VyIG93biBiYXNlIGluICUgb3IgcHguXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnaGVpZ2h0JzogcmVtVG9QeCgnMS42cmVtJylcbiAqICAgJ2hlaWdodCc6IHJlbVRvUHgoJzEuNnJlbScsICcxMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgaGVpZ2h0OiAke3JlbVRvUHgoJzEuNnJlbScpfVxuICogICBoZWlnaHQ6ICR7cmVtVG9QeCgnMS42cmVtJywgJzEwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMjUuNnB4JyxcbiAqICAgJ2hlaWdodCc6ICcxNnB4JyxcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbVRvUHgodmFsdWUsIGJhc2UpIHtcbiAgdmFyIGRlY29uc3RydWN0ZWRWYWx1ZSA9IGdldFZhbHVlQW5kVW5pdCh2YWx1ZSk7XG5cbiAgaWYgKGRlY29uc3RydWN0ZWRWYWx1ZVsxXSAhPT0gJ3JlbScgJiYgZGVjb25zdHJ1Y3RlZFZhbHVlWzFdICE9PSAnJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDc3LCBkZWNvbnN0cnVjdGVkVmFsdWVbMV0pO1xuICB9XG5cbiAgdmFyIG5ld0Jhc2UgPSBiYXNlID8gY29udmVydEJhc2UoYmFzZSkgOiBnZXRCYXNlRnJvbURvYygpO1xuICByZXR1cm4gZGVjb25zdHJ1Y3RlZFZhbHVlWzBdICogbmV3QmFzZSArIFwicHhcIjtcbn1cblxudmFyIGZ1bmN0aW9uc01hcCQzID0ge1xuICBiYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknLFxuICBjaXJjOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAgMC4wNDAsIDAuOTgwLCAwLjMzNSknLFxuICBjdWJpYzogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDU1LCAwLjY3NSwgMC4xOTApJyxcbiAgZXhwbzogJ2N1YmljLWJlemllcigwLjk1MCwgIDAuMDUwLCAwLjc5NSwgMC4wMzUpJyxcbiAgcXVhZDogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDg1LCAwLjY4MCwgMC41MzApJyxcbiAgcXVhcnQ6ICdjdWJpYy1iZXppZXIoMC44OTUsICAwLjAzMCwgMC42ODUsIDAuMjIwKScsXG4gIHF1aW50OiAnY3ViaWMtYmV6aWVyKDAuNzU1LCAgMC4wNTAsIDAuODU1LCAwLjA2MCknLFxuICBzaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDcwLCAgMC4wMDAsIDAuNzQ1LCAwLjcxNSknXG59O1xuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlSW4oJ3F1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke2Vhc2VJbigncXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZWFzZUluKGZ1bmN0aW9uTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb25zTWFwJDNbZnVuY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXTtcbn1cblxudmFyIGZ1bmN0aW9uc01hcCQyID0ge1xuICBiYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjgwLCAtMC41NTAsIDAuMjY1LCAxLjU1MCknLFxuICBjaXJjOiAnY3ViaWMtYmV6aWVyKDAuNzg1LCAgMC4xMzUsIDAuMTUwLCAwLjg2MCknLFxuICBjdWJpYzogJ2N1YmljLWJlemllcigwLjY0NSwgIDAuMDQ1LCAwLjM1NSwgMS4wMDApJyxcbiAgZXhwbzogJ2N1YmljLWJlemllcigxLjAwMCwgIDAuMDAwLCAwLjAwMCwgMS4wMDApJyxcbiAgcXVhZDogJ2N1YmljLWJlemllcigwLjQ1NSwgIDAuMDMwLCAwLjUxNSwgMC45NTUpJyxcbiAgcXVhcnQ6ICdjdWJpYy1iZXppZXIoMC43NzAsICAwLjAwMCwgMC4xNzUsIDEuMDAwKScsXG4gIHF1aW50OiAnY3ViaWMtYmV6aWVyKDAuODYwLCAgMC4wMDAsIDAuMDcwLCAxLjAwMCknLFxuICBzaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDQ1LCAgMC4wNTAsIDAuNTUwLCAwLjk1MCknXG59O1xuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlSW5PdXQoJ3F1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke2Vhc2VJbk91dCgncXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC40NTUsICAwLjAzMCwgMC41MTUsIDAuOTU1KScsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZWFzZUluT3V0KGZ1bmN0aW9uTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb25zTWFwJDJbZnVuY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXTtcbn1cblxudmFyIGZ1bmN0aW9uc01hcCQxID0ge1xuICBiYWNrOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAgMC44ODUsIDAuMzIwLCAxLjI3NSknLFxuICBjdWJpYzogJ2N1YmljLWJlemllcigwLjIxNSwgIDAuNjEwLCAwLjM1NSwgMS4wMDApJyxcbiAgY2lyYzogJ2N1YmljLWJlemllcigwLjA3NSwgIDAuODIwLCAwLjE2NSwgMS4wMDApJyxcbiAgZXhwbzogJ2N1YmljLWJlemllcigwLjE5MCwgIDEuMDAwLCAwLjIyMCwgMS4wMDApJyxcbiAgcXVhZDogJ2N1YmljLWJlemllcigwLjI1MCwgIDAuNDYwLCAwLjQ1MCwgMC45NDApJyxcbiAgcXVhcnQ6ICdjdWJpYy1iZXppZXIoMC4xNjUsICAwLjg0MCwgMC40NDAsIDEuMDAwKScsXG4gIHF1aW50OiAnY3ViaWMtYmV6aWVyKDAuMjMwLCAgMS4wMDAsIDAuMzIwLCAxLjAwMCknLFxuICBzaW5lOiAnY3ViaWMtYmV6aWVyKDAuMzkwLCAgMC41NzUsIDAuNTY1LCAxLjAwMCknXG59O1xuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlT3V0KCdxdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHtlYXNlT3V0KCdxdWFkJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogJ2N1YmljLWJlemllcigwLjI1MCwgIDAuNDYwLCAwLjQ1MCwgMC45NDApJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBlYXNlT3V0KGZ1bmN0aW9uTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb25zTWFwJDFbZnVuY3Rpb25OYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgQ1NTIGNhbGMgZm9ybXVsYSBmb3IgbGluZWFyIGludGVycG9sYXRpb24gb2YgYSBwcm9wZXJ0eSBiZXR3ZWVuIHR3byB2YWx1ZXMuIEFjY2VwdHMgb3B0aW9uYWwgbWluU2NyZWVuIChkZWZhdWx0cyB0byAnMzIwcHgnKSBhbmQgbWF4U2NyZWVuIChkZWZhdWx0cyB0byAnMTIwMHB4JykuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgZm9udFNpemU6IGJldHdlZW4oJzIwcHgnLCAnMTAwcHgnLCAnNDAwcHgnLCAnMTAwMHB4JyksXG4gKiAgIGZvbnRTaXplOiBiZXR3ZWVuKCcyMHB4JywgJzEwMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgZm9udFNpemU6ICR7YmV0d2VlbignMjBweCcsICcxMDBweCcsICc0MDBweCcsICcxMDAwcHgnKX07XG4gKiAgIGZvbnRTaXplOiAke2JldHdlZW4oJzIwcHgnLCAnMTAwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogaDE6IHtcbiAqICAgJ2ZvbnRTaXplJzogJ2NhbGMoLTMzLjMzMzMzMzMzMzMzMzM0cHggKyAxMy4zMzMzMzMzMzMzMzMzMzR2dyknLFxuICogICAnZm9udFNpemUnOiAnY2FsYygtOS4wOTA5MDkwOTA5MDkwOTNweCArIDkuMDkwOTA5MDkwOTA5MDkydncpJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGJldHdlZW4oZnJvbVNpemUsIHRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pIHtcbiAgaWYgKG1pblNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluU2NyZWVuID0gJzMyMHB4JztcbiAgfVxuXG4gIGlmIChtYXhTY3JlZW4gPT09IHZvaWQgMCkge1xuICAgIG1heFNjcmVlbiA9ICcxMjAwcHgnO1xuICB9XG5cbiAgdmFyIF9nZXRWYWx1ZUFuZFVuaXQgPSBnZXRWYWx1ZUFuZFVuaXQoZnJvbVNpemUpLFxuICAgICAgdW5pdGxlc3NGcm9tU2l6ZSA9IF9nZXRWYWx1ZUFuZFVuaXRbMF0sXG4gICAgICBmcm9tU2l6ZVVuaXQgPSBfZ2V0VmFsdWVBbmRVbml0WzFdO1xuXG4gIHZhciBfZ2V0VmFsdWVBbmRVbml0MiA9IGdldFZhbHVlQW5kVW5pdCh0b1NpemUpLFxuICAgICAgdW5pdGxlc3NUb1NpemUgPSBfZ2V0VmFsdWVBbmRVbml0MlswXSxcbiAgICAgIHRvU2l6ZVVuaXQgPSBfZ2V0VmFsdWVBbmRVbml0MlsxXTtcblxuICB2YXIgX2dldFZhbHVlQW5kVW5pdDMgPSBnZXRWYWx1ZUFuZFVuaXQobWluU2NyZWVuKSxcbiAgICAgIHVuaXRsZXNzTWluU2NyZWVuID0gX2dldFZhbHVlQW5kVW5pdDNbMF0sXG4gICAgICBtaW5TY3JlZW5Vbml0ID0gX2dldFZhbHVlQW5kVW5pdDNbMV07XG5cbiAgdmFyIF9nZXRWYWx1ZUFuZFVuaXQ0ID0gZ2V0VmFsdWVBbmRVbml0KG1heFNjcmVlbiksXG4gICAgICB1bml0bGVzc01heFNjcmVlbiA9IF9nZXRWYWx1ZUFuZFVuaXQ0WzBdLFxuICAgICAgbWF4U2NyZWVuVW5pdCA9IF9nZXRWYWx1ZUFuZFVuaXQ0WzFdO1xuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NNaW5TY3JlZW4gIT09ICdudW1iZXInIHx8IHR5cGVvZiB1bml0bGVzc01heFNjcmVlbiAhPT0gJ251bWJlcicgfHwgIW1pblNjcmVlblVuaXQgfHwgIW1heFNjcmVlblVuaXQgfHwgbWluU2NyZWVuVW5pdCAhPT0gbWF4U2NyZWVuVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ3KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdW5pdGxlc3NGcm9tU2l6ZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHVuaXRsZXNzVG9TaXplICE9PSAnbnVtYmVyJyB8fCBmcm9tU2l6ZVVuaXQgIT09IHRvU2l6ZVVuaXQpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OCk7XG4gIH1cblxuICBpZiAoZnJvbVNpemVVbml0ICE9PSBtaW5TY3JlZW5Vbml0IHx8IHRvU2l6ZVVuaXQgIT09IG1heFNjcmVlblVuaXQpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3Nik7XG4gIH1cblxuICB2YXIgc2xvcGUgPSAodW5pdGxlc3NGcm9tU2l6ZSAtIHVuaXRsZXNzVG9TaXplKSAvICh1bml0bGVzc01pblNjcmVlbiAtIHVuaXRsZXNzTWF4U2NyZWVuKTtcbiAgdmFyIGJhc2UgPSB1bml0bGVzc1RvU2l6ZSAtIHNsb3BlICogdW5pdGxlc3NNYXhTY3JlZW47XG4gIHJldHVybiBcImNhbGMoXCIgKyBiYXNlLnRvRml4ZWQoMikgKyAoZnJvbVNpemVVbml0IHx8ICcnKSArIFwiICsgXCIgKyAoMTAwICogc2xvcGUpLnRvRml4ZWQoMikgKyBcInZ3KVwiO1xufVxuXG4vKipcbiAqIENTUyB0byBjb250YWluIGEgZmxvYXQgKGNyZWRpdCB0byBDU1NNb2pvKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAgLi4uY2xlYXJGaXgoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtjbGVhckZpeCgpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnJjo6YWZ0ZXInOiB7XG4gKiAgICdjbGVhcic6ICdib3RoJyxcbiAqICAgJ2NvbnRlbnQnOiAnXCJcIicsXG4gKiAgICdkaXNwbGF5JzogJ3RhYmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBjbGVhckZpeChwYXJlbnQpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50ID0gJyYnO1xuICB9XG5cbiAgdmFyIHBzZXVkb1NlbGVjdG9yID0gcGFyZW50ICsgXCI6OmFmdGVyXCI7XG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbcHNldWRvU2VsZWN0b3JdID0ge1xuICAgIGNsZWFyOiAnYm90aCcsXG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIGRpc3BsYXk6ICd0YWJsZSdcbiAgfSwgX3JlZjtcbn1cblxuLyoqXG4gKiBDU1MgdG8gZnVsbHkgY292ZXIgYW4gYXJlYS4gQ2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGFuIG9mZnNldCB0byBhY3QgYXMgYSBcInBhZGRpbmdcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5jb3ZlcigpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y292ZXIoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd0b3AnOiAnMCcsXG4gKiAgICdyaWdodDogJzAnLFxuICogICAnYm90dG9tJzogJzAnLFxuICogICAnbGVmdDogJzAnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvdmVyKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IG9mZnNldCxcbiAgICByaWdodDogb2Zmc2V0LFxuICAgIGJvdHRvbTogb2Zmc2V0LFxuICAgIGxlZnQ6IG9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJ1bmNhdGVkIHRleHQgd2l0aCBhbiBlbGxpcHNpcy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYSBtYXgtd2lkdGggYW5kIG51bWJlciBvZiBsaW5lcyBiZWZvcmUgdHJ1bmNhdGluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5lbGxpcHNpcygnMjUwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2VsbGlwc2lzKCcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAqICAgJ21heFdpZHRoJzogJzI1MHB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd0ZXh0T3ZlcmZsb3cnOiAnZWxsaXBzaXMnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd29yZFdyYXAnOiAnbm9ybWFsJ1xuICogfVxuICovXG5mdW5jdGlvbiBlbGxpcHNpcyh3aWR0aCwgbGluZXMpIHtcbiAgaWYgKGxpbmVzID09PSB2b2lkIDApIHtcbiAgICBsaW5lcyA9IDE7XG4gIH1cblxuICB2YXIgc3R5bGVzID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIG1heFdpZHRoOiB3aWR0aCB8fCAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB3b3JkV3JhcDogJ25vcm1hbCdcbiAgfTtcbiAgcmV0dXJuIGxpbmVzID4gMSA/IF9leHRlbmRzKHt9LCBzdHlsZXMsIHtcbiAgICBXZWJraXRCb3hPcmllbnQ6ICd2ZXJ0aWNhbCcsXG4gICAgV2Via2l0TGluZUNsYW1wOiBsaW5lcyxcbiAgICBkaXNwbGF5OiAnLXdlYmtpdC1ib3gnLFxuICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gIH0pIDogc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IG9mIG1lZGlhIHF1ZXJpZXMgdGhhdCByZXNpemVzIGEgcHJvcGVydHkgKG9yIHNldCBvZiBwcm9wZXJ0aWVzKSBiZXR3ZWVuIGEgcHJvdmlkZWQgZnJvbVNpemUgYW5kIHRvU2l6ZS4gQWNjZXB0cyBvcHRpb25hbCBtaW5TY3JlZW4gKGRlZmF1bHRzIHRvICczMjBweCcpIGFuZCBtYXhTY3JlZW4gKGRlZmF1bHRzIHRvICcxMjAwcHgnKSB0byBjb25zdHJhaW4gdGhlIGludGVycG9sYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZmx1aWRSYW5nZShcbiAqICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2ZsdWlkUmFuZ2UoXG4gKiAgICAgIHtcbiAqICAgICAgICBwcm9wOiAncGFkZGluZycsXG4gKiAgICAgICAgZnJvbVNpemU6ICcyMHB4JyxcbiAqICAgICAgICB0b1NpemU6ICcxMDBweCcsXG4gKiAgICAgIH0sXG4gKiAgICAgICc0MDBweCcsXG4gKiAgICAgICcxMDAwcHgnLFxuICogICAgKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgIFwiQG1lZGlhIChtaW4td2lkdGg6IDEwMDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCIxMDBweFwiLFxuICogICB9LFxuICogICBcIkBtZWRpYSAobWluLXdpZHRoOiA0MDBweClcIjogT2JqZWN0IHtcbiAqICAgICBcInBhZGRpbmdcIjogXCJjYWxjKC0zMy4zMzMzMzMzMzMzMzMzNHB4ICsgMTMuMzMzMzMzMzMzMzMzMzM0dncpXCIsXG4gKiAgIH0sXG4gKiAgIFwicGFkZGluZ1wiOiBcIjIwcHhcIixcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZmx1aWRSYW5nZShjc3NQcm9wLCBtaW5TY3JlZW4sIG1heFNjcmVlbikge1xuICBpZiAobWluU2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtaW5TY3JlZW4gPSAnMzIwcHgnO1xuICB9XG5cbiAgaWYgKG1heFNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWF4U2NyZWVuID0gJzEyMDBweCc7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3NzUHJvcCkgJiYgdHlwZW9mIGNzc1Byb3AgIT09ICdvYmplY3QnIHx8IGNzc1Byb3AgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjc3NQcm9wKSkge1xuICAgIHZhciBtZWRpYVF1ZXJpZXMgPSB7fTtcbiAgICB2YXIgZmFsbGJhY2tzID0ge307XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGNzc1Byb3ApLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9leHRlbmRzMiwgX2V4dGVuZHMzO1xuXG4gICAgICB2YXIgb2JqID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghb2JqLnByb3AgfHwgIW9iai5mcm9tU2l6ZSB8fCAhb2JqLnRvU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1MCk7XG4gICAgICB9XG5cbiAgICAgIGZhbGxiYWNrc1tvYmoucHJvcF0gPSBvYmouZnJvbVNpemU7XG4gICAgICBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0gPSBfZXh0ZW5kcyh7fSwgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltvYmoucHJvcF0gPSBiZXR3ZWVuKG9iai5mcm9tU2l6ZSwgb2JqLnRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pLCBfZXh0ZW5kczIpKTtcbiAgICAgIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSA9IF9leHRlbmRzKHt9LCBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0sIChfZXh0ZW5kczMgPSB7fSwgX2V4dGVuZHMzW29iai5wcm9wXSA9IG9iai50b1NpemUsIF9leHRlbmRzMykpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZmFsbGJhY2tzLCBtZWRpYVF1ZXJpZXMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmVmLCBfcmVmMiwgX3JlZjM7XG5cbiAgICBpZiAoIWNzc1Byb3AucHJvcCB8fCAhY3NzUHJvcC5mcm9tU2l6ZSB8fCAhY3NzUHJvcC50b1NpemUpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JlZjMgPSB7fSwgX3JlZjNbY3NzUHJvcC5wcm9wXSA9IGNzc1Byb3AuZnJvbVNpemUsIF9yZWYzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWluU2NyZWVuICsgXCIpXCJdID0gKF9yZWYgPSB7fSwgX3JlZltjc3NQcm9wLnByb3BdID0gYmV0d2Vlbihjc3NQcm9wLmZyb21TaXplLCBjc3NQcm9wLnRvU2l6ZSwgbWluU2NyZWVuLCBtYXhTY3JlZW4pLCBfcmVmKSwgX3JlZjNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtYXhTY3JlZW4gKyBcIilcIl0gPSAoX3JlZjIgPSB7fSwgX3JlZjJbY3NzUHJvcC5wcm9wXSA9IGNzc1Byb3AudG9TaXplLCBfcmVmMiksIF9yZWYzO1xuICB9XG59XG5cbnZhciBkYXRhVVJJUmVnZXggPSAvXlxccypkYXRhOihbYS16XStcXC9bYS16LV0rKDtbYS16LV0rPVthLXotXSspPyk/KDtjaGFyc2V0PVthLXowLTktXSspPyg7YmFzZTY0KT8sW2EtejAtOSEkJicsKCkqKyw7PVxcLS5ffjpALz8lXFxzXSpcXHMqJC9pO1xudmFyIGZvcm1hdEhpbnRNYXAgPSB7XG4gIHdvZmY6ICd3b2ZmJyxcbiAgd29mZjI6ICd3b2ZmMicsXG4gIHR0ZjogJ3RydWV0eXBlJyxcbiAgb3RmOiAnb3BlbnR5cGUnLFxuICBlb3Q6ICdlbWJlZGRlZC1vcGVudHlwZScsXG4gIHN2ZzogJ3N2ZycsXG4gIHN2Z3o6ICdzdmcnXG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUZvcm1hdEhpbnQoZm9ybWF0LCBmb3JtYXRIaW50KSB7XG4gIGlmICghZm9ybWF0SGludCkgcmV0dXJuICcnO1xuICByZXR1cm4gXCIgZm9ybWF0KFxcXCJcIiArIGZvcm1hdEhpbnRNYXBbZm9ybWF0XSArIFwiXFxcIilcIjtcbn1cblxuZnVuY3Rpb24gaXNEYXRhVVJJKGZvbnRGaWxlUGF0aCkge1xuICByZXR1cm4gISFmb250RmlsZVBhdGgucmVwbGFjZSgvXFxzKy9nLCAnICcpLm1hdGNoKGRhdGFVUklSZWdleCk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRmlsZVJlZmVyZW5jZXMoZm9udEZpbGVQYXRoLCBmaWxlRm9ybWF0cywgZm9ybWF0SGludCkge1xuICBpZiAoaXNEYXRhVVJJKGZvbnRGaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gXCJ1cmwoXFxcIlwiICsgZm9udEZpbGVQYXRoICsgXCJcXFwiKVwiICsgZ2VuZXJhdGVGb3JtYXRIaW50KGZpbGVGb3JtYXRzWzBdLCBmb3JtYXRIaW50KTtcbiAgfVxuXG4gIHZhciBmaWxlRm9udFJlZmVyZW5jZXMgPSBmaWxlRm9ybWF0cy5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBcInVybChcXFwiXCIgKyBmb250RmlsZVBhdGggKyBcIi5cIiArIGZvcm1hdCArIFwiXFxcIilcIiArIGdlbmVyYXRlRm9ybWF0SGludChmb3JtYXQsIGZvcm1hdEhpbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZpbGVGb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyhsb2NhbEZvbnRzKSB7XG4gIHZhciBsb2NhbEZvbnRSZWZlcmVuY2VzID0gbG9jYWxGb250cy5tYXAoZnVuY3Rpb24gKGZvbnQpIHtcbiAgICByZXR1cm4gXCJsb2NhbChcXFwiXCIgKyBmb250ICsgXCJcXFwiKVwiO1xuICB9KTtcbiAgcmV0dXJuIGxvY2FsRm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2VzKGZvbnRGaWxlUGF0aCwgbG9jYWxGb250cywgZmlsZUZvcm1hdHMsIGZvcm1hdEhpbnQpIHtcbiAgdmFyIGZvbnRSZWZlcmVuY2VzID0gW107XG4gIGlmIChsb2NhbEZvbnRzKSBmb250UmVmZXJlbmNlcy5wdXNoKGdlbmVyYXRlTG9jYWxSZWZlcmVuY2VzKGxvY2FsRm9udHMpKTtcblxuICBpZiAoZm9udEZpbGVQYXRoKSB7XG4gICAgZm9udFJlZmVyZW5jZXMucHVzaChnZW5lcmF0ZUZpbGVSZWZlcmVuY2VzKGZvbnRGaWxlUGF0aCwgZmlsZUZvcm1hdHMsIGZvcm1hdEhpbnQpKTtcbiAgfVxuXG4gIHJldHVybiBmb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuLyoqXG4gKiBDU1MgZm9yIGEgQGZvbnQtZmFjZSBkZWNsYXJhdGlvbi4gRGVmYXVsdHMgdG8gY2hlY2sgZm9yIGxvY2FsIGNvcGllcyBvZiB0aGUgZm9udCBvbiB0aGUgdXNlcidzIG1hY2hpbmUuIFlvdSBjYW4gZGlzYWJsZSB0aGlzIGJ5IHBhc3NpbmcgYG51bGxgIHRvIGxvY2FsRm9udHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmZvbnRGYWNlKHtcbiAqICAgICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtcbiAqICAgZm9udEZhY2Uoe1xuICogICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJyxcbiAqICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgfVxuICogKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdAZm9udC1mYWNlJzoge1xuICogICAnZm9udEZhbWlseSc6ICdTYW5zLVBybycsXG4gKiAgICdzcmMnOiAndXJsKFwicGF0aC90by9maWxlLmVvdFwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmYyXCIpLCB1cmwoXCJwYXRoL3RvL2ZpbGUud29mZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnR0ZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnN2Z1wiKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBmb250RmFjZShfcmVmKSB7XG4gIHZhciBmb250RmFtaWx5ID0gX3JlZi5mb250RmFtaWx5LFxuICAgICAgZm9udEZpbGVQYXRoID0gX3JlZi5mb250RmlsZVBhdGgsXG4gICAgICBmb250U3RyZXRjaCA9IF9yZWYuZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGUgPSBfcmVmLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50ID0gX3JlZi5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQgPSBfcmVmLmZvbnRXZWlnaHQsXG4gICAgICBfcmVmJGZpbGVGb3JtYXRzID0gX3JlZi5maWxlRm9ybWF0cyxcbiAgICAgIGZpbGVGb3JtYXRzID0gX3JlZiRmaWxlRm9ybWF0cyA9PT0gdm9pZCAwID8gWydlb3QnLCAnd29mZjInLCAnd29mZicsICd0dGYnLCAnc3ZnJ10gOiBfcmVmJGZpbGVGb3JtYXRzLFxuICAgICAgX3JlZiRmb3JtYXRIaW50ID0gX3JlZi5mb3JtYXRIaW50LFxuICAgICAgZm9ybWF0SGludCA9IF9yZWYkZm9ybWF0SGludCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGZvcm1hdEhpbnQsXG4gICAgICBfcmVmJGxvY2FsRm9udHMgPSBfcmVmLmxvY2FsRm9udHMsXG4gICAgICBsb2NhbEZvbnRzID0gX3JlZiRsb2NhbEZvbnRzID09PSB2b2lkIDAgPyBbZm9udEZhbWlseV0gOiBfcmVmJGxvY2FsRm9udHMsXG4gICAgICB1bmljb2RlUmFuZ2UgPSBfcmVmLnVuaWNvZGVSYW5nZSxcbiAgICAgIGZvbnREaXNwbGF5ID0gX3JlZi5mb250RGlzcGxheSxcbiAgICAgIGZvbnRWYXJpYXRpb25TZXR0aW5ncyA9IF9yZWYuZm9udFZhcmlhdGlvblNldHRpbmdzLFxuICAgICAgZm9udEZlYXR1cmVTZXR0aW5ncyA9IF9yZWYuZm9udEZlYXR1cmVTZXR0aW5ncztcbiAgLy8gRXJyb3IgSGFuZGxpbmdcbiAgaWYgKCFmb250RmFtaWx5KSB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1NSk7XG5cbiAgaWYgKCFmb250RmlsZVBhdGggJiYgIWxvY2FsRm9udHMpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Mik7XG4gIH1cblxuICBpZiAobG9jYWxGb250cyAmJiAhQXJyYXkuaXNBcnJheShsb2NhbEZvbnRzKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShmaWxlRm9ybWF0cykpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1NCk7XG4gIH1cblxuICB2YXIgZm9udEZhY2VEZWNsYXJhdGlvbiA9IHtcbiAgICAnQGZvbnQtZmFjZSc6IHtcbiAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICBzcmM6IGdlbmVyYXRlU291cmNlcyhmb250RmlsZVBhdGgsIGxvY2FsRm9udHMsIGZpbGVGb3JtYXRzLCBmb3JtYXRIaW50KSxcbiAgICAgIHVuaWNvZGVSYW5nZTogdW5pY29kZVJhbmdlLFxuICAgICAgZm9udFN0cmV0Y2g6IGZvbnRTdHJldGNoLFxuICAgICAgZm9udFN0eWxlOiBmb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogZm9udFZhcmlhbnQsXG4gICAgICBmb250V2VpZ2h0OiBmb250V2VpZ2h0LFxuICAgICAgZm9udERpc3BsYXk6IGZvbnREaXNwbGF5LFxuICAgICAgZm9udFZhcmlhdGlvblNldHRpbmdzOiBmb250VmFyaWF0aW9uU2V0dGluZ3MsXG4gICAgICBmb250RmVhdHVyZVNldHRpbmdzOiBmb250RmVhdHVyZVNldHRpbmdzXG4gICAgfVxuICB9OyAvLyBSZW1vdmVzIHVuZGVmaW5lZCBmaWVsZHMgZm9yIGNsZWFuZXIgY3NzIG9iamVjdC5cblxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmb250RmFjZURlY2xhcmF0aW9uKSk7XG59XG5cbi8qKlxuICogQ1NTIHRvIGhpZGUgdGV4dCB0byBzaG93IGEgYmFja2dyb3VuZCBpbWFnZSBpbiBhIFNFTy1mcmllbmRseSB3YXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICd1cmwobG9nby5wbmcpJyxcbiAqICAgLi4uaGlkZVRleHQoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZEltYWdlOiB1cmwobG9nby5wbmcpO1xuICogICAke2hpZGVUZXh0KCl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChsb2dvLnBuZyknLFxuICogICAndGV4dEluZGVudCc6ICcxMDElJyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd3aGl0ZVNwYWNlJzogJ25vd3JhcCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpZGVUZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHRleHRJbmRlbnQ6ICcxMDElJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gaGlkZSBjb250ZW50IHZpc3VhbGx5IGJ1dCByZW1haW4gYWNjZXNzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cbiAqIGZyb20gW0hUTUw1IEJvaWxlcnBsYXRlXShodHRwczovL2dpdGh1Yi5jb20vaDVicC9odG1sNS1ib2lsZXJwbGF0ZS9ibG9iLzlhMTc2ZjU3YWYxY2ZlOGVjNzAzMDBkYTQ2MjFmYjliMDdlNWZhMzEvc3JjL2Nzcy9tYWluLmNzcyNMMTIxKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmhpZGVWaXN1YWxseSgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2hpZGVWaXN1YWxseSgpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ2JvcmRlcic6ICcwJyxcbiAqICAgJ2NsaXAnOiAncmVjdCgwIDAgMCAwKScsXG4gKiAgICdoZWlnaHQnOiAnMXB4JyxcbiAqICAgJ21hcmdpbic6ICctMXB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICdwYWRkaW5nJzogJzAnLFxuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd2lkdGgnOiAnMXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlkZVZpc3VhbGx5KCkge1xuICByZXR1cm4ge1xuICAgIGJvcmRlcjogJzAnLFxuICAgIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgICBoZWlnaHQ6ICcxcHgnLFxuICAgIG1hcmdpbjogJy0xcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd2lkdGg6ICcxcHgnXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0IEhpRFBJIGRldmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICBbaGlEUEkoMS41KV06IHtcbiAqICAgIHdpZHRoOiAyMDBweDtcbiAqICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlEUEkoMS41KX0ge1xuICogICAgIHdpZHRoOiAyMDBweDtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS41LzEpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICd3aWR0aCc6ICcyMDBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhpRFBJKHJhdGlvKSB7XG4gIGlmIChyYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgcmF0aW8gPSAxLjM7XG4gIH1cblxuICByZXR1cm4gXCJcXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiKSxcXG4gICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIvMSksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IFwiICsgTWF0aC5yb3VuZChyYXRpbyAqIDk2KSArIFwiZHBpKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogXCIgKyByYXRpbyArIFwiZHBweClcXG4gIFwiO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKGxpdGVyYWxzKSB7XG4gIHZhciB0ZW1wbGF0ZSA9ICcnO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdWJzdGl0dXRpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdWJzdGl0dXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGl0ZXJhbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0ZW1wbGF0ZSArPSBsaXRlcmFsc1tpXTtcblxuICAgIGlmIChpID09PSBzdWJzdGl0dXRpb25zLmxlbmd0aCAtIDEgJiYgc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgdmFyIGRlZmluZWRWYWx1ZXMgPSBzdWJzdGl0dXRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3Vic3RpdHV0ZSkge1xuICAgICAgICByZXR1cm4gISFzdWJzdGl0dXRlO1xuICAgICAgfSk7IC8vIEFkZHMgbGVhZGluZyBjb21hIGlmIHByb3BlcnRpZXMgcHJlY2VlZCBjb2xvci1zdG9wc1xuXG4gICAgICBpZiAoZGVmaW5lZFZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgLTEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIiwgXCIgKyBzdWJzdGl0dXRpb25zW2ldOyAvLyBObyB0cmFpbGluZyBzcGFjZSBpZiBjb2xvci1zdG9wcyBpcyB0aGUgb25seSBwYXJhbSBwcm92aWRlZFxuICAgICAgfSBlbHNlIGlmIChkZWZpbmVkVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBcIlwiICsgc3Vic3RpdHV0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1YnN0aXR1dGlvbnNbaV0pIHtcbiAgICAgIHRlbXBsYXRlICs9IHN1YnN0aXR1dGlvbnNbaV0gKyBcIiBcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGUudHJpbSgpO1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0JDE7XG5cbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSBsaW5lYXIgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ubGluZWFyR3JhZGllbnQoe1xuICAgICAgICBjb2xvclN0b3BzOiBbJyMwMEZGRkYgMCUnLCAncmdiYSgwLCAwLCAyNTUsIDApIDUwJScsICcjMDAwMEZGIDk1JSddLFxuICAgICAgICB0b0RpcmVjdGlvbjogJ3RvIHRvcCByaWdodCcsXG4gICAgICAgIGZhbGxiYWNrOiAnI0ZGRicsXG4gICAgICB9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2xpbmVhckdyYWRpZW50KHtcbiAgICAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAgICAgICAgdG9EaXJlY3Rpb246ICd0byB0b3AgcmlnaHQnLFxuICAgICAgICBmYWxsYmFjazogJyNGRkYnLFxuICAgICAgfSl9XG4gKmBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdiYWNrZ3JvdW5kQ29sb3InOiAnI0ZGRicsXG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAnbGluZWFyLWdyYWRpZW50KHRvIHRvcCByaWdodCwgIzAwRkZGRiAwJSwgcmdiYSgwLCAwLCAyNTUsIDApIDUwJSwgIzAwMDBGRiA5NSUpJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoX3JlZikge1xuICB2YXIgY29sb3JTdG9wcyA9IF9yZWYuY29sb3JTdG9wcyxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIF9yZWYkdG9EaXJlY3Rpb24gPSBfcmVmLnRvRGlyZWN0aW9uLFxuICAgICAgdG9EaXJlY3Rpb24gPSBfcmVmJHRvRGlyZWN0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkdG9EaXJlY3Rpb247XG5cbiAgaWYgKCFjb2xvclN0b3BzIHx8IGNvbG9yU3RvcHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU2KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnJlcGxhY2UoLyxcXHMrL2csICcsJykuc3BsaXQoJyAnKVswXS5yZXBsYWNlKC8sKD89XFxTKS9nLCAnLCAnKSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGNvbnN0cnVjdEdyYWRpZW50VmFsdWUoX3RlbXBsYXRlT2JqZWN0JDEgfHwgKF90ZW1wbGF0ZU9iamVjdCQxID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcImxpbmVhci1ncmFkaWVudChcIiwgXCJcIiwgXCIpXCJdKSksIHRvRGlyZWN0aW9uLCBjb2xvclN0b3BzLmpvaW4oJywgJykucmVwbGFjZSgvLCg/PVxcUykvZywgJywgJykpXG4gIH07XG59XG5cbi8qKlxuICogQ1NTIHRvIG5vcm1hbGl6ZSBhYm5vcm1hbGl0aWVzIGFjcm9zcyBicm93c2VycyAobm9ybWFsaXplLmNzcyB2OC4wLjEgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5ub3JtYWxpemUoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgR2xvYmFsU3R5bGUgPSBjcmVhdGVHbG9iYWxTdHlsZWAke25vcm1hbGl6ZSgpfWBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogaHRtbCB7XG4gKiAgIGxpbmVIZWlnaHQ6IDEuMTUsXG4gKiAgIHRleHRTaXplQWRqdXN0OiAxMDAlLFxuICogfSAuLi5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB2YXIgX3JlZjtcblxuICByZXR1cm4gWyhfcmVmID0ge1xuICAgIGh0bWw6IHtcbiAgICAgIGxpbmVIZWlnaHQ6ICcxLjE1JyxcbiAgICAgIHRleHRTaXplQWRqdXN0OiAnMTAwJSdcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBtYWluOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfSxcbiAgICBoMToge1xuICAgICAgZm9udFNpemU6ICcyZW0nLFxuICAgICAgbWFyZ2luOiAnMC42N2VtIDAnXG4gICAgfSxcbiAgICBocjoge1xuICAgICAgYm94U2l6aW5nOiAnY29udGVudC1ib3gnLFxuICAgICAgaGVpZ2h0OiAnMCcsXG4gICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgfSxcbiAgICBwcmU6IHtcbiAgICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UsIG1vbm9zcGFjZScsXG4gICAgICBmb250U2l6ZTogJzFlbSdcbiAgICB9LFxuICAgIGE6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgJ2FiYnJbdGl0bGVdJzoge1xuICAgICAgYm9yZGVyQm90dG9tOiAnbm9uZScsXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSdcbiAgICB9XG4gIH0sIF9yZWZbXCJiLFxcbiAgICBzdHJvbmdcIl0gPSB7XG4gICAgZm9udFdlaWdodDogJ2JvbGRlcidcbiAgfSwgX3JlZltcImNvZGUsXFxuICAgIGtiZCxcXG4gICAgc2FtcFwiXSA9IHtcbiAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlLCBtb25vc3BhY2UnLFxuICAgIGZvbnRTaXplOiAnMWVtJ1xuICB9LCBfcmVmLnNtYWxsID0ge1xuICAgIGZvbnRTaXplOiAnODAlJ1xuICB9LCBfcmVmW1wic3ViLFxcbiAgICBzdXBcIl0gPSB7XG4gICAgZm9udFNpemU6ICc3NSUnLFxuICAgIGxpbmVIZWlnaHQ6ICcwJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAnYmFzZWxpbmUnXG4gIH0sIF9yZWYuc3ViID0ge1xuICAgIGJvdHRvbTogJy0wLjI1ZW0nXG4gIH0sIF9yZWYuc3VwID0ge1xuICAgIHRvcDogJy0wLjVlbSdcbiAgfSwgX3JlZi5pbWcgPSB7XG4gICAgYm9yZGVyU3R5bGU6ICdub25lJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBpbnB1dCxcXG4gICAgb3B0Z3JvdXAsXFxuICAgIHNlbGVjdCxcXG4gICAgdGV4dGFyZWFcIl0gPSB7XG4gICAgZm9udEZhbWlseTogJ2luaGVyaXQnLFxuICAgIGZvbnRTaXplOiAnMTAwJScsXG4gICAgbGluZUhlaWdodDogJzEuMTUnLFxuICAgIG1hcmdpbjogJzAnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIGlucHV0XCJdID0ge1xuICAgIG92ZXJmbG93OiAndmlzaWJsZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgc2VsZWN0XCJdID0ge1xuICAgIHRleHRUcmFuc2Zvcm06ICdub25lJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBodG1sIFt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG4gICAgW3R5cGU9XFxcInJlc2V0XFxcIl0sXFxuICAgIFt0eXBlPVxcXCJzdWJtaXRcXFwiXVwiXSA9IHtcbiAgICBXZWJraXRBcHBlYXJhbmNlOiAnYnV0dG9uJ1xuICB9LCBfcmVmW1wiYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICBbdHlwZT1cXFwiYnV0dG9uXFxcIl06Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgIFt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICBbdHlwZT1cXFwic3VibWl0XFxcIl06Oi1tb3otZm9jdXMtaW5uZXJcIl0gPSB7XG4gICAgYm9yZGVyU3R5bGU6ICdub25lJyxcbiAgICBwYWRkaW5nOiAnMCdcbiAgfSwgX3JlZltcImJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG4gICAgW3R5cGU9XFxcImJ1dHRvblxcXCJdOi1tb3otZm9jdXNyaW5nLFxcbiAgICBbdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG4gICAgW3R5cGU9XFxcInN1Ym1pdFxcXCJdOi1tb3otZm9jdXNyaW5nXCJdID0ge1xuICAgIG91dGxpbmU6ICcxcHggZG90dGVkIEJ1dHRvblRleHQnXG4gIH0sIF9yZWYuZmllbGRzZXQgPSB7XG4gICAgcGFkZGluZzogJzAuMzVlbSAwLjYyNWVtIDAuNzVlbSdcbiAgfSwgX3JlZi5sZWdlbmQgPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICBkaXNwbGF5OiAndGFibGUnLFxuICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgcGFkZGluZzogJzAnLFxuICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gIH0sIF9yZWYucHJvZ3Jlc3MgPSB7XG4gICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xuICB9LCBfcmVmLnRleHRhcmVhID0ge1xuICAgIG92ZXJmbG93OiAnYXV0bydcbiAgfSwgX3JlZltcIlt0eXBlPVxcXCJjaGVja2JveFxcXCJdLFxcbiAgICBbdHlwZT1cXFwicmFkaW9cXFwiXVwiXSA9IHtcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBwYWRkaW5nOiAnMCdcbiAgfSwgX3JlZltcIlt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uXCJdID0ge1xuICAgIGhlaWdodDogJ2F1dG8nXG4gIH0sIF9yZWZbJ1t0eXBlPVwic2VhcmNoXCJdJ10gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ3RleHRmaWVsZCcsXG4gICAgb3V0bGluZU9mZnNldDogJy0ycHgnXG4gIH0sIF9yZWZbJ1t0eXBlPVwic2VhcmNoXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uJ10gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ25vbmUnXG4gIH0sIF9yZWZbJzo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24nXSA9IHtcbiAgICBXZWJraXRBcHBlYXJhbmNlOiAnYnV0dG9uJyxcbiAgICBmb250OiAnaW5oZXJpdCdcbiAgfSwgX3JlZi5kZXRhaWxzID0ge1xuICAgIGRpc3BsYXk6ICdibG9jaydcbiAgfSwgX3JlZi5zdW1tYXJ5ID0ge1xuICAgIGRpc3BsYXk6ICdsaXN0LWl0ZW0nXG4gIH0sIF9yZWYudGVtcGxhdGUgPSB7XG4gICAgZGlzcGxheTogJ25vbmUnXG4gIH0sIF9yZWZbJ1toaWRkZW5dJ10gPSB7XG4gICAgZGlzcGxheTogJ25vbmUnXG4gIH0sIF9yZWYpLCB7XG4gICAgJ2FiYnJbdGl0bGVdJzoge1xuICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUgZG90dGVkJ1xuICAgIH1cbiAgfV07XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3Q7XG5cbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSByYWRpYWwgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pfVxuICpgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAnYmFja2dyb3VuZENvbG9yJzogJyMwMEZGRkYnLFxuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3JhZGlhbC1ncmFkaWVudChjZW50ZXIgZWxsaXBzZSBmYXJ0aGVzdC1jb3JuZXIgYXQgNDVweCA0NXB4LCAjMDBGRkZGIDAlLCByZ2JhKDAsIDAsIDI1NSwgMCkgNTAlLCAjMDAwMEZGIDk1JSknLFxuICogfVxuICovXG5mdW5jdGlvbiByYWRpYWxHcmFkaWVudChfcmVmKSB7XG4gIHZhciBjb2xvclN0b3BzID0gX3JlZi5jb2xvclN0b3BzLFxuICAgICAgX3JlZiRleHRlbnQgPSBfcmVmLmV4dGVudCxcbiAgICAgIGV4dGVudCA9IF9yZWYkZXh0ZW50ID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkZXh0ZW50LFxuICAgICAgZmFsbGJhY2sgPSBfcmVmLmZhbGxiYWNrLFxuICAgICAgX3JlZiRwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiA9IF9yZWYkcG9zaXRpb24gPT09IHZvaWQgMCA/ICcnIDogX3JlZiRwb3NpdGlvbixcbiAgICAgIF9yZWYkc2hhcGUgPSBfcmVmLnNoYXBlLFxuICAgICAgc2hhcGUgPSBfcmVmJHNoYXBlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkc2hhcGU7XG5cbiAgaWYgKCFjb2xvclN0b3BzIHx8IGNvbG9yU3RvcHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU3KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnNwbGl0KCcgJylbMF0sXG4gICAgYmFja2dyb3VuZEltYWdlOiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKF90ZW1wbGF0ZU9iamVjdCB8fCAoX3RlbXBsYXRlT2JqZWN0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcInJhZGlhbC1ncmFkaWVudChcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCIpXCJdKSksIHBvc2l0aW9uLCBzaGFwZSwgZXh0ZW50LCBjb2xvclN0b3BzLmpvaW4oJywgJykpXG4gIH07XG59XG5cbi8qKlxuICogQSBoZWxwZXIgdG8gZ2VuZXJhdGUgYSByZXRpbmEgYmFja2dyb3VuZCBpbWFnZSBhbmQgbm9uLXJldGluYVxuICogYmFja2dyb3VuZCBpbWFnZS4gVGhlIHJldGluYSBiYWNrZ3JvdW5kIGltYWdlIHdpbGwgb3V0cHV0IHRvIGEgSGlEUEkgbWVkaWEgcXVlcnkuIFRoZSBtaXhpbiB1c2VzXG4gKiBhIF8yeC5wbmcgZmlsZW5hbWUgc3VmZml4IGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAuLi5yZXRpbmFJbWFnZSgnbXktaW1nJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtyZXRpbmFJbWFnZSgnbXktaW1nJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICogZGl2IHtcbiAqICAgYmFja2dyb3VuZEltYWdlOiAndXJsKG15LWltZy5wbmcpJyxcbiAqICAgJ0BtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMpLFxuICogICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMvMSksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxNDRkcGkpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKG15LWltZ18yeC5wbmcpJyxcbiAqICAgfVxuICogfVxuICovXG5mdW5jdGlvbiByZXRpbmFJbWFnZShmaWxlbmFtZSwgYmFja2dyb3VuZFNpemUsIGV4dGVuc2lvbiwgcmV0aW5hRmlsZW5hbWUsIHJldGluYVN1ZmZpeCkge1xuICB2YXIgX3JlZjtcblxuICBpZiAoZXh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICBleHRlbnNpb24gPSAncG5nJztcbiAgfVxuXG4gIGlmIChyZXRpbmFTdWZmaXggPT09IHZvaWQgMCkge1xuICAgIHJldGluYVN1ZmZpeCA9ICdfMngnO1xuICB9XG5cbiAgaWYgKCFmaWxlbmFtZSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU4KTtcbiAgfSAvLyBSZXBsYWNlIHRoZSBkb3QgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGFzc2VkIGV4dGVuc2lvbiBpZiBvbmUgZXhpc3RzXG5cblxuICB2YXIgZXh0ID0gZXh0ZW5zaW9uLnJlcGxhY2UoL15cXC4vLCAnJyk7XG4gIHZhciByRmlsZW5hbWUgPSByZXRpbmFGaWxlbmFtZSA/IHJldGluYUZpbGVuYW1lICsgXCIuXCIgKyBleHQgOiBcIlwiICsgZmlsZW5hbWUgKyByZXRpbmFTdWZmaXggKyBcIi5cIiArIGV4dDtcbiAgcmV0dXJuIF9yZWYgPSB7XG4gICAgYmFja2dyb3VuZEltYWdlOiBcInVybChcIiArIGZpbGVuYW1lICsgXCIuXCIgKyBleHQgKyBcIilcIlxuICB9LCBfcmVmW2hpRFBJKCldID0gX2V4dGVuZHMoe1xuICAgIGJhY2tncm91bmRJbWFnZTogXCJ1cmwoXCIgKyByRmlsZW5hbWUgKyBcIilcIlxuICB9LCBiYWNrZ3JvdW5kU2l6ZSA/IHtcbiAgICBiYWNrZ3JvdW5kU2l6ZTogYmFja2dyb3VuZFNpemVcbiAgfSA6IHt9KSwgX3JlZjtcbn1cblxuLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbnZhciBmdW5jdGlvbnNNYXAgPSB7XG4gIGVhc2VJbkJhY2s6ICdjdWJpYy1iZXppZXIoMC42MDAsIC0wLjI4MCwgMC43MzUsIDAuMDQ1KScsXG4gIGVhc2VJbkNpcmM6ICdjdWJpYy1iZXppZXIoMC42MDAsICAwLjA0MCwgMC45ODAsIDAuMzM1KScsXG4gIGVhc2VJbkN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wNTUsIDAuNjc1LCAwLjE5MCknLFxuICBlYXNlSW5FeHBvOiAnY3ViaWMtYmV6aWVyKDAuOTUwLCAgMC4wNTAsIDAuNzk1LCAwLjAzNSknLFxuICBlYXNlSW5RdWFkOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wODUsIDAuNjgwLCAwLjUzMCknLFxuICBlYXNlSW5RdWFydDogJ2N1YmljLWJlemllcigwLjg5NSwgIDAuMDMwLCAwLjY4NSwgMC4yMjApJyxcbiAgZWFzZUluUXVpbnQ6ICdjdWJpYy1iZXppZXIoMC43NTUsICAwLjA1MCwgMC44NTUsIDAuMDYwKScsXG4gIGVhc2VJblNpbmU6ICdjdWJpYy1iZXppZXIoMC40NzAsICAwLjAwMCwgMC43NDUsIDAuNzE1KScsXG4gIGVhc2VPdXRCYWNrOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAgMC44ODUsIDAuMzIwLCAxLjI3NSknLFxuICBlYXNlT3V0Q3ViaWM6ICdjdWJpYy1iZXppZXIoMC4yMTUsICAwLjYxMCwgMC4zNTUsIDEuMDAwKScsXG4gIGVhc2VPdXRDaXJjOiAnY3ViaWMtYmV6aWVyKDAuMDc1LCAgMC44MjAsIDAuMTY1LCAxLjAwMCknLFxuICBlYXNlT3V0RXhwbzogJ2N1YmljLWJlemllcigwLjE5MCwgIDEuMDAwLCAwLjIyMCwgMS4wMDApJyxcbiAgZWFzZU91dFF1YWQ6ICdjdWJpYy1iZXppZXIoMC4yNTAsICAwLjQ2MCwgMC40NTAsIDAuOTQwKScsXG4gIGVhc2VPdXRRdWFydDogJ2N1YmljLWJlemllcigwLjE2NSwgIDAuODQwLCAwLjQ0MCwgMS4wMDApJyxcbiAgZWFzZU91dFF1aW50OiAnY3ViaWMtYmV6aWVyKDAuMjMwLCAgMS4wMDAsIDAuMzIwLCAxLjAwMCknLFxuICBlYXNlT3V0U2luZTogJ2N1YmljLWJlemllcigwLjM5MCwgIDAuNTc1LCAwLjU2NSwgMS4wMDApJyxcbiAgZWFzZUluT3V0QmFjazogJ2N1YmljLWJlemllcigwLjY4MCwgLTAuNTUwLCAwLjI2NSwgMS41NTApJyxcbiAgZWFzZUluT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjc4NSwgIDAuMTM1LCAwLjE1MCwgMC44NjApJyxcbiAgZWFzZUluT3V0Q3ViaWM6ICdjdWJpYy1iZXppZXIoMC42NDUsICAwLjA0NSwgMC4zNTUsIDEuMDAwKScsXG4gIGVhc2VJbk91dEV4cG86ICdjdWJpYy1iZXppZXIoMS4wMDAsICAwLjAwMCwgMC4wMDAsIDEuMDAwKScsXG4gIGVhc2VJbk91dFF1YWQ6ICdjdWJpYy1iZXppZXIoMC40NTUsICAwLjAzMCwgMC41MTUsIDAuOTU1KScsXG4gIGVhc2VJbk91dFF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuNzcwLCAgMC4wMDAsIDAuMTc1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRRdWludDogJ2N1YmljLWJlemllcigwLjg2MCwgIDAuMDAwLCAwLjA3MCwgMS4wMDApJyxcbiAgZWFzZUluT3V0U2luZTogJ2N1YmljLWJlemllcigwLjQ0NSwgIDAuMDUwLCAwLjU1MCwgMC45NTApJ1xufTtcbi8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cblxuZnVuY3Rpb24gZ2V0VGltaW5nRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbnNNYXBbZnVuY3Rpb25OYW1lXTtcbn1cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGluIHY1IGluIGZhdm9yIG9mIGBlYXNlSW5gLCBgZWFzZU91dGAsIGBlYXNlSW5PdXRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiB0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke3RpbWluZ0Z1bmN0aW9ucygnZWFzZUluUXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiB0aW1pbmdGdW5jdGlvbnModGltaW5nRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGdldFRpbWluZ0Z1bmN0aW9uKHRpbWluZ0Z1bmN0aW9uKTtcbn1cblxudmFyIGdldEJvcmRlcldpZHRoID0gZnVuY3Rpb24gZ2V0Qm9yZGVyV2lkdGgocG9pbnRpbmdEaXJlY3Rpb24sIGhlaWdodCwgd2lkdGgpIHtcbiAgdmFyIGZ1bGxXaWR0aCA9IFwiXCIgKyB3aWR0aFswXSArICh3aWR0aFsxXSB8fCAnJyk7XG4gIHZhciBoYWxmV2lkdGggPSBcIlwiICsgd2lkdGhbMF0gLyAyICsgKHdpZHRoWzFdIHx8ICcnKTtcbiAgdmFyIGZ1bGxIZWlnaHQgPSBcIlwiICsgaGVpZ2h0WzBdICsgKGhlaWdodFsxXSB8fCAnJyk7XG4gIHZhciBoYWxmSGVpZ2h0ID0gXCJcIiArIGhlaWdodFswXSAvIDIgKyAoaGVpZ2h0WzFdIHx8ICcnKTtcblxuICBzd2l0Y2ggKHBvaW50aW5nRGlyZWN0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHJldHVybiBcIjAgXCIgKyBoYWxmV2lkdGggKyBcIiBcIiArIGZ1bGxIZWlnaHQgKyBcIiBcIiArIGhhbGZXaWR0aDtcblxuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgcmV0dXJuIGZ1bGxXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodCArIFwiIDAgMFwiO1xuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gaGFsZkhlaWdodCArIFwiIFwiICsgZnVsbFdpZHRoICsgXCIgXCIgKyBoYWxmSGVpZ2h0ICsgXCIgMFwiO1xuXG4gICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICByZXR1cm4gZnVsbFdpZHRoICsgXCIgMCAwIFwiICsgZnVsbEhlaWdodDtcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICByZXR1cm4gZnVsbEhlaWdodCArIFwiIFwiICsgaGFsZldpZHRoICsgXCIgMCBcIiArIGhhbGZXaWR0aDtcblxuICAgIGNhc2UgJ2JvdHRvbVJpZ2h0JzpcbiAgICAgIHJldHVybiBcIjAgMCBcIiArIGZ1bGxXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodDtcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBoYWxmSGVpZ2h0ICsgXCIgMCBcIiArIGhhbGZIZWlnaHQgKyBcIiBcIiArIGZ1bGxXaWR0aDtcblxuICAgIGNhc2UgJ3RvcFJpZ2h0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiMCBcIiArIGZ1bGxXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodCArIFwiIDBcIjtcbiAgfVxufTtcblxudmFyIGdldEJvcmRlckNvbG9yID0gZnVuY3Rpb24gZ2V0Qm9yZGVyQ29sb3IocG9pbnRpbmdEaXJlY3Rpb24sIGZvcmVncm91bmRDb2xvcikge1xuICBzd2l0Y2ggKHBvaW50aW5nRGlyZWN0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b21SaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogZm9yZWdyb3VuZENvbG9yXG4gICAgICB9O1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBmb3JlZ3JvdW5kQ29sb3JcbiAgICAgIH07XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IGZvcmVncm91bmRDb2xvclxuICAgICAgfTtcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3RvcFJpZ2h0JzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvcmRlclJpZ2h0Q29sb3I6IGZvcmVncm91bmRDb2xvclxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1OSk7XG4gIH1cbn07XG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJpYW5nbGUgd2l0aCBhbnkgcG9pbnRpbmcgZGlyZWN0aW9uIHdpdGggYW4gb3B0aW9uYWwgYmFja2dyb3VuZCBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICpcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4udHJpYW5nbGUoeyBwb2ludGluZ0RpcmVjdGlvbjogJ3JpZ2h0Jywgd2lkdGg6ICcxMDBweCcsIGhlaWdodDogJzEwMHB4JywgZm9yZWdyb3VuZENvbG9yOiAncmVkJyB9KVxuICogfVxuICpcbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHt0cmlhbmdsZSh7IHBvaW50aW5nRGlyZWN0aW9uOiAncmlnaHQnLCB3aWR0aDogJzEwMHB4JywgaGVpZ2h0OiAnMTAwcHgnLCBmb3JlZ3JvdW5kQ29sb3I6ICdyZWQnIH0pfVxuICpcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgJ2JvcmRlckNvbG9yJzogJ3RyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHJlZCcsXG4gKiAgJ2JvcmRlclN0eWxlJzogJ3NvbGlkJyxcbiAqICAnYm9yZGVyV2lkdGgnOiAnNTBweCAwIDUwcHggMTAwcHgnLFxuICogICdoZWlnaHQnOiAnMCcsXG4gKiAgJ3dpZHRoJzogJzAnLFxuICogfVxuICovXG5cblxuZnVuY3Rpb24gdHJpYW5nbGUoX3JlZikge1xuICB2YXIgcG9pbnRpbmdEaXJlY3Rpb24gPSBfcmVmLnBvaW50aW5nRGlyZWN0aW9uLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBmb3JlZ3JvdW5kQ29sb3IgPSBfcmVmLmZvcmVncm91bmRDb2xvcixcbiAgICAgIF9yZWYkYmFja2dyb3VuZENvbG9yID0gX3JlZi5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBfcmVmJGJhY2tncm91bmRDb2xvciA9PT0gdm9pZCAwID8gJ3RyYW5zcGFyZW50JyA6IF9yZWYkYmFja2dyb3VuZENvbG9yO1xuICB2YXIgd2lkdGhBbmRVbml0ID0gZ2V0VmFsdWVBbmRVbml0KHdpZHRoKTtcbiAgdmFyIGhlaWdodEFuZFVuaXQgPSBnZXRWYWx1ZUFuZFVuaXQoaGVpZ2h0KTtcblxuICBpZiAoaXNOYU4oaGVpZ2h0QW5kVW5pdFswXSkgfHwgaXNOYU4od2lkdGhBbmRVbml0WzBdKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYwKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6ICcwJyxcbiAgICBoZWlnaHQ6ICcwJyxcbiAgICBib3JkZXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gIH0sIGdldEJvcmRlckNvbG9yKHBvaW50aW5nRGlyZWN0aW9uLCBmb3JlZ3JvdW5kQ29sb3IpLCB7XG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyV2lkdGg6IGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHRBbmRVbml0LCB3aWR0aEFuZFVuaXQpXG4gIH0pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIGNoYW5nZSB0aGUgYHdvcmRXcmFwYCBwcm9wZXJ0eS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi53b3JkV3JhcCgnYnJlYWstd29yZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7d29yZFdyYXAoJ2JyZWFrLXdvcmQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcbiAqICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAqICAgd29yZEJyZWFrOiAnYnJlYWstYWxsJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gd29yZFdyYXAod3JhcCkge1xuICBpZiAod3JhcCA9PT0gdm9pZCAwKSB7XG4gICAgd3JhcCA9ICdicmVhay13b3JkJztcbiAgfVxuXG4gIHZhciB3b3JkQnJlYWsgPSB3cmFwID09PSAnYnJlYWstd29yZCcgPyAnYnJlYWstYWxsJyA6IHdyYXA7XG4gIHJldHVybiB7XG4gICAgb3ZlcmZsb3dXcmFwOiB3cmFwLFxuICAgIHdvcmRXcmFwOiB3cmFwLFxuICAgIHdvcmRCcmVhazogd29yZEJyZWFrXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9JbnQoY29sb3IpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoY29sb3IgKiAyNTUpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gY29sb3JUb0ludChyZWQpICsgXCIsXCIgKyBjb2xvclRvSW50KGdyZWVuKSArIFwiLFwiICsgY29sb3JUb0ludChibHVlKTtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGNvbnZlcnQpIHtcbiAgaWYgKGNvbnZlcnQgPT09IHZvaWQgMCkge1xuICAgIGNvbnZlcnQgPSBjb252ZXJ0VG9JbnQ7XG4gIH1cblxuICBpZiAoc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICByZXR1cm4gY29udmVydChsaWdodG5lc3MsIGxpZ2h0bmVzcywgbGlnaHRuZXNzKTtcbiAgfSAvLyBmb3JtdWxhZSBmcm9tIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWXG5cblxuICB2YXIgaHVlUHJpbWUgPSAoaHVlICUgMzYwICsgMzYwKSAlIDM2MCAvIDYwO1xuICB2YXIgY2hyb21hID0gKDEgLSBNYXRoLmFicygyICogbGlnaHRuZXNzIC0gMSkpICogc2F0dXJhdGlvbjtcbiAgdmFyIHNlY29uZENvbXBvbmVudCA9IGNocm9tYSAqICgxIC0gTWF0aC5hYnMoaHVlUHJpbWUgJSAyIC0gMSkpO1xuICB2YXIgcmVkID0gMDtcbiAgdmFyIGdyZWVuID0gMDtcbiAgdmFyIGJsdWUgPSAwO1xuXG4gIGlmIChodWVQcmltZSA+PSAwICYmIGh1ZVByaW1lIDwgMSkge1xuICAgIHJlZCA9IGNocm9tYTtcbiAgICBncmVlbiA9IHNlY29uZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSAxICYmIGh1ZVByaW1lIDwgMikge1xuICAgIHJlZCA9IHNlY29uZENvbXBvbmVudDtcbiAgICBncmVlbiA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSAyICYmIGh1ZVByaW1lIDwgMykge1xuICAgIGdyZWVuID0gY2hyb21hO1xuICAgIGJsdWUgPSBzZWNvbmRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gMyAmJiBodWVQcmltZSA8IDQpIHtcbiAgICBncmVlbiA9IHNlY29uZENvbXBvbmVudDtcbiAgICBibHVlID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDQgJiYgaHVlUHJpbWUgPCA1KSB7XG4gICAgcmVkID0gc2Vjb25kQ29tcG9uZW50O1xuICAgIGJsdWUgPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gNSAmJiBodWVQcmltZSA8IDYpIHtcbiAgICByZWQgPSBjaHJvbWE7XG4gICAgYmx1ZSA9IHNlY29uZENvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBsaWdodG5lc3NNb2RpZmljYXRpb24gPSBsaWdodG5lc3MgLSBjaHJvbWEgLyAyO1xuICB2YXIgZmluYWxSZWQgPSByZWQgKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHZhciBmaW5hbEdyZWVuID0gZ3JlZW4gKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHZhciBmaW5hbEJsdWUgPSBibHVlICsgbGlnaHRuZXNzTW9kaWZpY2F0aW9uO1xuICByZXR1cm4gY29udmVydChmaW5hbFJlZCwgZmluYWxHcmVlbiwgZmluYWxCbHVlKTtcbn1cblxudmFyIG5hbWVkQ29sb3JNYXAgPSB7XG4gIGFsaWNlYmx1ZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICcwMGZmZmYnLFxuICBhcXVhbWFyaW5lOiAnN2ZmZmQ0JyxcbiAgYXp1cmU6ICdmMGZmZmYnLFxuICBiZWlnZTogJ2Y1ZjVkYycsXG4gIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gIGJsYWNrOiAnMDAwJyxcbiAgYmxhbmNoZWRhbG1vbmQ6ICdmZmViY2QnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gIGJyb3duOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgY2hhcnRyZXVzZTogJzdmZmYwMCcsXG4gIGNob2NvbGF0ZTogJ2QyNjkxZScsXG4gIGNvcmFsOiAnZmY3ZjUwJyxcbiAgY29ybmZsb3dlcmJsdWU6ICc2NDk1ZWQnLFxuICBjb3Juc2lsazogJ2ZmZjhkYycsXG4gIGNyaW1zb246ICdkYzE0M2MnLFxuICBjeWFuOiAnMDBmZmZmJyxcbiAgZGFya2JsdWU6ICcwMDAwOGInLFxuICBkYXJrY3lhbjogJzAwOGI4YicsXG4gIGRhcmtnb2xkZW5yb2Q6ICdiODg2MGInLFxuICBkYXJrZ3JheTogJ2E5YTlhOScsXG4gIGRhcmtncmVlbjogJzAwNjQwMCcsXG4gIGRhcmtncmV5OiAnYTlhOWE5JyxcbiAgZGFya2toYWtpOiAnYmRiNzZiJyxcbiAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gIGRhcmtvcmFuZ2U6ICdmZjhjMDAnLFxuICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgZGFya3JlZDogJzhiMDAwMCcsXG4gIGRhcmtzYWxtb246ICdlOTk2N2EnLFxuICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgZGFya3NsYXRlZ3JheTogJzJmNGY0ZicsXG4gIGRhcmtzbGF0ZWdyZXk6ICcyZjRmNGYnLFxuICBkYXJrdHVycXVvaXNlOiAnMDBjZWQxJyxcbiAgZGFya3Zpb2xldDogJzk0MDBkMycsXG4gIGRlZXBwaW5rOiAnZmYxNDkzJyxcbiAgZGVlcHNreWJsdWU6ICcwMGJmZmYnLFxuICBkaW1ncmF5OiAnNjk2OTY5JyxcbiAgZGltZ3JleTogJzY5Njk2OScsXG4gIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICBmaXJlYnJpY2s6ICdiMjIyMjInLFxuICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgZnVjaHNpYTogJ2ZmMDBmZicsXG4gIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICBnb2xkOiAnZmZkNzAwJyxcbiAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgZ3JheTogJzgwODA4MCcsXG4gIGdyZWVuOiAnMDA4MDAwJyxcbiAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICBncmV5OiAnODA4MDgwJyxcbiAgaG9uZXlkZXc6ICdmMGZmZjAnLFxuICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgaW5kaWFucmVkOiAnY2Q1YzVjJyxcbiAgaW5kaWdvOiAnNGIwMDgyJyxcbiAgaXZvcnk6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gIGxpZ2h0Z3JheTogJ2QzZDNkMycsXG4gIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICBsaWdodHNsYXRlZ3JheTogJzc4OScsXG4gIGxpZ2h0c2xhdGVncmV5OiAnNzg5JyxcbiAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gIGxpbWU6ICcwZjAnLFxuICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICBsaW5lbjogJ2ZhZjBlNicsXG4gIG1hZ2VudGE6ICdmMGYnLFxuICBtYXJvb246ICc4MDAwMDAnLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gIG1lZGl1bXB1cnBsZTogJzkzNzBkYicsXG4gIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgbmF2eTogJzAwMDA4MCcsXG4gIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICBvbGl2ZTogJzgwODAwMCcsXG4gIG9saXZlZHJhYjogJzZiOGUyMycsXG4gIG9yYW5nZTogJ2ZmYTUwMCcsXG4gIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gIG9yY2hpZDogJ2RhNzBkNicsXG4gIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgcGFsZXZpb2xldHJlZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcGluazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgcHVycGxlOiAnODAwMDgwJyxcbiAgcmViZWNjYXB1cnBsZTogJzYzOScsXG4gIHJlZDogJ2YwMCcsXG4gIHJvc3licm93bjogJ2JjOGY4ZicsXG4gIHJveWFsYmx1ZTogJzQxNjllMScsXG4gIHNhZGRsZWJyb3duOiAnOGI0NTEzJyxcbiAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gIHNlYWdyZWVuOiAnMmU4YjU3JyxcbiAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICBzaWVubmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3libHVlOiAnODdjZWViJyxcbiAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgc2xhdGVncmF5OiAnNzA4MDkwJyxcbiAgc2xhdGVncmV5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwcmluZ2dyZWVuOiAnMDBmZjdmJyxcbiAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVhbDogJzAwODA4MCcsXG4gIHRoaXN0bGU6ICdkOGJmZDgnLFxuICB0b21hdG86ICdmZjYzNDcnLFxuICB0dXJxdW9pc2U6ICc0MGUwZDAnLFxuICB2aW9sZXQ6ICdlZTgyZWUnLFxuICB3aGVhdDogJ2Y1ZGViMycsXG4gIHdoaXRlOiAnZmZmJyxcbiAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gIHllbGxvdzogJ2ZmMCcsXG4gIHllbGxvd2dyZWVuOiAnOWFjZDMyJ1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGEgQ1NTIG5hbWVkIGNvbG9yIGFuZCByZXR1cm5zIGl0cyBlcXVpdmFsZW50IGhleCB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIG9yaWdpbmFsIGNvbG9yLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBuYW1lVG9IZXgoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHJldHVybiBjb2xvcjtcbiAgdmFyIG5vcm1hbGl6ZWRDb2xvck5hbWUgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA/IFwiI1wiICsgbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA6IGNvbG9yO1xufVxuXG52YXIgaGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXs2fSQvO1xudmFyIGhleFJnYmFSZWdleCA9IC9eI1thLWZBLUYwLTldezh9JC87XG52YXIgcmVkdWNlZEhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17M30kLztcbnZhciByZWR1Y2VkUmdiYUhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17NH0kLztcbnZhciByZ2JSZWdleCA9IC9ecmdiXFwoXFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqXFwpJC9pO1xudmFyIHJnYmFSZWdleCA9IC9ecmdiKD86YSk/XFwoXFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LCk/XFxzKihcXGR7MSwzfSlcXHMqKD86LHxcXC8pXFxzKihbLStdP1xcZCpbLl0/XFxkK1slXT8pXFxzKlxcKSQvaTtcbnZhciBoc2xSZWdleCA9IC9eaHNsXFwoXFxzKihcXGR7MCwzfVsuXT9bMC05XSsoPzpkZWcpPylcXHMqKD86LCk/XFxzKihcXGR7MSwzfVsuXT9bMC05XT8pJVxccyooPzosKT9cXHMqKFxcZHsxLDN9Wy5dP1swLTldPyklXFxzKlxcKSQvaTtcbnZhciBoc2xhUmVnZXggPSAvXmhzbCg/OmEpP1xcKFxccyooXFxkezAsM31bLl0/WzAtOV0rKD86ZGVnKT8pXFxzKig/OiwpP1xccyooXFxkezEsM31bLl0/WzAtOV0/KSVcXHMqKD86LCk/XFxzKihcXGR7MSwzfVsuXT9bMC05XT8pJVxccyooPzosfFxcLylcXHMqKFstK10/XFxkKlsuXT9cXGQrWyVdPylcXHMqXFwpJC9pO1xuLyoqXG4gKiBSZXR1cm5zIGFuIFJnYkNvbG9yIG9yIFJnYmFDb2xvciBvYmplY3QuIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBpcyBvbmx5IHVzZWZ1bFxuICogaWYgd2FudCB0byBleHRyYWN0IGEgY29sb3IgY29tcG9uZW50LiBXaXRoIHRoZSBjb2xvciB1dGlsIGB0b0NvbG9yU3RyaW5nYCB5b3VcbiAqIGNhbiBjb252ZXJ0IGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCBiYWNrIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogMjU1LCBncmVlbjogMCwgYmx1ZTogMCB9YCB0byBjb2xvcjFcbiAqIGNvbnN0IGNvbG9yMSA9IHBhcnNlVG9SZ2IoJ3JnYigyNTUsIDAsIDApJyk7XG4gKiAvLyBBc3NpZ25zIGB7IHJlZDogOTIsIGdyZWVuOiAxMDIsIGJsdWU6IDExMiwgYWxwaGE6IDAuNzUgfWAgdG8gY29sb3IyXG4gKiBjb25zdCBjb2xvcjIgPSBwYXJzZVRvUmdiKCdoc2xhKDIxMCwgMTAlLCA0MCUsIDAuNzUpJyk7XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUb1JnYihjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDMpO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IG5hbWVUb0hleChjb2xvcik7XG5cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChoZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls1XSArIG5vcm1hbGl6ZWRDb2xvcls2XSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2goaGV4UmdiYVJlZ2V4KSkge1xuICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQoKHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbN10gKyBub3JtYWxpemVkQ29sb3JbOF0sIDE2KSAvIDI1NSkudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNV0gKyBub3JtYWxpemVkQ29sb3JbNl0sIDE2KSxcbiAgICAgIGFscGhhOiBhbHBoYVxuICAgIH07XG4gIH1cblxuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKHJlZHVjZWRIZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzFdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsyXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvclszXSwgMTYpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2gocmVkdWNlZFJnYmFIZXhSZWdleCkpIHtcbiAgICB2YXIgX2FscGhhID0gcGFyc2VGbG9hdCgocGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls0XSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKTtcblxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMV0gKyBub3JtYWxpemVkQ29sb3JbMV0sIDE2KSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzJdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzNdLCAxNiksXG4gICAgICBhbHBoYTogX2FscGhhXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChyZ2JNYXRjaGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgcmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgcmdiYU1hdGNoZWQgPSByZ2JhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3Iuc3Vic3RyaW5nKDAsIDUwKSk7XG5cbiAgaWYgKHJnYmFNYXRjaGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzFdLCAxMCksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzJdLCAxMCksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgcmdiYU1hdGNoZWRbM10sIDEwKSxcbiAgICAgIGFscGhhOiBwYXJzZUZsb2F0KFwiXCIgKyByZ2JhTWF0Y2hlZFs0XSkgPiAxID8gcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pIC8gMTAwIDogcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pXG4gICAgfTtcbiAgfVxuXG4gIHZhciBoc2xNYXRjaGVkID0gaHNsUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuXG4gIGlmIChoc2xNYXRjaGVkKSB7XG4gICAgdmFyIGh1ZSA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzFdLCAxMCk7XG4gICAgdmFyIHNhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFsyXSwgMTApIC8gMTAwO1xuICAgIHZhciBsaWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciByZ2JDb2xvclN0cmluZyA9IFwicmdiKFwiICsgaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpICsgXCIpXCI7XG4gICAgdmFyIGhzbFJnYk1hdGNoZWQgPSByZ2JSZWdleC5leGVjKHJnYkNvbG9yU3RyaW5nKTtcblxuICAgIGlmICghaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCByZ2JDb2xvclN0cmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludChcIlwiICsgaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbM10sIDEwKVxuICAgIH07XG4gIH1cblxuICB2YXIgaHNsYU1hdGNoZWQgPSBoc2xhUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3Iuc3Vic3RyaW5nKDAsIDUwKSk7XG5cbiAgaWYgKGhzbGFNYXRjaGVkKSB7XG4gICAgdmFyIF9odWUgPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbMV0sIDEwKTtcblxuICAgIHZhciBfc2F0dXJhdGlvbiA9IHBhcnNlSW50KFwiXCIgKyBoc2xhTWF0Y2hlZFsyXSwgMTApIC8gMTAwO1xuXG4gICAgdmFyIF9saWdodG5lc3MgPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbM10sIDEwKSAvIDEwMDtcblxuICAgIHZhciBfcmdiQ29sb3JTdHJpbmcgPSBcInJnYihcIiArIGhzbFRvUmdiKF9odWUsIF9zYXR1cmF0aW9uLCBfbGlnaHRuZXNzKSArIFwiKVwiO1xuXG4gICAgdmFyIF9oc2xSZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhfcmdiQ29sb3JTdHJpbmcpO1xuXG4gICAgaWYgKCFfaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCBfcmdiQ29sb3JTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIF9oc2xSZ2JNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdChcIlwiICsgaHNsYU1hdGNoZWRbNF0pID4gMSA/IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKSAvIDEwMCA6IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1KTtcbn1cblxuZnVuY3Rpb24gcmdiVG9Ic2woY29sb3IpIHtcbiAgLy8gbWFrZSBzdXJlIHJnYiBhcmUgY29udGFpbmVkIGluIGEgc2V0IG9mIFswLCAyNTVdXG4gIHZhciByZWQgPSBjb2xvci5yZWQgLyAyNTU7XG4gIHZhciBncmVlbiA9IGNvbG9yLmdyZWVuIC8gMjU1O1xuICB2YXIgYmx1ZSA9IGNvbG9yLmJsdWUgLyAyNTU7XG4gIHZhciBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHVlOiAwLFxuICAgICAgICBzYXR1cmF0aW9uOiAwLFxuICAgICAgICBsaWdodG5lc3M6IGxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodWU6IDAsXG4gICAgICAgIHNhdHVyYXRpb246IDAsXG4gICAgICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBodWU7XG4gIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgdmFyIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPiAwLjUgPyBkZWx0YSAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhIC8gKG1heCArIG1pbik7XG5cbiAgc3dpdGNoIChtYXgpIHtcbiAgICBjYXNlIHJlZDpcbiAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGdyZWVuOlxuICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gYmx1ZSBjYXNlXG4gICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgKyA0O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBodWUgKj0gNjA7XG5cbiAgaWYgKGNvbG9yLmFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHVlOiBodWUsXG4gICAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBsaWdodG5lc3MsXG4gICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBodWU6IGh1ZSxcbiAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyBodWU6IDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gcGFyc2VUb0hzbCgncmdiKDI1NSwgMCwgMCknKTtcbiAqIC8vIEFzc2lnbnMgYHsgaHVlOiAxMjgsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41LCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9IHBhcnNlVG9Ic2woJ2hzbGEoMTI4LCAxMDAlLCA1MCUsIDAuNzUpJyk7XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9Ic2woY29sb3IpIHtcbiAgLy8gTm90ZTogQXQgYSBsYXRlciBzdGFnZSB3ZSBjYW4gb3B0aW1pemUgdGhpcyBmdW5jdGlvbiBhcyByaWdodCBub3cgYSBoc2xcbiAgLy8gY29sb3Igd291bGQgYmUgcGFyc2VkIGNvbnZlcnRlZCB0byByZ2IgdmFsdWVzIGFuZCBjb252ZXJ0ZWQgYmFjayB0byBoc2wuXG4gIHJldHVybiByZ2JUb0hzbChwYXJzZVRvUmdiKGNvbG9yKSk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBoZXggdmFsdWVzIGlmIHBvc3NpYmxlIGUuZy4gI2ZmODg2NiB0byAjZjg2XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVkdWNlSGV4VmFsdWUgPSBmdW5jdGlvbiByZWR1Y2VIZXhWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSA3ICYmIHZhbHVlWzFdID09PSB2YWx1ZVsyXSAmJiB2YWx1ZVszXSA9PT0gdmFsdWVbNF0gJiYgdmFsdWVbNV0gPT09IHZhbHVlWzZdKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgdmFsdWVbMV0gKyB2YWx1ZVszXSArIHZhbHVlWzVdO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHJlZHVjZUhleFZhbHVlJDEgPSByZWR1Y2VIZXhWYWx1ZTtcblxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWUpIHtcbiAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb0hleChjb2xvcikge1xuICByZXR1cm4gbnVtYmVyVG9IZXgoTWF0aC5yb3VuZChjb2xvciAqIDI1NSkpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gcmVkdWNlSGV4VmFsdWUkMShcIiNcIiArIGNvbG9yVG9IZXgocmVkKSArIGNvbG9yVG9IZXgoZ3JlZW4pICsgY29sb3JUb0hleChibHVlKSk7XG59XG5cbmZ1bmN0aW9uIGhzbFRvSGV4KGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XG4gIHJldHVybiBoc2xUb1JnYihodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgY29udmVydFRvSGV4KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIGhleCBub3RhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBoc2woMzU5LCAwLjc1LCAwLjQpLFxuICogICBiYWNrZ3JvdW5kOiBoc2woeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsKDM1OSwgMC43NSwgMC40KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40IH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2IzMTkxY1wiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHNsKHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBsaWdodG5lc3MgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGhzbFRvSGV4KHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgc2F0dXJhdGlvbiA9PT0gdW5kZWZpbmVkICYmIGxpZ2h0bmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhzbFRvSGV4KHZhbHVlLmh1ZSwgdmFsdWUuc2F0dXJhdGlvbiwgdmFsdWUubGlnaHRuZXNzKTtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDEpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgcmdiYSBvciBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyOCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjgsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHNsYSh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxpZ2h0bmVzcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFscGhhID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgOiBcInJnYmEoXCIgKyBoc2xUb1JnYih2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSArIFwiLFwiICsgYWxwaGEgKyBcIilcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHNhdHVyYXRpb24gPT09IHVuZGVmaW5lZCAmJiBsaWdodG5lc3MgPT09IHVuZGVmaW5lZCAmJiBhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlLmFscGhhID49IDEgPyBoc2xUb0hleCh2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcykgOiBcInJnYmEoXCIgKyBoc2xUb1JnYih2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcykgKyBcIixcIiArIHZhbHVlLmFscGhhICsgXCIpXCI7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIGhleCBub3RhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyMDUsIDEwMCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKDI1NSwgMjA1LCAxMDApfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiKHZhbHVlLCBncmVlbiwgYmx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBibHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiByZWR1Y2VIZXhWYWx1ZSQxKFwiI1wiICsgbnVtYmVyVG9IZXgodmFsdWUpICsgbnVtYmVyVG9IZXgoZ3JlZW4pICsgbnVtYmVyVG9IZXgoYmx1ZSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgZ3JlZW4gPT09IHVuZGVmaW5lZCAmJiBibHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUkMShcIiNcIiArIG51bWJlclRvSGV4KHZhbHVlLnJlZCkgKyBudW1iZXJUb0hleCh2YWx1ZS5ncmVlbikgKyBudW1iZXJUb0hleCh2YWx1ZS5ibHVlKSk7XG4gIH1cblxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHJnYmEgb3IgaGV4IG5vdGF0aW9uLlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gZmFkZSBhIGNvbG9yIGJ5IHBhc3NpbmcgYSBoZXggdmFsdWUgb3IgbmFtZWQgQ1NTIGNvbG9yIGFsb25nIHdpdGggYW4gYWxwaGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAwLjcpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNyB9KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIwNSwgMTAwLCAxKSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgnI2ZmZmZmZicsIDAuNCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoJ2JsYWNrJywgMC43KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDAuNyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKDI1NSwgMjA1LCAxMDAsIDEpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKCcjZmZmZmZmJywgMC40KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgnYmxhY2snLCAwLjcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjA1LDEwMCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC40KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMCwwLDAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiByZ2JhKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlLCB0aGlyZFZhbHVlLCBmb3VydGhWYWx1ZSkge1xuICBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWNvbmRWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgcmdiVmFsdWUgPSBwYXJzZVRvUmdiKGZpcnN0VmFsdWUpO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JWYWx1ZS5yZWQgKyBcIixcIiArIHJnYlZhbHVlLmdyZWVuICsgXCIsXCIgKyByZ2JWYWx1ZS5ibHVlICsgXCIsXCIgKyBzZWNvbmRWYWx1ZSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2Vjb25kVmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiB0aGlyZFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZm91cnRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvdXJ0aFZhbHVlID49IDEgPyByZ2IoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZSArIFwiLFwiICsgc2Vjb25kVmFsdWUgKyBcIixcIiArIHRoaXJkVmFsdWUgKyBcIixcIiArIGZvdXJ0aFZhbHVlICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0VmFsdWUgPT09ICdvYmplY3QnICYmIHNlY29uZFZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcmRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZvdXJ0aFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmlyc3RWYWx1ZS5hbHBoYSA+PSAxID8gcmdiKGZpcnN0VmFsdWUucmVkLCBmaXJzdFZhbHVlLmdyZWVuLCBmaXJzdFZhbHVlLmJsdWUpIDogXCJyZ2JhKFwiICsgZmlyc3RWYWx1ZS5yZWQgKyBcIixcIiArIGZpcnN0VmFsdWUuZ3JlZW4gKyBcIixcIiArIGZpcnN0VmFsdWUuYmx1ZSArIFwiLFwiICsgZmlyc3RWYWx1ZS5hbHBoYSArIFwiKVwiO1xuICB9XG5cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNyk7XG59XG5cbnZhciBpc1JnYiA9IGZ1bmN0aW9uIGlzUmdiKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBpc1JnYmEgPSBmdW5jdGlvbiBpc1JnYmEoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNIc2wgPSBmdW5jdGlvbiBpc0hzbChjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmICh0eXBlb2YgY29sb3IuYWxwaGEgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcblxudmFyIGlzSHNsYSA9IGZ1bmN0aW9uIGlzSHNsYShjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGByZ2JgLCBgcmdiYWAsIGBoc2xgIG9yIGBoc2xhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjMDBmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjUsMC43MilcIjtcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xuICBpZiAoaXNSZ2JhKGNvbG9yKSkgcmV0dXJuIHJnYmEoY29sb3IpO1xuICBpZiAoaXNSZ2IoY29sb3IpKSByZXR1cm4gcmdiKGNvbG9yKTtcbiAgaWYgKGlzSHNsYShjb2xvcikpIHJldHVybiBoc2xhKGNvbG9yKTtcbiAgaWYgKGlzSHNsKGNvbG9yKSkgcmV0dXJuIGhzbChjb2xvcik7XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDgpO1xufVxuXG4vLyBUeXBlIGRlZmluaXRpb25zIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2djYW50aS9mbG93LXN0YXRpYy1sYW5kL2Jsb2IvbWFzdGVyL3NyYy9GdW4uanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBjdXJyaWVkKGYsIGxlbmd0aCwgYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgdmFyIGNvbWJpbmVkID0gYWNjLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gY29tYmluZWQubGVuZ3RoID49IGxlbmd0aCA/IGYuYXBwbHkodGhpcywgY29tYmluZWQpIDogY3VycmllZChmLCBsZW5ndGgsIGNvbWJpbmVkKTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbmZ1bmN0aW9uIGN1cnJ5KGYpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcbiAgcmV0dXJuIGN1cnJpZWQoZiwgZi5sZW5ndGgsIFtdKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBodWUgb2YgdGhlIGNvbG9yLiBIdWUgaXMgYSBudW1iZXIgYmV0d2VlbiAwIHRvIDM2MC4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBmb3IgYWRqdXN0SHVlIGlzIHRoZSBhbW91bnQgb2YgZGVncmVlcyB0aGUgY29sb3IgaXMgcm90YXRlZCBhcm91bmRcbiAqIHRoZSBjb2xvciB3aGVlbCwgYWx3YXlzIHByb2R1Y2luZyBhIHBvc2l0aXZlIGh1ZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBhZGp1c3RIdWUoMTgwLCAnIzQ0OCcpLFxuICogICBiYWNrZ3JvdW5kOiBhZGp1c3RIdWUoJzE4MCcsICdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHthZGp1c3RIdWUoMTgwLCAnIzQ0OCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHthZGp1c3RIdWUoJzE4MCcsICdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzg4ODg0NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTM2LDEzNiw2OCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gYWRqdXN0SHVlKGRlZ3JlZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBodWU6IGhzbENvbG9yLmh1ZSArIHBhcnNlRmxvYXQoZGVncmVlKVxuICB9KSk7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbnZhciBjdXJyaWVkQWRqdXN0SHVlID0gLyojX19QVVJFX18qL2N1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGFkanVzdEh1ZSk7XG52YXIgY3VycmllZEFkanVzdEh1ZSQxID0gY3VycmllZEFkanVzdEh1ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb21wbGVtZW50IG9mIHRoZSBwcm92aWRlZCBjb2xvci4gVGhpcyBpcyBpZGVudGljYWwgdG8gYWRqdXN0SHVlKDE4MCwgPGNvbG9yPikuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogY29tcGxlbWVudCgnIzQ0OCcpLFxuICogICBiYWNrZ3JvdW5kOiBjb21wbGVtZW50KCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtjb21wbGVtZW50KCcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2NvbXBsZW1lbnQoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNTMsMTUzLDE1MywwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gY29tcGxlbWVudChjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGh1ZTogKGhzbENvbG9yLmh1ZSArIDE4MCkgJSAzNjBcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBndWFyZChsb3dlckJvdW5kYXJ5LCB1cHBlckJvdW5kYXJ5LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgobG93ZXJCb3VuZGFyeSwgTWF0aC5taW4odXBwZXJCb3VuZGFyeSwgdmFsdWUpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgZGFya2VuZWQgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogZGFya2VuKDAuMiwgJyNGRkNENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZGFya2VuKCcwLjInLCAncmdiYSgyNTUsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7ZGFya2VuKDAuMiwgJyNGRkNENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7ZGFya2VuKCcwLjInLCAncmdiYSgyNTUsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZiZDMxXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMTg5LDQ5LDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBkYXJrZW4oYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGxpZ2h0bmVzczogZ3VhcmQoMCwgMSwgaHNsQ29sb3IubGlnaHRuZXNzIC0gcGFyc2VGbG9hdChhbW91bnQpKVxuICB9KSk7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbnZhciBjdXJyaWVkRGFya2VuID0gLyojX19QVVJFX18qL2N1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGRhcmtlbik7XG52YXIgY3VycmllZERhcmtlbiQxID0gY3VycmllZERhcmtlbjtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIGRlc2F0dXJhdGUgZnVuY3Rpb24gaXMgdGhlIGFtb3VudCBieSBob3cgbXVjaCB0aGUgY29sb3JcbiAqIGludGVuc2l0eSBzaG91bGQgYmUgZGVjcmVhc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7ZGVzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2I4Yjk3OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTg0LDE4NSwxMjEsMC43KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWREZXNhdHVyYXRlID0gLyojX19QVVJFX18qL2N1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKGRlc2F0dXJhdGUpO1xudmFyIGN1cnJpZWREZXNhdHVyYXRlJDEgPSBjdXJyaWVkRGVzYXR1cmF0ZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIChmbG9hdCkgcmVwcmVzZW50aW5nIHRoZSBsdW1pbmFuY2Ugb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJyxcbiAqICAgYmFja2dyb3VuZDogZ2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScsXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCcjQ0NDRDY0JykgPj0gZ2V0THVtaW5hbmNlKCcjMDAwMGZmJykgPyAnI0NDQ0Q2NCcgOiAnIzAwMDBmZid9O1xuICogICBiYWNrZ3JvdW5kOiAke2dldEx1bWluYW5jZSgncmdiYSg1OCwgMTMzLCAyNTUsIDEpJykgPj0gZ2V0THVtaW5hbmNlKCdyZ2JhKDI1NSwgNTcsIDE0OSwgMSknKSA/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScgOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDI1NSwgNTcsIDE0OSwgMSknfTtcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgYmFja2dyb3VuZDogXCIjQ0NDRDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSg1OCwgMTMzLCAyNTUsIDEpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIDA7XG4gIHZhciByZ2JDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuXG4gIHZhciBfT2JqZWN0JGtleXMkbWFwID0gT2JqZWN0LmtleXMocmdiQ29sb3IpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoYW5uZWwgPSByZ2JDb2xvcltrZXldIC8gMjU1O1xuICAgIHJldHVybiBjaGFubmVsIDw9IDAuMDM5MjggPyBjaGFubmVsIC8gMTIuOTIgOiBNYXRoLnBvdygoY2hhbm5lbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9KSxcbiAgICAgIHIgPSBfT2JqZWN0JGtleXMkbWFwWzBdLFxuICAgICAgZyA9IF9PYmplY3Qka2V5cyRtYXBbMV0sXG4gICAgICBiID0gX09iamVjdCRrZXlzJG1hcFsyXTtcblxuICByZXR1cm4gcGFyc2VGbG9hdCgoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiKS50b0ZpeGVkKDMpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250cmFzdCByYXRpbyBiZXR3ZWVuIHR3byBjb2xvcnMgYmFzZWQgb25cbiAqIFtXMydzIHJlY29tbWVuZGVkIGVxdWF0aW9uIGZvciBjYWxjdWxhdGluZyBjb250cmFzdF0oaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNvbnRyYXN0UmF0aW8gPSBnZXRDb250cmFzdCgnIzQ0NCcsICcjZmZmJyk7XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q29udHJhc3QoY29sb3IxLCBjb2xvcjIpIHtcbiAgdmFyIGx1bWluYW5jZTEgPSBnZXRMdW1pbmFuY2UoY29sb3IxKTtcbiAgdmFyIGx1bWluYW5jZTIgPSBnZXRMdW1pbmFuY2UoY29sb3IyKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoKGx1bWluYW5jZTEgPiBsdW1pbmFuY2UyID8gKGx1bWluYW5jZTEgKyAwLjA1KSAvIChsdW1pbmFuY2UyICsgMC4wNSkgOiAobHVtaW5hbmNlMiArIDAuMDUpIC8gKGx1bWluYW5jZTEgKyAwLjA1KSkudG9GaXhlZCgyKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNvbG9yIHRvIGEgZ3JheXNjYWxlLCBieSByZWR1Y2luZyBpdHMgc2F0dXJhdGlvbiB0byAwLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdyYXlzY2FsZSgnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2dyYXlzY2FsZSgnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjOTk5XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNTMsMTUzLDE1MywwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZ3JheXNjYWxlKGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBzYXR1cmF0aW9uOiAwXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGBoc2xgIG9yIGBoc2xhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBoc2xUb0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pLFxuICogICBiYWNrZ3JvdW5kOiBoc2xUb0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtoc2xUb0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtoc2xUb0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzAwZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTc5LDI1LDI1LDAuNzIpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbFRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbG9yLmh1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLnNhdHVyYXRpb24gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5saWdodG5lc3MgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGNvbG9yLmFscGhhICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBoc2xhKHtcbiAgICAgICAgaHVlOiBjb2xvci5odWUsXG4gICAgICAgIHNhdHVyYXRpb246IGNvbG9yLnNhdHVyYXRpb24sXG4gICAgICAgIGxpZ2h0bmVzczogY29sb3IubGlnaHRuZXNzLFxuICAgICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBoc2woe1xuICAgICAgaHVlOiBjb2xvci5odWUsXG4gICAgICBzYXR1cmF0aW9uOiBjb2xvci5zYXR1cmF0aW9uLFxuICAgICAgbGlnaHRuZXNzOiBjb2xvci5saWdodG5lc3NcbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ1KTtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIHZhbHVlcyBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGludmVydCgnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2ludmVydCgnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzMzMzI5YlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTU0LDE1NSw1MCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gaW52ZXJ0KGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yOyAvLyBwYXJzZSBjb2xvciBzdHJpbmcgdG8gcmdiXG5cbiAgdmFyIHZhbHVlID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCB2YWx1ZSwge1xuICAgIHJlZDogMjU1IC0gdmFsdWUucmVkLFxuICAgIGdyZWVuOiAyNTUgLSB2YWx1ZS5ncmVlbixcbiAgICBibHVlOiAyNTUgLSB2YWx1ZS5ibHVlXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgbGlnaHRlbmVkIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGxpZ2h0ZW4oMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBsaWdodGVuKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7bGlnaHRlbigwLjIsICcjRkZDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2xpZ2h0ZW4oJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNlNWU2YjFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyOSwyMzAsMTc3LDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBsaWdodGVuKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBsaWdodG5lc3M6IGd1YXJkKDAsIDEsIGhzbENvbG9yLmxpZ2h0bmVzcyArIHBhcnNlRmxvYXQoYW1vdW50KSlcbiAgfSkpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZExpZ2h0ZW4gPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4obGlnaHRlbik7XG52YXIgY3VycmllZExpZ2h0ZW4kMSA9IGN1cnJpZWRMaWdodGVuO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggY29udHJhc3QgZ3VpZGVsaW5lcyBoYXZlIGJlZW4gbWV0IGZvciB0d28gY29sb3JzLlxuICogQmFzZWQgb24gdGhlIFtjb250cmFzdCBjYWxjdWxhdGlvbnMgcmVjb21tZW5kZWQgYnkgVzNdKGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvV0NBRzIxL1VuZGVyc3RhbmRpbmcvY29udHJhc3QtZW5oYW5jZWQuaHRtbCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNjb3JlcyA9IG1lZXRzQ29udHJhc3RHdWlkZWxpbmVzKCcjNDQ0JywgJyNmZmYnKTtcbiAqL1xuZnVuY3Rpb24gbWVldHNDb250cmFzdEd1aWRlbGluZXMoY29sb3IxLCBjb2xvcjIpIHtcbiAgdmFyIGNvbnRyYXN0UmF0aW8gPSBnZXRDb250cmFzdChjb2xvcjEsIGNvbG9yMik7XG4gIHJldHVybiB7XG4gICAgQUE6IGNvbnRyYXN0UmF0aW8gPj0gNC41LFxuICAgIEFBTGFyZ2U6IGNvbnRyYXN0UmF0aW8gPj0gMyxcbiAgICBBQUE6IGNvbnRyYXN0UmF0aW8gPj0gNyxcbiAgICBBQUFMYXJnZTogY29udHJhc3RSYXRpbyA+PSA0LjVcbiAgfTtcbn1cblxuLyoqXG4gKiBNaXhlcyB0aGUgdHdvIHByb3ZpZGVkIGNvbG9ycyB0b2dldGhlciBieSBjYWxjdWxhdGluZyB0aGUgYXZlcmFnZSBvZiBlYWNoIG9mIHRoZSBSR0IgY29tcG9uZW50cyB3ZWlnaHRlZCB0byB0aGUgZmlyc3QgY29sb3IgYnkgdGhlIHByb3ZpZGVkIHdlaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBtaXgoMC41LCAnI2YwMCcsICcjMDBmJylcbiAqICAgYmFja2dyb3VuZDogbWl4KDAuMjUsICcjZjAwJywgJyMwMGYnKVxuICogICBiYWNrZ3JvdW5kOiBtaXgoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC41KScsICcjMDBmJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHttaXgoMC41LCAnI2YwMCcsICcjMDBmJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke21peCgwLjI1LCAnI2YwMCcsICcjMDBmJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke21peCgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJywgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiM3ZjAwN2ZcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjM2YwMGJmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSg2MywgMCwgMTkxLCAwLjc1KVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIG1peCh3ZWlnaHQsIGNvbG9yLCBvdGhlckNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIG90aGVyQ29sb3I7XG4gIGlmIChvdGhlckNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIGlmICh3ZWlnaHQgPT09IDApIHJldHVybiBvdGhlckNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IxID0gcGFyc2VUb1JnYihjb2xvcik7XG5cbiAgdmFyIGNvbG9yMSA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvcjEsIHtcbiAgICBhbHBoYTogdHlwZW9mIHBhcnNlZENvbG9yMS5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvcjEuYWxwaGEgOiAxXG4gIH0pO1xuXG4gIHZhciBwYXJzZWRDb2xvcjIgPSBwYXJzZVRvUmdiKG90aGVyQ29sb3IpO1xuXG4gIHZhciBjb2xvcjIgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IyLCB7XG4gICAgYWxwaGE6IHR5cGVvZiBwYXJzZWRDb2xvcjIuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IyLmFscGhhIDogMVxuICB9KTsgLy8gVGhlIGZvcm11bGEgaXMgY29waWVkIGZyb20gdGhlIG9yaWdpbmFsIFNhc3MgaW1wbGVtZW50YXRpb246XG4gIC8vIGh0dHA6Ly9zYXNzLWxhbmcuY29tL2RvY3VtZW50YXRpb24vU2Fzcy9TY3JpcHQvRnVuY3Rpb25zLmh0bWwjbWl4LWluc3RhbmNlX21ldGhvZFxuXG5cbiAgdmFyIGFscGhhRGVsdGEgPSBjb2xvcjEuYWxwaGEgLSBjb2xvcjIuYWxwaGE7XG4gIHZhciB4ID0gcGFyc2VGbG9hdCh3ZWlnaHQpICogMiAtIDE7XG4gIHZhciB5ID0geCAqIGFscGhhRGVsdGEgPT09IC0xID8geCA6IHggKyBhbHBoYURlbHRhO1xuICB2YXIgeiA9IDEgKyB4ICogYWxwaGFEZWx0YTtcbiAgdmFyIHdlaWdodDEgPSAoeSAvIHogKyAxKSAvIDIuMDtcbiAgdmFyIHdlaWdodDIgPSAxIC0gd2VpZ2h0MTtcbiAgdmFyIG1peGVkQ29sb3IgPSB7XG4gICAgcmVkOiBNYXRoLmZsb29yKGNvbG9yMS5yZWQgKiB3ZWlnaHQxICsgY29sb3IyLnJlZCAqIHdlaWdodDIpLFxuICAgIGdyZWVuOiBNYXRoLmZsb29yKGNvbG9yMS5ncmVlbiAqIHdlaWdodDEgKyBjb2xvcjIuZ3JlZW4gKiB3ZWlnaHQyKSxcbiAgICBibHVlOiBNYXRoLmZsb29yKGNvbG9yMS5ibHVlICogd2VpZ2h0MSArIGNvbG9yMi5ibHVlICogd2VpZ2h0MiksXG4gICAgYWxwaGE6IGNvbG9yMS5hbHBoYSAqIHBhcnNlRmxvYXQod2VpZ2h0KSArIGNvbG9yMi5hbHBoYSAqICgxIC0gcGFyc2VGbG9hdCh3ZWlnaHQpKVxuICB9O1xuICByZXR1cm4gcmdiYShtaXhlZENvbG9yKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRNaXggPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihtaXgpO1xudmFyIG1peCQxID0gY3VycmllZE1peDtcblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIG9wYWNpdHkgb2YgYSBjb2xvci4gSXRzIHJhbmdlIGZvciB0aGUgYW1vdW50IGlzIGJldHdlZW4gMCB0byAxLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBvcGFjaWZ5KDAuMSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45KScpO1xuICogICBiYWNrZ3JvdW5kOiBvcGFjaWZ5KDAuMiwgJ2hzbGEoMCwgMCUsIDEwMCUsIDAuNSknKSxcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjIpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7b3BhY2lmeSgwLjEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7b3BhY2lmeSgwLjIsICdoc2xhKDAsIDAlLCAxMDAlLCAwLjUpJyl9LFxuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC4yKScpfSxcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDI1NSwyNTUsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDAsMCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gb3BhY2lmeShhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGFscGhhID0gdHlwZW9mIHBhcnNlZENvbG9yLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yLmFscGhhIDogMTtcblxuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwICsgcGFyc2VGbG9hdChhbW91bnQpICogMTAwKSAvIDEwMClcbiAgfSk7XG5cbiAgcmV0dXJuIHJnYmEoY29sb3JXaXRoQWxwaGEpO1xufSAvLyBwcmV0dGllci1pZ25vcmVcblxuXG52YXIgY3VycmllZE9wYWNpZnkgPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4ob3BhY2lmeSk7XG52YXIgY3VycmllZE9wYWNpZnkkMSA9IGN1cnJpZWRPcGFjaWZ5O1xuXG52YXIgZGVmYXVsdFJldHVybklmTGlnaHRDb2xvciA9ICcjMDAwJztcbnZhciBkZWZhdWx0UmV0dXJuSWZEYXJrQ29sb3IgPSAnI2ZmZic7XG4vKipcbiAqIFJldHVybnMgYmxhY2sgb3Igd2hpdGUgKG9yIG9wdGlvbmFsIHBhc3NlZCBjb2xvcnMpIGZvciBiZXN0XG4gKiBjb250cmFzdCBkZXBlbmRpbmcgb24gdGhlIGx1bWlub3NpdHkgb2YgdGhlIGdpdmVuIGNvbG9yLlxuICogV2hlbiBwYXNzaW5nIGN1c3RvbSByZXR1cm4gY29sb3JzLCBzdHJpY3QgbW9kZSBlbnN1cmVzIHRoYXQgdGhlXG4gKiByZXR1cm4gY29sb3IgYWx3YXlzIG1lZXRzIG9yIGV4Y2VlZHMgV0NBRyBsZXZlbCBBQSBvciBncmVhdGVyLiBJZiB0aGlzIHRlc3RcbiAqIGZhaWxzLCB0aGUgZGVmYXVsdCByZXR1cm4gY29sb3IgKGJsYWNrIG9yIHdoaXRlKSBpcyByZXR1cm5lZCBpbiBwbGFjZSBvZiB0aGVcbiAqIGN1c3RvbSByZXR1cm4gY29sb3IuIFlvdSBjYW4gb3B0aW9uYWxseSB0dXJuIG9mZiBzdHJpY3QgbW9kZS5cbiAqXG4gKiBGb2xsb3dzIFtXM0Mgc3BlY3MgZm9yIHJlYWRhYmlsaXR5XShodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxOC5odG1sKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignIzAwMCcpLFxuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4JyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKSxcbiAqICAgY29sb3I6IHJlYWRhYmxlQ29sb3IoJ3JlZCcsICcjMzMzJywgJyNkZGQnLCB0cnVlKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCcjMDAwJyl9O1xuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCdibGFjaycsICcjMDAxJywgJyNmZjgnKX07XG4gKiAgIGNvbG9yOiAke3JlYWRhYmxlQ29sb3IoJ3doaXRlJywgJyMwMDEnLCAnI2ZmOCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcigncmVkJywgJyMzMzMnLCAnI2RkZCcsIHRydWUpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgY29sb3I6IFwiI2ZmZlwiO1xuICogICBjb2xvcjogXCIjZmY4XCI7XG4gKiAgIGNvbG9yOiBcIiMwMDFcIjtcbiAqICAgY29sb3I6IFwiIzAwMFwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHJlYWRhYmxlQ29sb3IoY29sb3IsIHJldHVybklmTGlnaHRDb2xvciwgcmV0dXJuSWZEYXJrQ29sb3IsIHN0cmljdCkge1xuICBpZiAocmV0dXJuSWZMaWdodENvbG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm5JZkxpZ2h0Q29sb3IgPSBkZWZhdWx0UmV0dXJuSWZMaWdodENvbG9yO1xuICB9XG5cbiAgaWYgKHJldHVybklmRGFya0NvbG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm5JZkRhcmtDb2xvciA9IGRlZmF1bHRSZXR1cm5JZkRhcmtDb2xvcjtcbiAgfVxuXG4gIGlmIChzdHJpY3QgPT09IHZvaWQgMCkge1xuICAgIHN0cmljdCA9IHRydWU7XG4gIH1cblxuICB2YXIgaXNDb2xvckxpZ2h0ID0gZ2V0THVtaW5hbmNlKGNvbG9yKSA+IDAuMTc5O1xuICB2YXIgcHJlZmVycmVkUmV0dXJuQ29sb3IgPSBpc0NvbG9yTGlnaHQgPyByZXR1cm5JZkxpZ2h0Q29sb3IgOiByZXR1cm5JZkRhcmtDb2xvcjtcblxuICBpZiAoIXN0cmljdCB8fCBnZXRDb250cmFzdChjb2xvciwgcHJlZmVycmVkUmV0dXJuQ29sb3IpID49IDQuNSkge1xuICAgIHJldHVybiBwcmVmZXJyZWRSZXR1cm5Db2xvcjtcbiAgfVxuXG4gIHJldHVybiBpc0NvbG9yTGlnaHQgPyBkZWZhdWx0UmV0dXJuSWZMaWdodENvbG9yIDogZGVmYXVsdFJldHVybklmRGFya0NvbG9yO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdCB0byBhIGNvbG9yIHN0cmluZy5cbiAqIFRoaXMgdXRpbCBpcyB1c2VmdWwgaW4gY2FzZSB5b3Ugb25seSBrbm93IG9uIHJ1bnRpbWUgd2hpY2ggY29sb3Igb2JqZWN0IGlzXG4gKiB1c2VkLiBPdGhlcndpc2Ugd2UgcmVjb21tZW5kIHRvIHJlbHkgb24gYHJnYmAgb3IgYHJnYmFgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHJnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLFxuICogICBiYWNrZ3JvdW5kOiByZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiVG9Db2xvclN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmdiYSh7XG4gICAgICAgIHJlZDogY29sb3IucmVkLFxuICAgICAgICBncmVlbjogY29sb3IuZ3JlZW4sXG4gICAgICAgIGJsdWU6IGNvbG9yLmJsdWUsXG4gICAgICAgIGFscGhhOiBjb2xvci5hbHBoYVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJnYih7XG4gICAgICByZWQ6IGNvbG9yLnJlZCxcbiAgICAgIGdyZWVuOiBjb2xvci5ncmVlbixcbiAgICAgIGJsdWU6IGNvbG9yLmJsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ2KTtcbn1cblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGluY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2UwZTI1MFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI0LDIyNiw4MCwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIHNhdHVyYXRpb246IGd1YXJkKDAsIDEsIGhzbENvbG9yLnNhdHVyYXRpb24gKyBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTYXR1cmF0ZSA9IC8qI19fUFVSRV9fKi9jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzYXR1cmF0ZSk7XG52YXIgY3VycmllZFNhdHVyYXRlJDEgPSBjdXJyaWVkU2F0dXJhdGU7XG5cbi8qKlxuICogU2V0cyB0aGUgaHVlIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgaHVlIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAzNTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0SHVlKDQyLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoJzI0NCcsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRIdWUoNDIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSgnMjQ0JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjY2RhZTY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxMDcsMTAwLDIwNSwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2V0SHVlKGh1ZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGh1ZTogcGFyc2VGbG9hdChodWUpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTZXRIdWUgPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0SHVlKTtcbnZhciBjdXJyaWVkU2V0SHVlJDEgPSBjdXJyaWVkU2V0SHVlO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpZ2h0bmVzcyBvZiBhIGNvbG9yIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhlIGxpZ2h0bmVzcyByYW5nZSBjYW4gYmVcbiAqIGZyb20gMCBhbmQgMS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzZXRMaWdodG5lc3MoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRMaWdodG5lc3MoJzAuNzUnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0TGlnaHRuZXNzKDAuMiwgJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0TGlnaHRuZXNzKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjNGQ0ZDE5XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjMsMjI0LDE1OSwwLjcpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2V0TGlnaHRuZXNzKGxpZ2h0bmVzcywgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGxpZ2h0bmVzczogcGFyc2VGbG9hdChsaWdodG5lc3MpXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTZXRMaWdodG5lc3MgPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4oc2V0TGlnaHRuZXNzKTtcbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzJDEgPSBjdXJyaWVkU2V0TGlnaHRuZXNzO1xuXG4vKipcbiAqIFNldHMgdGhlIHNhdHVyYXRpb24gb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBzYXR1cmF0aW9uIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNldFNhdHVyYXRpb24oMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRTYXR1cmF0aW9uKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldFNhdHVyYXRpb24oMC4yLCAnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzZXRTYXR1cmF0aW9uKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYWRhZDg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjgsMjI5LDc2LDAuNylcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBzZXRTYXR1cmF0aW9uKHNhdHVyYXRpb24sIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBzYXR1cmF0aW9uOiBwYXJzZUZsb2F0KHNhdHVyYXRpb24pXG4gIH0pKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTZXRTYXR1cmF0aW9uID0gLyojX19QVVJFX18qL2N1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHNldFNhdHVyYXRpb24pO1xudmFyIGN1cnJpZWRTZXRTYXR1cmF0aW9uJDEgPSBjdXJyaWVkU2V0U2F0dXJhdGlvbjtcblxuLyoqXG4gKiBTaGFkZXMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCBibGFjay4gYHNoYWRlYCBjYW4gcHJvZHVjZVxuICogaHVlIHNoaWZ0cywgd2hlcmUgYXMgYGRhcmtlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNoYWRlKDAuMjUsICcjMDBmJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzaGFkZSgwLjI1LCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzAwMDAzZlwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHNoYWRlKHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gbWl4JDEocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigwLCAwLCAwKScsIGNvbG9yKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRTaGFkZSA9IC8qI19fUFVSRV9fKi9jdXJyeVxuLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi9cbihzaGFkZSk7XG52YXIgY3VycmllZFNoYWRlJDEgPSBjdXJyaWVkU2hhZGU7XG5cbi8qKlxuICogVGludHMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCB3aGl0ZS4gYHRpbnRgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgbGlnaHRlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRpbnQoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RpbnQoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiZmJmZmZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0aW50KHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gbWl4JDEocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigyNTUsIDI1NSwgMjU1KScsIGNvbG9yKTtcbn0gLy8gcHJldHRpZXItaWdub3JlXG5cblxudmFyIGN1cnJpZWRUaW50ID0gLyojX19QVVJFX18qL2N1cnJ5XG4vKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqL1xuKHRpbnQpO1xudmFyIGN1cnJpZWRUaW50JDEgPSBjdXJyaWVkVGludDtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIG9wYWNpdHkgb2YgYSBjb2xvci4gSXRzIHJhbmdlIGZvciB0aGUgYW1vdW50IGlzIGJldHdlZW4gMCB0byAxLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgwLjEsICcjZmZmJyksXG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKDAuMiwgJ2hzbCgwLCAwJSwgMTAwJSknKSxcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC44KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKDAuMSwgJyNmZmYnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoMC4yLCAnaHNsKDAsIDAlLCAxMDAlKScpfTtcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgnMC41JywgJ3JnYmEoMjU1LCAwLCAwLCAwLjgpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOSlcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOClcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwwLDAsMC4zKVwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zcGFyZW50aXplKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgYWxwaGEgPSB0eXBlb2YgcGFyc2VkQ29sb3IuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IuYWxwaGEgOiAxO1xuXG4gIHZhciBjb2xvcldpdGhBbHBoYSA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvciwge1xuICAgIGFscGhhOiBndWFyZCgwLCAxLCArKGFscGhhICogMTAwIC0gcGFyc2VGbG9hdChhbW91bnQpICogMTAwKS50b0ZpeGVkKDIpIC8gMTAwKVxuICB9KTtcblxuICByZXR1cm4gcmdiYShjb2xvcldpdGhBbHBoYSk7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbnZhciBjdXJyaWVkVHJhbnNwYXJlbnRpemUgPSAvKiNfX1BVUkVfXyovY3Vycnlcbi8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovXG4odHJhbnNwYXJlbnRpemUpO1xudmFyIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSQxID0gY3VycmllZFRyYW5zcGFyZW50aXplO1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgZWFzaWx5IHNldHRpbmcgdGhlIGFuaW1hdGlvbiBwcm9wZXJ0eS4gQWxsb3dzIGVpdGhlciBtdWx0aXBsZSBhcnJheXMgd2l0aCBhbmltYXRpb25zXG4gKiBvciBhIHNpbmdsZSBhbmltYXRpb24gc3ByZWFkIG92ZXIgdGhlIGFyZ3VtZW50cy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbihbJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCddLCBbJ2NvbG9yY2hhbmdlJywgJzJzJ10pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YW5pbWF0aW9uKFsncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0J10sIFsnY29sb3JjaGFuZ2UnLCAnMnMnXSl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdhbmltYXRpb24nOiAncm90YXRlIDFzIGVhc2UtaW4tb3V0LCBjb2xvcmNoYW5nZSAycydcbiAqIH1cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbigncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHthbmltYXRpb24oJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYW5pbWF0aW9uJzogJ3JvdGF0ZSAxcyBlYXNlLWluLW91dCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgLy8gQWxsb3cgc2luZ2xlIG9yIG11bHRpcGxlIGFuaW1hdGlvbnMgcGFzc2VkXG4gIHZhciBtdWx0aU1vZGUgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pO1xuXG4gIGlmICghbXVsdGlNb2RlICYmIGFyZ3MubGVuZ3RoID4gOCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY0KTtcbiAgfVxuXG4gIHZhciBjb2RlID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChtdWx0aU1vZGUgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSB8fCAhbXVsdGlNb2RlICYmIEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjUpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpID8gYXJnLmpvaW4oJyAnKSA6IGFyZztcbiAgfSkuam9pbignLCAnKTtcbiAgcmV0dXJuIHtcbiAgICBhbmltYXRpb246IGNvZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYmFja2dyb3VuZEltYWdlIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIHNpbmdsZSBiYWNrZ3JvdW5kIHN0YXRlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJhY2tncm91bmRJbWFnZXMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JhY2tncm91bmRJbWFnZXMoJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKScsICdsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiksIGxpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKSdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYmFja2dyb3VuZEltYWdlcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZEltYWdlOiBwcm9wZXJ0aWVzLmpvaW4oJywgJylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYmFja2dyb3VuZCB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScsICdjZW50ZXIgbm8tcmVwZWF0JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kcygndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpJywgJ2xpbmVhci1ncmFkaWVudChyZWQsIGdyZWVuKScsICdjZW50ZXIgbm8tcmVwZWF0Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kJzogJ3VybChcIi9pbWFnZS9iYWNrZ3JvdW5kLmpwZ1wiKSwgbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pLCBjZW50ZXIgbm8tcmVwZWF0J1xuICogfVxuICovXG5mdW5jdGlvbiBiYWNrZ3JvdW5kcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZDogcHJvcGVydGllcy5qb2luKCcsICcpXG4gIH07XG59XG5cbnZhciBzaWRlTWFwID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbi8qKlxuICogU2hvcnRoYW5kIGZvciB0aGUgYm9yZGVyIHByb3BlcnR5IHRoYXQgc3BsaXRzIG91dCBpbmRpdmlkdWFsIHByb3BlcnRpZXMgZm9yIHVzZSB3aXRoIHRvb2xzIGxpa2UgRmVsYSBhbmQgU3R5bGV0cm9uLiBBIHNpZGUga2V5d29yZCBjYW4gb3B0aW9uYWxseSBiZSBwYXNzZWQgdG8gdGFyZ2V0IG9ubHkgb25lIHNpZGUncyBib3JkZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXIoJzFweCcsICdzb2xpZCcsICdyZWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlcignMXB4JywgJ3NvbGlkJywgJ3JlZCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlcldpZHRoJzogYDFweGAsXG4gKiB9XG4gKlxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXIoJ3RvcCcsICcxcHgnLCAnc29saWQnLCAncmVkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXIoJ3RvcCcsICcxcHgnLCAnc29saWQnLCAncmVkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJUb3BDb2xvcic6ICdyZWQnLFxuICogICAnYm9yZGVyVG9wU3R5bGUnOiAnc29saWQnLFxuICogICAnYm9yZGVyVG9wV2lkdGgnOiBgMXB4YCxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBib3JkZXIoc2lkZUtleXdvcmQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2lkZUtleXdvcmQgPT09ICdzdHJpbmcnICYmIHNpZGVNYXAuaW5kZXhPZihzaWRlS2V5d29yZCkgPj0gMCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltcImJvcmRlclwiICsgY2FwaXRhbGl6ZVN0cmluZyhzaWRlS2V5d29yZCkgKyBcIldpZHRoXCJdID0gdmFsdWVzWzBdLCBfcmVmW1wiYm9yZGVyXCIgKyBjYXBpdGFsaXplU3RyaW5nKHNpZGVLZXl3b3JkKSArIFwiU3R5bGVcIl0gPSB2YWx1ZXNbMV0sIF9yZWZbXCJib3JkZXJcIiArIGNhcGl0YWxpemVTdHJpbmcoc2lkZUtleXdvcmQpICsgXCJDb2xvclwiXSA9IHZhbHVlc1syXSwgX3JlZjtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZXMudW5zaGlmdChzaWRlS2V5d29yZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlcldpZHRoOiB2YWx1ZXNbMF0sXG4gICAgICBib3JkZXJTdHlsZTogdmFsdWVzWzFdLFxuICAgICAgYm9yZGVyQ29sb3I6IHZhbHVlc1syXVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclJpZ2h0Q29sb3InOiAnZ3JlZW4nLFxuICogICAnYm9yZGVyQm90dG9tQ29sb3InOiAnYmx1ZScsXG4gKiAgICdib3JkZXJMZWZ0Q29sb3InOiAneWVsbG93J1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJDb2xvcigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyQ29sb3InXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhIHZhbHVlIGZvciBzaWRlIGFuZCBhIHZhbHVlIGZvciByYWRpdXMgYW5kIGFwcGxpZXMgdGhlIHJhZGl1cyB2YWx1ZSB0byBib3RoIGNvcm5lcnMgb2YgdGhlIHNpZGUuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJSYWRpdXMoJ3RvcCcsICc1cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclJhZGl1cygndG9wJywgJzVweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnOiAnNXB4JyxcbiAqICAgJ2JvcmRlclRvcExlZnRSYWRpdXMnOiAnNXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyUmFkaXVzKHNpZGUsIHJhZGl1cykge1xuICB2YXIgdXBwZXJjYXNlU2lkZSA9IGNhcGl0YWxpemVTdHJpbmcoc2lkZSk7XG5cbiAgaWYgKCFyYWRpdXMgJiYgcmFkaXVzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjIpO1xuICB9XG5cbiAgaWYgKHVwcGVyY2FzZVNpZGUgPT09ICdUb3AnIHx8IHVwcGVyY2FzZVNpZGUgPT09ICdCb3R0b20nKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1wiYm9yZGVyXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJSaWdodFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZltcImJvcmRlclwiICsgdXBwZXJjYXNlU2lkZSArIFwiTGVmdFJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjtcbiAgfVxuXG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnTGVmdCcgfHwgdXBwZXJjYXNlU2lkZSA9PT0gJ1JpZ2h0Jykge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHJldHVybiBfcmVmMiA9IHt9LCBfcmVmMltcImJvcmRlclRvcFwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMltcImJvcmRlckJvdHRvbVwiICsgdXBwZXJjYXNlU2lkZSArIFwiUmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmMjtcbiAgfVxuXG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYzKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyU3R5bGUoJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFN0eWxlJzogJ3NvbGlkJyxcbiAqICAgJ2JvcmRlclJpZ2h0U3R5bGUnOiAnZGFzaGVkJyxcbiAqICAgJ2JvcmRlckJvdHRvbVN0eWxlJzogJ2RvdHRlZCcsXG4gKiAgICdib3JkZXJMZWZ0U3R5bGUnOiAnZG91YmxlJ1xuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJTdHlsZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyU3R5bGUnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcldpZHRoKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wV2lkdGgnOiAnMTJweCcsXG4gKiAgICdib3JkZXJSaWdodFdpZHRoJzogJzI0cHgnLFxuICogICAnYm9yZGVyQm90dG9tV2lkdGgnOiAnMzZweCcsXG4gKiAgICdib3JkZXJMZWZ0V2lkdGgnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyV2lkdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ2JvcmRlcldpZHRoJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGUpIHtcbiAgdmFyIHN0YXRlU3VmZml4ID0gc3RhdGUgPyBcIjpcIiArIHN0YXRlIDogJyc7XG4gIHJldHVybiB0ZW1wbGF0ZShzdGF0ZVN1ZmZpeCk7XG59XG4vKipcbiAqIEZ1bmN0aW9uIGhlbHBlciB0aGF0IGFkZHMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRvIGEgdGVtcGxhdGUgb2Ygc2VsZWN0b3JzLiBVc2VkIGluIHRleHRJbnB1dHMgYW5kIGJ1dHRvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSwgc3RhdGVNYXApIHtcbiAgaWYgKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjcpO1xuICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBudWxsKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YXRlTWFwICYmIHN0YXRlTWFwLmluZGV4T2Yoc3RhdGVzW2ldKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY4KTtcbiAgICB9XG5cbiAgICBzZWxlY3RvcnMucHVzaChnZW5lcmF0ZVNlbGVjdG9ycyh0ZW1wbGF0ZSwgc3RhdGVzW2ldKSk7XG4gIH1cblxuICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuXG52YXIgc3RhdGVNYXAkMSA9IFt1bmRlZmluZWQsIG51bGwsICdhY3RpdmUnLCAnZm9jdXMnLCAnaG92ZXInXTtcblxuZnVuY3Rpb24gdGVtcGxhdGUkMShzdGF0ZSkge1xuICByZXR1cm4gXCJidXR0b25cIiArIHN0YXRlICsgXCIsXFxuICBpbnB1dFt0eXBlPVxcXCJidXR0b25cXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcInJlc2V0XFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICBpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXVwiICsgc3RhdGU7XG59XG4vKipcbiAqIFBvcHVsYXRlcyBzZWxlY3RvcnMgdGhhdCB0YXJnZXQgYWxsIGJ1dHRvbnMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbYnV0dG9ucygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHtidXR0b25zKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2J1dHRvbjphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XCJidXR0b25cIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cXFwic3VibWl0XFxcIl06YWN0aXZlOiB7XG4gKiAgICdib3JkZXInOiAnbm9uZSdcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1dHRvbnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGF0ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RhdGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUkMSwgc3RhdGVNYXAkMSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLm1hcmdpbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7bWFyZ2luKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdtYXJnaW5Ub3AnOiAnMTJweCcsXG4gKiAgICdtYXJnaW5SaWdodCc6ICcyNHB4JyxcbiAqICAgJ21hcmdpbkJvdHRvbSc6ICczNnB4JyxcbiAqICAgJ21hcmdpbkxlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbWFyZ2luKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWydtYXJnaW4nXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBhZGRpbmcoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3BhZGRpbmcoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3BhZGRpbmdUb3AnOiAnMTJweCcsXG4gKiAgICdwYWRkaW5nUmlnaHQnOiAnMjRweCcsXG4gKiAgICdwYWRkaW5nQm90dG9tJzogJzM2cHgnLFxuICogICAncGFkZGluZ0xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcGFkZGluZygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsncGFkZGluZyddLmNvbmNhdCh2YWx1ZXMpKTtcbn1cblxudmFyIHBvc2l0aW9uTWFwID0gWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGF0aWMnLCAnc3RpY2t5J107XG4vKipcbiAqIFNob3J0aGFuZCBhY2NlcHRzIHVwIHRvIGZpdmUgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLiBUaGUgZmlyc3QgdmFsdWUgY2FuIG9wdGlvbmFsbHkgYmUgYSBwb3NpdGlvbiBrZXl3b3JkLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucG9zaXRpb24oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3Bvc2l0aW9uKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICd0b3AnOiAnMTJweCcsXG4gKiAgICdyaWdodCc6ICcyNHB4JyxcbiAqICAgJ2JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ2xlZnQnOiAnNDhweCdcbiAqIH1cbiAqXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBvc2l0aW9uKCdhYnNvbHV0ZScsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwb3NpdGlvbignYWJzb2x1dGUnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAndG9wJzogJzEycHgnLFxuICogICAncmlnaHQnOiAnMjRweCcsXG4gKiAgICdib3R0b20nOiAnMzZweCcsXG4gKiAgICdsZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gcG9zaXRpb24oZmlyc3RWYWx1ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uTWFwLmluZGV4T2YoZmlyc3RWYWx1ZSkgPj0gMCAmJiBmaXJzdFZhbHVlKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWycnXS5jb25jYXQodmFsdWVzKSksIHtcbiAgICAgIHBvc2l0aW9uOiBmaXJzdFZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJycsIGZpcnN0VmFsdWVdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0byBzZXQgdGhlIGhlaWdodCBhbmQgd2lkdGggcHJvcGVydGllcyBpbiBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5zaXplKCczMDBweCcsICcyNTBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7c2l6ZSgnMzAwcHgnLCAnMjUwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2hlaWdodCc6ICczMDBweCcsXG4gKiAgICd3aWR0aCc6ICcyNTBweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNpemUoaGVpZ2h0LCB3aWR0aCkge1xuICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgIHdpZHRoID0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGhcbiAgfTtcbn1cblxudmFyIHN0YXRlTWFwID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2FjdGl2ZScsICdmb2N1cycsICdob3ZlciddO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdGF0ZSkge1xuICByZXR1cm4gXCJpbnB1dFt0eXBlPVxcXCJjb2xvclxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRlXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcImRhdGV0aW1lXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcImRhdGV0aW1lLWxvY2FsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcImVtYWlsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcIm1vbnRoXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcIm51bWJlclxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJwYXNzd29yZFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJzZWFyY2hcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidGVsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidGltZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ1cmxcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwid2Vla1xcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dDpub3QoW3R5cGVdKVwiICsgc3RhdGUgKyBcIixcXG4gICAgdGV4dGFyZWFcIiArIHN0YXRlO1xufVxuLyoqXG4gKiBQb3B1bGF0ZXMgc2VsZWN0b3JzIHRoYXQgdGFyZ2V0IGFsbCB0ZXh0IGlucHV0cy4gWW91IGNhbiBwYXNzIG9wdGlvbmFsIHN0YXRlcyB0byBhcHBlbmQgdG8gdGhlIHNlbGVjdG9ycy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIFt0ZXh0SW5wdXRzKCdhY3RpdmUnKV06IHtcbiAqICAgICAnYm9yZGVyJzogJ25vbmUnXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgPiAke3RleHRJbnB1dHMoJ2FjdGl2ZScpfSB7XG4gKiAgICAgYm9yZGVyOiBub25lO1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqICAnaW5wdXRbdHlwZT1cImNvbG9yXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZGF0ZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGV0aW1lXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJlbWFpbFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIm1vbnRoXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwibnVtYmVyXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwicGFzc3dvcmRcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJzZWFyY2hcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ0ZWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ0ZXh0XCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGltZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInVybFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIndlZWtcIl06YWN0aXZlLFxuICogIGlucHV0Om5vdChbdHlwZV0pOmFjdGl2ZSxcbiAqICB0ZXh0YXJlYTphY3RpdmUnOiB7XG4gKiAgICdib3JkZXInOiAnbm9uZSdcbiAqIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRleHRJbnB1dHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGF0ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RhdGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUsIHN0YXRlTWFwKTtcbn1cblxuLyoqXG4gKiBBY2NlcHRzIGFueSBudW1iZXIgb2YgdHJhbnNpdGlvbiB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgdHJhbnNpdGlvbiBzdGF0ZW1lbnQuIFlvdSBtYXkgYWxzbyBwYXNzIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIGFwcGx5IHRoZSBzYW1lIHRyYW5zaXRpb24gdmFsdWVzIHRvIChzZWNvbmQgcGFyYW1ldGVyKS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKSxcbiAqICAgLi4udHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKX07XG4gKiAgICR7dHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKSx9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAndHJhbnNpdGlvbic6ICdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcywgd2lkdGggMi4wcyBlYXNlLWluIDJzJ1xuICogICAndHJhbnNpdGlvbic6ICdjb2xvciAyLjBzIGVhc2UtaW4gMnMsIGJhY2tncm91bmQtY29sb3IgMi4wcyBlYXNlLWluIDJzJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9ucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXNbMF0pICYmIHByb3BlcnRpZXMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1sxXTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2MSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25zU3RyaW5nID0gcHJvcGVydGllc1swXS5tYXAoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkgKyBcIiBcIiArIHZhbHVlO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zU3RyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbjogcHJvcGVydGllcy5qb2luKCcsICcpXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgeyBjdXJyaWVkQWRqdXN0SHVlJDEgYXMgYWRqdXN0SHVlLCBhbmltYXRpb24sIGJhY2tncm91bmRJbWFnZXMsIGJhY2tncm91bmRzLCBiZXR3ZWVuLCBib3JkZXIsIGJvcmRlckNvbG9yLCBib3JkZXJSYWRpdXMsIGJvcmRlclN0eWxlLCBib3JkZXJXaWR0aCwgYnV0dG9ucywgY2xlYXJGaXgsIGNvbXBsZW1lbnQsIGNvdmVyLCBjc3NWYXIsIGN1cnJpZWREYXJrZW4kMSBhcyBkYXJrZW4sIGN1cnJpZWREZXNhdHVyYXRlJDEgYXMgZGVzYXR1cmF0ZSwgZGlyZWN0aW9uYWxQcm9wZXJ0eSwgZWFzZUluLCBlYXNlSW5PdXQsIGVhc2VPdXQsIGVsbGlwc2lzLCBlbSQxIGFzIGVtLCBmbHVpZFJhbmdlLCBmb250RmFjZSwgZ2V0Q29udHJhc3QsIGdldEx1bWluYW5jZSwgZ2V0VmFsdWVBbmRVbml0LCBncmF5c2NhbGUsIGhpRFBJLCBoaWRlVGV4dCwgaGlkZVZpc3VhbGx5LCBoc2wsIGhzbFRvQ29sb3JTdHJpbmcsIGhzbGEsIGltcG9ydGFudCwgaW52ZXJ0LCBjdXJyaWVkTGlnaHRlbiQxIGFzIGxpZ2h0ZW4sIGxpbmVhckdyYWRpZW50LCBtYXJnaW4sIG1hdGgsIG1lZXRzQ29udHJhc3RHdWlkZWxpbmVzLCBtaXgkMSBhcyBtaXgsIG1vZHVsYXJTY2FsZSwgbm9ybWFsaXplLCBjdXJyaWVkT3BhY2lmeSQxIGFzIG9wYWNpZnksIHBhZGRpbmcsIHBhcnNlVG9Ic2wsIHBhcnNlVG9SZ2IsIHBvc2l0aW9uLCByYWRpYWxHcmFkaWVudCwgcmVhZGFibGVDb2xvciwgcmVtJDEgYXMgcmVtLCByZW1Ub1B4LCByZXRpbmFJbWFnZSwgcmdiLCByZ2JUb0NvbG9yU3RyaW5nLCByZ2JhLCBjdXJyaWVkU2F0dXJhdGUkMSBhcyBzYXR1cmF0ZSwgY3VycmllZFNldEh1ZSQxIGFzIHNldEh1ZSwgY3VycmllZFNldExpZ2h0bmVzcyQxIGFzIHNldExpZ2h0bmVzcywgY3VycmllZFNldFNhdHVyYXRpb24kMSBhcyBzZXRTYXR1cmF0aW9uLCBjdXJyaWVkU2hhZGUkMSBhcyBzaGFkZSwgc2l6ZSwgc3RyaXBVbml0LCB0ZXh0SW5wdXRzLCB0aW1pbmdGdW5jdGlvbnMsIGN1cnJpZWRUaW50JDEgYXMgdGludCwgdG9Db2xvclN0cmluZywgdHJhbnNpdGlvbnMsIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSQxIGFzIHRyYW5zcGFyZW50aXplLCB0cmlhbmdsZSwgd29yZFdyYXAgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfaW5oZXJpdHNMb29zZSIsIl93cmFwTmF0aXZlU3VwZXIiLCJfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UiLCJsYXN0IiwiX3JlZiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm5lZ2F0aW9uIiwiYSIsImFkZGl0aW9uIiwiYiIsInN1YnRyYWN0aW9uIiwibXVsdGlwbGljYXRpb24iLCJkaXZpc2lvbiIsIm1heCIsIk1hdGgiLCJhcHBseSIsIm1pbiIsImNvbW1hIiwiQXJyYXkiLCJvZiIsImRlZmF1bHRTeW1ib2xzIiwic3ltYm9scyIsImluZml4Iiwic3ltYm9sIiwiZiIsIm5vdGF0aW9uIiwicHJlY2VkZW5jZSIsInJpZ2h0VG9MZWZ0IiwiYXJnQ291bnQiLCJyZWdTeW1ib2wiLCJwcmVmaXgiLCJwb3N0Zml4IiwiZnVuYyIsImRlZmF1bHRTeW1ib2xNYXAiLCJFUlJPUlMiLCJmb3JtYXQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJjIiwicHVzaCIsImZvckVhY2giLCJkIiwicmVwbGFjZSIsIlBvbGlzaGVkRXJyb3IiLCJfRXJyb3IiLCJjb2RlIiwiX3RoaXMiLCJwcm9jZXNzIiwiY2FsbCIsIl9sZW4yIiwiX2tleTIiLCJjb25jYXQiLCJFcnJvciIsInVuaXRSZWdFeHAiLCJtZXJnZVN5bWJvbE1hcHMiLCJhZGRpdGlvbmFsU3ltYm9scyIsInN5bWJvbE1hcCIsImV4ZWMiLCJvcGVyYXRvcnMiLCJ2YWx1ZXMiLCJvcCIsInBvcCIsInNwbGljZSIsImNhbGN1bGF0ZSIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhdHRlcm4iLCJSZWdFeHAiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5Iiwic29ydCIsInZhbCIsImpvaW4iLCJsYXN0SW5kZXgiLCJhZnRlclZhbHVlIiwiX3JlZjIiLCJ0b2tlbiIsImJhZCIsIm5vdE51bWJlciIsIm5vdE5ld1ZhbHVlIiwibm90QWZ0ZXJWYWx1ZSIsImluZGV4IiwiY3VyciIsInByZXYiLCJyZXZlcnNlU3RyaW5nIiwic3RyIiwic3BsaXQiLCJyZXZlcnNlIiwibWF0aCIsImZvcm11bGEiLCJyZXZlcnNlZEZvcm11bGEiLCJmb3JtdWxhTWF0Y2giLCJldmVyeSIsInVuaXQiLCJjbGVhbkZvcm11bGEiLCJjc3NWYXJpYWJsZVJlZ2V4IiwiY3NzVmFyIiwiY3NzVmFyaWFibGUiLCJkZWZhdWx0VmFsdWUiLCJ2YXJpYWJsZVZhbHVlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRyaW0iLCJjYXBpdGFsaXplU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInBvc2l0aW9uTWFwJDEiLCJnZW5lcmF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJwb3NpdGlvbiIsInRvTG93ZXJDYXNlIiwic3BsaXRQcm9wZXJ0eSIsInJlZHVjZSIsImFjYyIsImpvaW5lZFByb3BlcnR5IiwiZ2VuZXJhdGVTdHlsZXMiLCJ2YWx1ZXNXaXRoRGVmYXVsdHMiLCJzdHlsZXMiLCJpIiwiZGlyZWN0aW9uYWxQcm9wZXJ0eSIsImZpcnN0VmFsdWUiLCJfdmFsdWVzJCIsInNlY29uZFZhbHVlIiwiX3ZhbHVlcyQyIiwidGhpcmRWYWx1ZSIsIl92YWx1ZXMkMyIsImZvdXJ0aFZhbHVlIiwiZW5kc1dpdGgiLCJzdWZmaXgiLCJzdWJzdHIiLCJjc3NSZWdleCQxIiwic3RyaXBVbml0IiwidmFsdWUiLCJtYXRjaGVkVmFsdWUiLCJwYXJzZUZsb2F0IiwicHh0b0ZhY3RvcnkiLCJ0byIsInB4dmFsIiwiYmFzZSIsIm5ld1B4dmFsIiwibmV3QmFzZSIsInBpeGVsc3RvIiwiZW0iLCJlbSQxIiwiY3NzUmVnZXgiLCJnZXRWYWx1ZUFuZFVuaXQiLCJpbXBvcnRhbnQiLCJzdHlsZUJsb2NrIiwicnVsZXMiLCJuZXdTdHlsZUJsb2NrIiwiaW5kZXhPZiIsInJhdGlvTmFtZXMiLCJtaW5vclNlY29uZCIsIm1ham9yU2Vjb25kIiwibWlub3JUaGlyZCIsIm1ham9yVGhpcmQiLCJwZXJmZWN0Rm91cnRoIiwiYXVnRm91cnRoIiwicGVyZmVjdEZpZnRoIiwibWlub3JTaXh0aCIsImdvbGRlblNlY3Rpb24iLCJtYWpvclNpeHRoIiwibWlub3JTZXZlbnRoIiwibWFqb3JTZXZlbnRoIiwib2N0YXZlIiwibWFqb3JUZW50aCIsIm1ham9yRWxldmVudGgiLCJtYWpvclR3ZWxmdGgiLCJkb3VibGVPY3RhdmUiLCJnZXRSYXRpbyIsInJhdGlvTmFtZSIsIm1vZHVsYXJTY2FsZSIsInN0ZXBzIiwicmF0aW8iLCJyZWFsQmFzZSIsInJlYWxSYXRpbyIsInBvdyIsInJlbSIsInJlbSQxIiwiZGVmYXVsdEZvbnRTaXplIiwiY29udmVydEJhc2UiLCJkZWNvbnN0cnVjdGVkVmFsdWUiLCJnZXRCYXNlRnJvbURvYyIsInJvb3RGb250U2l6ZSIsImZvbnRTaXplIiwicmVtVG9QeCIsImZ1bmN0aW9uc01hcCQzIiwiYmFjayIsImNpcmMiLCJjdWJpYyIsImV4cG8iLCJxdWFkIiwicXVhcnQiLCJxdWludCIsInNpbmUiLCJlYXNlSW4iLCJmdW5jdGlvbk5hbWUiLCJmdW5jdGlvbnNNYXAkMiIsImVhc2VJbk91dCIsImZ1bmN0aW9uc01hcCQxIiwiZWFzZU91dCIsImJldHdlZW4iLCJmcm9tU2l6ZSIsInRvU2l6ZSIsIm1pblNjcmVlbiIsIm1heFNjcmVlbiIsIl9nZXRWYWx1ZUFuZFVuaXQiLCJ1bml0bGVzc0Zyb21TaXplIiwiZnJvbVNpemVVbml0IiwiX2dldFZhbHVlQW5kVW5pdDIiLCJ1bml0bGVzc1RvU2l6ZSIsInRvU2l6ZVVuaXQiLCJfZ2V0VmFsdWVBbmRVbml0MyIsInVuaXRsZXNzTWluU2NyZWVuIiwibWluU2NyZWVuVW5pdCIsIl9nZXRWYWx1ZUFuZFVuaXQ0IiwidW5pdGxlc3NNYXhTY3JlZW4iLCJtYXhTY3JlZW5Vbml0Iiwic2xvcGUiLCJ0b0ZpeGVkIiwiY2xlYXJGaXgiLCJwYXJlbnQiLCJwc2V1ZG9TZWxlY3RvciIsImNsZWFyIiwiY29udGVudCIsImRpc3BsYXkiLCJjb3ZlciIsIm9mZnNldCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsImVsbGlwc2lzIiwid2lkdGgiLCJsaW5lcyIsIm1heFdpZHRoIiwib3ZlcmZsb3ciLCJ0ZXh0T3ZlcmZsb3ciLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJXZWJraXRCb3hPcmllbnQiLCJXZWJraXRMaW5lQ2xhbXAiLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwibyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm5leHQiLCJiaW5kIiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImRvbmUiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiYXJyIiwibGVuIiwiYXJyMiIsImZsdWlkUmFuZ2UiLCJjc3NQcm9wIiwibWVkaWFRdWVyaWVzIiwiZmFsbGJhY2tzIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfZXh0ZW5kczIiLCJfZXh0ZW5kczMiLCJvYmoiLCJwcm9wIiwiX3JlZjMiLCJkYXRhVVJJUmVnZXgiLCJmb3JtYXRIaW50TWFwIiwid29mZiIsIndvZmYyIiwidHRmIiwib3RmIiwiZW90Iiwic3ZnIiwic3ZneiIsImdlbmVyYXRlRm9ybWF0SGludCIsImZvcm1hdEhpbnQiLCJpc0RhdGFVUkkiLCJmb250RmlsZVBhdGgiLCJnZW5lcmF0ZUZpbGVSZWZlcmVuY2VzIiwiZmlsZUZvcm1hdHMiLCJmaWxlRm9udFJlZmVyZW5jZXMiLCJnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyIsImxvY2FsRm9udHMiLCJsb2NhbEZvbnRSZWZlcmVuY2VzIiwiZm9udCIsImdlbmVyYXRlU291cmNlcyIsImZvbnRSZWZlcmVuY2VzIiwiZm9udEZhY2UiLCJmb250RmFtaWx5IiwiZm9udFN0cmV0Y2giLCJmb250U3R5bGUiLCJmb250VmFyaWFudCIsImZvbnRXZWlnaHQiLCJfcmVmJGZpbGVGb3JtYXRzIiwiX3JlZiRmb3JtYXRIaW50IiwiX3JlZiRsb2NhbEZvbnRzIiwidW5pY29kZVJhbmdlIiwiZm9udERpc3BsYXkiLCJmb250VmFyaWF0aW9uU2V0dGluZ3MiLCJmb250RmVhdHVyZVNldHRpbmdzIiwiZm9udEZhY2VEZWNsYXJhdGlvbiIsInNyYyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImhpZGVUZXh0IiwidGV4dEluZGVudCIsImhpZGVWaXN1YWxseSIsImJvcmRlciIsImNsaXAiLCJoZWlnaHQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiaGlEUEkiLCJyb3VuZCIsImNvbnN0cnVjdEdyYWRpZW50VmFsdWUiLCJsaXRlcmFscyIsInRlbXBsYXRlIiwic3Vic3RpdHV0aW9ucyIsImRlZmluZWRWYWx1ZXMiLCJmaWx0ZXIiLCJzdWJzdGl0dXRlIiwiX3RlbXBsYXRlT2JqZWN0JDEiLCJsaW5lYXJHcmFkaWVudCIsImNvbG9yU3RvcHMiLCJmYWxsYmFjayIsIl9yZWYkdG9EaXJlY3Rpb24iLCJ0b0RpcmVjdGlvbiIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsIm5vcm1hbGl6ZSIsImh0bWwiLCJsaW5lSGVpZ2h0IiwidGV4dFNpemVBZGp1c3QiLCJib2R5IiwibWFpbiIsImgxIiwiaHIiLCJib3hTaXppbmciLCJwcmUiLCJib3JkZXJCb3R0b20iLCJ0ZXh0RGVjb3JhdGlvbiIsInNtYWxsIiwidmVydGljYWxBbGlnbiIsInN1YiIsInN1cCIsImltZyIsImJvcmRlclN0eWxlIiwidGV4dFRyYW5zZm9ybSIsIldlYmtpdEFwcGVhcmFuY2UiLCJvdXRsaW5lIiwiZmllbGRzZXQiLCJsZWdlbmQiLCJjb2xvciIsInByb2dyZXNzIiwidGV4dGFyZWEiLCJvdXRsaW5lT2Zmc2V0IiwiZGV0YWlscyIsInN1bW1hcnkiLCJfdGVtcGxhdGVPYmplY3QiLCJyYWRpYWxHcmFkaWVudCIsIl9yZWYkZXh0ZW50IiwiZXh0ZW50IiwiX3JlZiRwb3NpdGlvbiIsIl9yZWYkc2hhcGUiLCJzaGFwZSIsInJldGluYUltYWdlIiwiZmlsZW5hbWUiLCJiYWNrZ3JvdW5kU2l6ZSIsImV4dGVuc2lvbiIsInJldGluYUZpbGVuYW1lIiwicmV0aW5hU3VmZml4IiwiZXh0IiwickZpbGVuYW1lIiwiZnVuY3Rpb25zTWFwIiwiZWFzZUluQmFjayIsImVhc2VJbkNpcmMiLCJlYXNlSW5DdWJpYyIsImVhc2VJbkV4cG8iLCJlYXNlSW5RdWFkIiwiZWFzZUluUXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0QmFjayIsImVhc2VPdXRDdWJpYyIsImVhc2VPdXRDaXJjIiwiZWFzZU91dEV4cG8iLCJlYXNlT3V0UXVhZCIsImVhc2VPdXRRdWFydCIsImVhc2VPdXRRdWludCIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJbk91dFNpbmUiLCJnZXRUaW1pbmdGdW5jdGlvbiIsInRpbWluZ0Z1bmN0aW9ucyIsInRpbWluZ0Z1bmN0aW9uIiwiZ2V0Qm9yZGVyV2lkdGgiLCJwb2ludGluZ0RpcmVjdGlvbiIsImZ1bGxXaWR0aCIsImhhbGZXaWR0aCIsImZ1bGxIZWlnaHQiLCJoYWxmSGVpZ2h0IiwiZ2V0Qm9yZGVyQ29sb3IiLCJmb3JlZ3JvdW5kQ29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyUmlnaHRDb2xvciIsInRyaWFuZ2xlIiwiX3JlZiRiYWNrZ3JvdW5kQ29sb3IiLCJ3aWR0aEFuZFVuaXQiLCJoZWlnaHRBbmRVbml0IiwiaXNOYU4iLCJib3JkZXJDb2xvciIsImJvcmRlcldpZHRoIiwid3JhcCIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImNvbG9yVG9JbnQiLCJjb252ZXJ0VG9JbnQiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJoc2xUb1JnYiIsImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiLCJjb252ZXJ0IiwiaHVlUHJpbWUiLCJjaHJvbWEiLCJhYnMiLCJzZWNvbmRDb21wb25lbnQiLCJsaWdodG5lc3NNb2RpZmljYXRpb24iLCJmaW5hbFJlZCIsImZpbmFsR3JlZW4iLCJmaW5hbEJsdWUiLCJuYW1lZENvbG9yTWFwIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJuYW1lVG9IZXgiLCJub3JtYWxpemVkQ29sb3JOYW1lIiwiaGV4UmVnZXgiLCJoZXhSZ2JhUmVnZXgiLCJyZWR1Y2VkSGV4UmVnZXgiLCJyZWR1Y2VkUmdiYUhleFJlZ2V4IiwicmdiUmVnZXgiLCJyZ2JhUmVnZXgiLCJoc2xSZWdleCIsImhzbGFSZWdleCIsInBhcnNlVG9SZ2IiLCJub3JtYWxpemVkQ29sb3IiLCJwYXJzZUludCIsImFscGhhIiwiX2FscGhhIiwicmdiTWF0Y2hlZCIsInJnYmFNYXRjaGVkIiwic3Vic3RyaW5nIiwiaHNsTWF0Y2hlZCIsInJnYkNvbG9yU3RyaW5nIiwiaHNsUmdiTWF0Y2hlZCIsImhzbGFNYXRjaGVkIiwiX2h1ZSIsIl9zYXR1cmF0aW9uIiwiX2xpZ2h0bmVzcyIsIl9yZ2JDb2xvclN0cmluZyIsIl9oc2xSZ2JNYXRjaGVkIiwicmdiVG9Ic2wiLCJkZWx0YSIsInBhcnNlVG9Ic2wiLCJyZWR1Y2VIZXhWYWx1ZSIsInJlZHVjZUhleFZhbHVlJDEiLCJudW1iZXJUb0hleCIsImhleCIsImNvbG9yVG9IZXgiLCJjb252ZXJ0VG9IZXgiLCJoc2xUb0hleCIsImhzbCIsImhzbGEiLCJyZ2IiLCJyZ2JhIiwicmdiVmFsdWUiLCJpc1JnYiIsImlzUmdiYSIsImlzSHNsIiwiaXNIc2xhIiwidG9Db2xvclN0cmluZyIsImN1cnJpZWQiLCJmbiIsImNvbWJpbmVkIiwiY3VycnkiLCJhZGp1c3RIdWUiLCJkZWdyZWUiLCJoc2xDb2xvciIsImN1cnJpZWRBZGp1c3RIdWUiLCJjdXJyaWVkQWRqdXN0SHVlJDEiLCJjb21wbGVtZW50IiwiZ3VhcmQiLCJsb3dlckJvdW5kYXJ5IiwidXBwZXJCb3VuZGFyeSIsImRhcmtlbiIsImFtb3VudCIsImN1cnJpZWREYXJrZW4iLCJjdXJyaWVkRGFya2VuJDEiLCJkZXNhdHVyYXRlIiwiY3VycmllZERlc2F0dXJhdGUiLCJjdXJyaWVkRGVzYXR1cmF0ZSQxIiwiZ2V0THVtaW5hbmNlIiwicmdiQ29sb3IiLCJfT2JqZWN0JGtleXMkbWFwIiwiY2hhbm5lbCIsInIiLCJnIiwiZ2V0Q29udHJhc3QiLCJjb2xvcjEiLCJjb2xvcjIiLCJsdW1pbmFuY2UxIiwibHVtaW5hbmNlMiIsImdyYXlzY2FsZSIsImhzbFRvQ29sb3JTdHJpbmciLCJpbnZlcnQiLCJsaWdodGVuIiwiY3VycmllZExpZ2h0ZW4iLCJjdXJyaWVkTGlnaHRlbiQxIiwibWVldHNDb250cmFzdEd1aWRlbGluZXMiLCJjb250cmFzdFJhdGlvIiwiQUEiLCJBQUxhcmdlIiwiQUFBIiwiQUFBTGFyZ2UiLCJtaXgiLCJ3ZWlnaHQiLCJvdGhlckNvbG9yIiwicGFyc2VkQ29sb3IxIiwicGFyc2VkQ29sb3IyIiwiYWxwaGFEZWx0YSIsIngiLCJ5IiwieiIsIndlaWdodDEiLCJ3ZWlnaHQyIiwibWl4ZWRDb2xvciIsImZsb29yIiwiY3VycmllZE1peCIsIm1peCQxIiwib3BhY2lmeSIsInBhcnNlZENvbG9yIiwiY29sb3JXaXRoQWxwaGEiLCJjdXJyaWVkT3BhY2lmeSIsImN1cnJpZWRPcGFjaWZ5JDEiLCJkZWZhdWx0UmV0dXJuSWZMaWdodENvbG9yIiwiZGVmYXVsdFJldHVybklmRGFya0NvbG9yIiwicmVhZGFibGVDb2xvciIsInJldHVybklmTGlnaHRDb2xvciIsInJldHVybklmRGFya0NvbG9yIiwic3RyaWN0IiwiaXNDb2xvckxpZ2h0IiwicHJlZmVycmVkUmV0dXJuQ29sb3IiLCJyZ2JUb0NvbG9yU3RyaW5nIiwic2F0dXJhdGUiLCJjdXJyaWVkU2F0dXJhdGUiLCJjdXJyaWVkU2F0dXJhdGUkMSIsInNldEh1ZSIsImN1cnJpZWRTZXRIdWUiLCJjdXJyaWVkU2V0SHVlJDEiLCJzZXRMaWdodG5lc3MiLCJjdXJyaWVkU2V0TGlnaHRuZXNzIiwiY3VycmllZFNldExpZ2h0bmVzcyQxIiwic2V0U2F0dXJhdGlvbiIsImN1cnJpZWRTZXRTYXR1cmF0aW9uIiwiY3VycmllZFNldFNhdHVyYXRpb24kMSIsInNoYWRlIiwicGVyY2VudGFnZSIsImN1cnJpZWRTaGFkZSIsImN1cnJpZWRTaGFkZSQxIiwidGludCIsImN1cnJpZWRUaW50IiwiY3VycmllZFRpbnQkMSIsInRyYW5zcGFyZW50aXplIiwiY3VycmllZFRyYW5zcGFyZW50aXplIiwiY3VycmllZFRyYW5zcGFyZW50aXplJDEiLCJhbmltYXRpb24iLCJtdWx0aU1vZGUiLCJhcmciLCJiYWNrZ3JvdW5kSW1hZ2VzIiwicHJvcGVydGllcyIsImJhY2tncm91bmRzIiwiYmFja2dyb3VuZCIsInNpZGVNYXAiLCJzaWRlS2V5d29yZCIsInVuc2hpZnQiLCJib3JkZXJSYWRpdXMiLCJzaWRlIiwicmFkaXVzIiwidXBwZXJjYXNlU2lkZSIsImdlbmVyYXRlU2VsZWN0b3JzIiwic3RhdGUiLCJzdGF0ZVN1ZmZpeCIsInN0YXRlZnVsU2VsZWN0b3JzIiwic3RhdGVzIiwic3RhdGVNYXAiLCJzZWxlY3RvcnMiLCJzdGF0ZU1hcCQxIiwidGVtcGxhdGUkMSIsImJ1dHRvbnMiLCJwb3NpdGlvbk1hcCIsInNpemUiLCJ0ZXh0SW5wdXRzIiwidHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uc1N0cmluZyIsInRyYW5zaXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polished/dist/polished.esm.js\n");

/***/ })

};
;