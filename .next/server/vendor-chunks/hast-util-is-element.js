"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-is-element";
exports.ids = ["vendor-chunks/hast-util-is-element"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-is-element/index.js":
/*!****************************************************!*\
  !*** ./node_modules/hast-util-is-element/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertElement: () => (/* binding */ convertElement),\n/* harmony export */   isElement: () => (/* binding */ isElement)\n/* harmony export */ });\n/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */ /**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */ /**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */ /**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */ /**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */ /**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */ /**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */ const isElement = /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */ /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */ // eslint-disable-next-line max-params\nfunction(node, test, index, parent, context) {\n    const check = convertElement(test);\n    if (index !== undefined && index !== null && (typeof index !== \"number\" || index < 0 || index === Number.POSITIVE_INFINITY)) {\n        throw new Error(\"Expected positive finite index for child node\");\n    }\n    if (parent !== undefined && parent !== null && (!parent.type || !parent.children)) {\n        throw new Error(\"Expected parent node\");\n    }\n    // @ts-expect-error Looks like a node.\n    if (!node || !node.type || typeof node.type !== \"string\") {\n        return false;\n    }\n    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n        throw new Error(\"Expected both parent and index\");\n    }\n    return check.call(context, node, index, parent);\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */ const convertElement = /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */ /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */ function(test) {\n    if (test === undefined || test === null) {\n        return element;\n    }\n    if (typeof test === \"string\") {\n        return tagNameFactory(test);\n    }\n    if (typeof test === \"object\") {\n        return anyFactory(test);\n    }\n    if (typeof test === \"function\") {\n        return castFactory(test);\n    }\n    throw new Error(\"Expected function, string, or array as test\");\n};\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */ function anyFactory(tests) {\n    /** @type {Array<AssertAnything>} */ const checks = [];\n    let index = -1;\n    while(++index < tests.length){\n        checks[index] = convertElement(tests[index]);\n    }\n    return castFactory(any);\n    /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */ function any(...parameters) {\n        let index = -1;\n        while(++index < checks.length){\n            if (checks[index].call(this, ...parameters)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */ function tagNameFactory(check) {\n    return tagName;\n    /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */ function tagName(node) {\n        return element(node) && node.tagName === check;\n    }\n}\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */ function castFactory(check) {\n    return assertion;\n    /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */ function assertion(node, ...parameters) {\n        // @ts-expect-error: fine.\n        return element(node) && Boolean(check.call(this, node, ...parameters));\n    }\n}\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */ function element(node) {\n    return Boolean(node && typeof node === \"object\" && // @ts-expect-error Looks like a node.\n    node.type === \"element\" && // @ts-expect-error Looks like an element.\n    typeof node.tagName === \"string\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLWlzLWVsZW1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUQ7Ozs7Ozs7Ozs7O0NBV0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FFRDs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUEsWUFDWDs7Ozs7O0dBTUMsR0FFQzs7Ozs7OztLQU9DLEdBQ0Qsc0NBQXNDO0FBQ3RDLFNBQVVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUMxQyxNQUFNQyxRQUFRQyxlQUFlTDtJQUU3QixJQUNFQyxVQUFVSyxhQUNWTCxVQUFVLFFBQ1QsUUFBT0EsVUFBVSxZQUNoQkEsUUFBUSxLQUNSQSxVQUFVTSxPQUFPQyxpQkFBaUIsR0FDcEM7UUFDQSxNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxJQUNFUCxXQUFXSSxhQUNYSixXQUFXLFFBQ1YsRUFBQ0EsT0FBT1EsSUFBSSxJQUFJLENBQUNSLE9BQU9TLFFBQVEsR0FDakM7UUFDQSxNQUFNLElBQUlGLE1BQU07SUFDbEI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBSSxDQUFDVixRQUFRLENBQUNBLEtBQUtXLElBQUksSUFBSSxPQUFPWCxLQUFLVyxJQUFJLEtBQUssVUFBVTtRQUN4RCxPQUFPO0lBQ1Q7SUFFQSxJQUNFLENBQUNSLFdBQVdJLGFBQWFKLFdBQVcsSUFBRyxNQUN0Q0QsQ0FBQUEsVUFBVUssYUFBYUwsVUFBVSxJQUFHLEdBQ3JDO1FBQ0EsTUFBTSxJQUFJUSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0wsTUFBTVEsSUFBSSxDQUFDVCxTQUFTSixNQUFNRSxPQUFPQztBQUMxQyxFQUNEO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxNQUFNRyxpQkFDWDs7Ozs7R0FLQyxHQUVDOzs7S0FHQyxHQUNELFNBQVVMLElBQUk7SUFDWixJQUFJQSxTQUFTTSxhQUFhTixTQUFTLE1BQU07UUFDdkMsT0FBT2E7SUFDVDtJQUVBLElBQUksT0FBT2IsU0FBUyxVQUFVO1FBQzVCLE9BQU9jLGVBQWVkO0lBQ3hCO0lBRUEsSUFBSSxPQUFPQSxTQUFTLFVBQVU7UUFDNUIsT0FBT2UsV0FBV2Y7SUFDcEI7SUFFQSxJQUFJLE9BQU9BLFNBQVMsWUFBWTtRQUM5QixPQUFPZ0IsWUFBWWhCO0lBQ3JCO0lBRUEsTUFBTSxJQUFJUyxNQUFNO0FBQ2xCLEVBQ0Q7QUFFSDs7Ozs7Q0FLQyxHQUNELFNBQVNNLFdBQVdFLEtBQUs7SUFDdkIsa0NBQWtDLEdBQ2xDLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixJQUFJakIsUUFBUSxDQUFDO0lBRWIsTUFBTyxFQUFFQSxRQUFRZ0IsTUFBTUUsTUFBTSxDQUFFO1FBQzdCRCxNQUFNLENBQUNqQixNQUFNLEdBQUdJLGVBQWVZLEtBQUssQ0FBQ2hCLE1BQU07SUFDN0M7SUFFQSxPQUFPZSxZQUFZSTtJQUVuQjs7OztHQUlDLEdBQ0QsU0FBU0EsSUFBSSxHQUFHQyxVQUFVO1FBQ3hCLElBQUlwQixRQUFRLENBQUM7UUFFYixNQUFPLEVBQUVBLFFBQVFpQixPQUFPQyxNQUFNLENBQUU7WUFDOUIsSUFBSUQsTUFBTSxDQUFDakIsTUFBTSxDQUFDVyxJQUFJLENBQUMsSUFBSSxLQUFLUyxhQUFhO2dCQUMzQyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTUCxlQUFlVixLQUFLO0lBQzNCLE9BQU9rQjtJQUVQOzs7R0FHQyxHQUNELFNBQVNBLFFBQVF2QixJQUFJO1FBQ25CLE9BQU9jLFFBQVFkLFNBQVNBLEtBQUt1QixPQUFPLEtBQUtsQjtJQUMzQztBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTWSxZQUFZWixLQUFLO0lBQ3hCLE9BQU9tQjtJQUVQOzs7OztHQUtDLEdBQ0QsU0FBU0EsVUFBVXhCLElBQUksRUFBRSxHQUFHc0IsVUFBVTtRQUNwQywwQkFBMEI7UUFDMUIsT0FBT1IsUUFBUWQsU0FBU3lCLFFBQVFwQixNQUFNUSxJQUFJLENBQUMsSUFBSSxFQUFFYixTQUFTc0I7SUFDNUQ7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1IsUUFBUWQsSUFBSTtJQUNuQixPQUFPeUIsUUFDTHpCLFFBQ0UsT0FBT0EsU0FBUyxZQUNoQixzQ0FBc0M7SUFDdENBLEtBQUtXLElBQUksS0FBSyxhQUNkLDBDQUEwQztJQUMxQyxPQUFPWCxLQUFLdUIsT0FBTyxLQUFLO0FBRTlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vS25vd2xlZGdlR3JhcGhRUy8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtaXMtZWxlbWVudC9pbmRleC5qcz9kNmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5QYXJlbnR9IFBhcmVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLkVsZW1lbnR9IEVsZW1lbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtudWxsIHwgdW5kZWZpbmVkIHwgc3RyaW5nIHwgVGVzdEZ1bmN0aW9uQW55dGhpbmcgfCBBcnJheTxzdHJpbmcgfCBUZXN0RnVuY3Rpb25Bbnl0aGluZz59IFRlc3RcbiAqICAgQ2hlY2sgZm9yIGFuIGFyYml0cmFyeSBlbGVtZW50LCB1bmF3YXJlIG9mIFR5cGVTY3JpcHQgaW5mZXJyYWwuXG4gKlxuICogQGNhbGxiYWNrIFRlc3RGdW5jdGlvbkFueXRoaW5nXG4gKiAgIENoZWNrIGlmIGFuIGVsZW1lbnQgcGFzc2VzIGEgdGVzdCwgdW5hd2FyZSBvZiBUeXBlU2NyaXB0IGluZmVycmFsLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIEFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IFtpbmRleF1cbiAqICAgVGhlIGVsZW1lbnTigJlzIHBvc2l0aW9uIGluIGl0cyBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudCB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXJlbnRdXG4gKiAgIFRoZSBlbGVtZW504oCZcyBwYXJlbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHZvaWR9XG4gKiAgIFdoZXRoZXIgdGhpcyBlbGVtZW50IHBhc3NlcyB0aGUgdGVzdC5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7RWxlbWVudH0gVFxuICogICBFbGVtZW50IHR5cGUuXG4gKiBAdHlwZWRlZiB7VFsndGFnTmFtZSddIHwgVGVzdEZ1bmN0aW9uUHJlZGljYXRlPFQ+IHwgQXJyYXk8VFsndGFnTmFtZSddIHwgVGVzdEZ1bmN0aW9uUHJlZGljYXRlPFQ+Pn0gUHJlZGljYXRlVGVzdFxuICogICBDaGVjayBmb3IgYW4gZWxlbWVudCB0aGF0IGNhbiBiZSBpbmZlcnJlZCBieSBUeXBlU2NyaXB0LlxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBwYXNzZXMgYSBjZXJ0YWluIG5vZGUgdGVzdC5cbiAqXG4gKiBAdGVtcGxhdGUge0VsZW1lbnR9IFRcbiAqICAgRWxlbWVudCB0eXBlLlxuICogQGNhbGxiYWNrIFRlc3RGdW5jdGlvblByZWRpY2F0ZVxuICogICBDb21wbGV4IHRlc3QgZnVuY3Rpb24gZm9yIGFuIGVsZW1lbnQgdGhhdCBjYW4gYmUgaW5mZXJyZWQgYnkgVHlwZVNjcmlwdC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICBBbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gKiAgIFRoZSBlbGVtZW504oCZcyBwb3NpdGlvbiBpbiBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFyZW50XVxuICogICBUaGUgZWxlbWVudOKAmXMgcGFyZW50LlxuICogQHJldHVybnMge2VsZW1lbnQgaXMgVH1cbiAqICAgV2hldGhlciB0aGlzIGVsZW1lbnQgcGFzc2VzIHRoZSB0ZXN0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEFzc2VydEFueXRoaW5nXG4gKiAgIENoZWNrIHRoYXQgYW4gYXJiaXRyYXJ5IHZhbHVlIGlzIGFuIGVsZW1lbnQsIHVuYXdhcmUgb2YgVHlwZVNjcmlwdCBpbmZlcnJhbC5cbiAqIEBwYXJhbSB7dW5rbm93bn0gW25vZGVdXG4gKiAgIEFueXRoaW5nICh0eXBpY2FsbHkgYSBub2RlKS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2luZGV4XVxuICogICBUaGUgbm9kZeKAmXMgcG9zaXRpb24gaW4gaXRzIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqICAgVGhlIG5vZGXigJlzIHBhcmVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoaXMgaXMgYW4gZWxlbWVudCBhbmQgcGFzc2VzIGEgdGVzdC5cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhbiBlbGVtZW50IGFuZCBwYXNzZXMgYSBjZXJ0YWluIG5vZGUgdGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSB7RWxlbWVudH0gVFxuICogICBFbGVtZW50IHR5cGUuXG4gKiBAY2FsbGJhY2sgQXNzZXJ0UHJlZGljYXRlXG4gKiAgIENoZWNrIHRoYXQgYW4gYXJiaXRyYXJ5IHZhbHVlIGlzIGEgc3BlY2lmaWMgZWxlbWVudCwgYXdhcmUgb2YgVHlwZVNjcmlwdC5cbiAqIEBwYXJhbSB7dW5rbm93bn0gW25vZGVdXG4gKiAgIEFueXRoaW5nICh0eXBpY2FsbHkgYSBub2RlKS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2luZGV4XVxuICogICBUaGUgbm9kZeKAmXMgcG9zaXRpb24gaW4gaXRzIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqICAgVGhlIG5vZGXigJlzIHBhcmVudC5cbiAqIEByZXR1cm5zIHtub2RlIGlzIFR9XG4gKiAgIFdoZXRoZXIgdGhpcyBpcyBhbiBlbGVtZW50IGFuZCBwYXNzZXMgYSB0ZXN0LlxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYG5vZGVgIGlzIGFuIGBFbGVtZW50YCBhbmQgd2hldGhlciBpdCBwYXNzZXMgdGhlIGdpdmVuIHRlc3QuXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqICAgVGhpbmcgdG8gY2hlY2ssIHR5cGljYWxseSBgTm9kZWAuXG4gKiBAcGFyYW0gdGVzdFxuICogICBBIGNoZWNrIGZvciBhIHNwZWNpZmljIGVsZW1lbnQuXG4gKiBAcGFyYW0gaW5kZXhcbiAqICAgVGhlIG5vZGXigJlzIHBvc2l0aW9uIGluIGl0cyBwYXJlbnQuXG4gKiBAcGFyYW0gcGFyZW50XG4gKiAgIFRoZSBub2Rl4oCZcyBwYXJlbnQuXG4gKiBAcmV0dXJuc1xuICogICBXaGV0aGVyIGBub2RlYCBpcyBhbiBlbGVtZW50IGFuZCBwYXNzZXMgYSB0ZXN0LlxuICovXG5leHBvcnQgY29uc3QgaXNFbGVtZW50ID1cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKCgpID0+IGZhbHNlKSAmXG4gICAqICAgKDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+KG5vZGU6IHVua25vd24sIHRlc3Q/OiBQcmVkaWNhdGVUZXN0PFQ+LCBpbmRleD86IG51bWJlciwgcGFyZW50PzogUGFyZW50LCBjb250ZXh0PzogdW5rbm93bikgPT4gbm9kZSBpcyBUKSAmXG4gICAqICAgKChub2RlOiB1bmtub3duLCB0ZXN0OiBUZXN0LCBpbmRleD86IG51bWJlciwgcGFyZW50PzogUGFyZW50LCBjb250ZXh0PzogdW5rbm93bikgPT4gYm9vbGVhbilcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3Vua25vd259IFtub2RlXVxuICAgICAqIEBwYXJhbSB7VGVzdCB8IHVuZGVmaW5lZH0gW3Rlc3RdXG4gICAgICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gICAgICogQHBhcmFtIHtQYXJlbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFyZW50XVxuICAgICAqIEBwYXJhbSB7dW5rbm93bn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICBmdW5jdGlvbiAobm9kZSwgdGVzdCwgaW5kZXgsIHBhcmVudCwgY29udGV4dCkge1xuICAgICAgY29uc3QgY2hlY2sgPSBjb252ZXJ0RWxlbWVudCh0ZXN0KVxuXG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgaW5kZXggIT09IG51bGwgJiZcbiAgICAgICAgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICBpbmRleCA8IDAgfHxcbiAgICAgICAgICBpbmRleCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgZmluaXRlIGluZGV4IGZvciBjaGlsZCBub2RlJylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwYXJlbnQgIT09IG51bGwgJiZcbiAgICAgICAgKCFwYXJlbnQudHlwZSB8fCAhcGFyZW50LmNoaWxkcmVuKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IG5vZGUnKVxuICAgICAgfVxuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExvb2tzIGxpa2UgYSBub2RlLlxuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnR5cGUgfHwgdHlwZW9mIG5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgKHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IHBhcmVudCA9PT0gbnVsbCkgIT09XG4gICAgICAgIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSBudWxsKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYm90aCBwYXJlbnQgYW5kIGluZGV4JylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoZWNrLmNhbGwoY29udGV4dCwgbm9kZSwgaW5kZXgsIHBhcmVudClcbiAgICB9XG4gIClcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhc3NlcnRpb24gZnJvbSBhIHRlc3QuXG4gKlxuICogVXNlZnVsIGlmIHlvdeKAmXJlIGdvaW5nIHRvIHRlc3QgbWFueSBub2RlcywgZm9yIGV4YW1wbGUgd2hlbiBjcmVhdGluZyBhXG4gKiB1dGlsaXR5IHdoZXJlIHNvbWV0aGluZyBlbHNlIHBhc3NlcyBhIGNvbXBhdGlibGUgdGVzdC5cbiAqXG4gKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBhIGJpdCBmYXN0ZXIgYmVjYXVzZSBpdCBleHBlY3RzIHZhbGlkIGlucHV0IG9ubHk6XG4gKiBhIGBub2RlYCwgYGluZGV4YCwgYW5kIGBwYXJlbnRgLlxuICpcbiAqIEBwYXJhbSB0ZXN0XG4gKiAgICogIFdoZW4gbnVsbGlzaCwgY2hlY2tzIGlmIGBub2RlYCBpcyBhbiBgRWxlbWVudGAuXG4gKiAgICogIFdoZW4gYHN0cmluZ2AsIHdvcmtzIGxpa2UgcGFzc2luZyBgKGVsZW1lbnQpID0+IGVsZW1lbnQudGFnTmFtZSA9PT0gdGVzdGAuXG4gKiAgICogIFdoZW4gYGZ1bmN0aW9uYCBjaGVja3MgaWYgZnVuY3Rpb24gcGFzc2VkIHRoZSBlbGVtZW50IGlzIHRydWUuXG4gKiAgICogIFdoZW4gYGFycmF5YCwgY2hlY2tzIGFueSBvbmUgb2YgdGhlIHN1YnRlc3RzIHBhc3MuXG4gKiBAcmV0dXJuc1xuICogICBBbiBhc3NlcnRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0RWxlbWVudCA9XG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VCBleHRlbmRzIEVsZW1lbnQ+KHRlc3Q6IFRbJ3RhZ05hbWUnXSB8IFRlc3RGdW5jdGlvblByZWRpY2F0ZTxUPikgPT4gQXNzZXJ0UHJlZGljYXRlPFQ+KSAmXG4gICAqICAgKCh0ZXN0PzogVGVzdCkgPT4gQXNzZXJ0QW55dGhpbmcpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUZXN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Rlc3RdXG4gICAgICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICBpZiAodGVzdCA9PT0gdW5kZWZpbmVkIHx8IHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGFnTmFtZUZhY3RvcnkodGVzdClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gYW55RmFjdG9yeSh0ZXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNhc3RGYWN0b3J5KHRlc3QpXG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZnVuY3Rpb24sIHN0cmluZywgb3IgYXJyYXkgYXMgdGVzdCcpXG4gICAgfVxuICApXG5cbi8qKlxuICogSGFuZGxlIG11bHRpcGxlIHRlc3RzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nIHwgVGVzdEZ1bmN0aW9uQW55dGhpbmc+fSB0ZXN0c1xuICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICovXG5mdW5jdGlvbiBhbnlGYWN0b3J5KHRlc3RzKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8QXNzZXJ0QW55dGhpbmc+fSAqL1xuICBjb25zdCBjaGVja3MgPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgdGVzdHMubGVuZ3RoKSB7XG4gICAgY2hlY2tzW2luZGV4XSA9IGNvbnZlcnRFbGVtZW50KHRlc3RzW2luZGV4XSlcbiAgfVxuXG4gIHJldHVybiBjYXN0RmFjdG9yeShhbnkpXG5cbiAgLyoqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiBAcGFyYW0ge0FycmF5PHVua25vd24+fSBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYW55KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGVja3MubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hlY2tzW2luZGV4XS5jYWxsKHRoaXMsIC4uLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgc3RyaW5nIGludG8gYSB0ZXN0IGZvciBhbiBlbGVtZW50IHdpdGggYSBjZXJ0YWluIHRhZyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGVja1xuICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICovXG5mdW5jdGlvbiB0YWdOYW1lRmFjdG9yeShjaGVjaykge1xuICByZXR1cm4gdGFnTmFtZVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiB0YWdOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gZWxlbWVudChub2RlKSAmJiBub2RlLnRhZ05hbWUgPT09IGNoZWNrXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgY3VzdG9tIHRlc3QgaW50byBhIHRlc3QgZm9yIGFuIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhhdCB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7VGVzdEZ1bmN0aW9uQW55dGhpbmd9IGNoZWNrXG4gKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhc3RGYWN0b3J5KGNoZWNrKSB7XG4gIHJldHVybiBhc3NlcnRpb25cblxuICAvKipcbiAgICogQHRoaXMge3Vua25vd259XG4gICAqIEBwYXJhbSB7dW5rbm93bn0gbm9kZVxuICAgKiBAcGFyYW0ge0FycmF5PHVua25vd24+fSBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0aW9uKG5vZGUsIC4uLnBhcmFtZXRlcnMpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBmaW5lLlxuICAgIHJldHVybiBlbGVtZW50KG5vZGUpICYmIEJvb2xlYW4oY2hlY2suY2FsbCh0aGlzLCBub2RlLCAuLi5wYXJhbWV0ZXJzKSlcbiAgfVxufVxuXG4vKipcbiAqIE1ha2Ugc3VyZSBzb21ldGhpbmcgaXMgYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAqIEByZXR1cm5zIHtub2RlIGlzIEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBub2RlICYmXG4gICAgICB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTG9va3MgbGlrZSBhIG5vZGUuXG4gICAgICBub2RlLnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMb29rcyBsaWtlIGFuIGVsZW1lbnQuXG4gICAgICB0eXBlb2Ygbm9kZS50YWdOYW1lID09PSAnc3RyaW5nJ1xuICApXG59XG4iXSwibmFtZXMiOlsiaXNFbGVtZW50Iiwibm9kZSIsInRlc3QiLCJpbmRleCIsInBhcmVudCIsImNvbnRleHQiLCJjaGVjayIsImNvbnZlcnRFbGVtZW50IiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJFcnJvciIsInR5cGUiLCJjaGlsZHJlbiIsImNhbGwiLCJlbGVtZW50IiwidGFnTmFtZUZhY3RvcnkiLCJhbnlGYWN0b3J5IiwiY2FzdEZhY3RvcnkiLCJ0ZXN0cyIsImNoZWNrcyIsImxlbmd0aCIsImFueSIsInBhcmFtZXRlcnMiLCJ0YWdOYW1lIiwiYXNzZXJ0aW9uIiwiQm9vbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-is-element/index.js\n");

/***/ })

};
;