/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unified";
exports.ids = ["vendor-chunks/unified"];
exports.modules = {

/***/ "(ssr)/./node_modules/unified/node_modules/is-buffer/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-buffer/index.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ module.exports = function isBuffer(obj) {\n    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcz8yZDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNCdWZmZXIiLCJvYmoiLCJjb25zdHJ1Y3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0NBS0MsR0FFREEsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFNBQVVDLEdBQUc7SUFDckMsT0FBT0EsT0FBTyxRQUFRQSxJQUFJQyxXQUFXLElBQUksUUFDdkMsT0FBT0QsSUFBSUMsV0FBVyxDQUFDRixRQUFRLEtBQUssY0FBY0MsSUFBSUMsV0FBVyxDQUFDRixRQUFRLENBQUNDO0FBQy9FIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL3VuaWZpZWQvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/node_modules/is-buffer/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/unified/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/unified/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unified: () => (/* binding */ unified)\n/* harmony export */ });\n/* harmony import */ var bail__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bail */ \"(ssr)/./node_modules/bail/index.js\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/unified/node_modules/is-buffer/index.js\");\n/* harmony import */ var extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\");\n/* harmony import */ var is_plain_obj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-plain-obj */ \"(ssr)/./node_modules/is-plain-obj/index.js\");\n/* harmony import */ var trough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! trough */ \"(ssr)/./node_modules/trough/index.js\");\n/* harmony import */ var vfile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vfile */ \"(ssr)/./node_modules/vfile/lib/index.js\");\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */ \n\n\n\n\n\n// Expose a frozen processor.\nconst unified = base().freeze();\nconst own = {}.hasOwnProperty;\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */ function base() {\n    const transformers = (0,trough__WEBPACK_IMPORTED_MODULE_3__.trough)();\n    /** @type {Processor['attachers']} */ const attachers = [];\n    /** @type {Record<string, unknown>} */ let namespace = {};\n    /** @type {boolean|undefined} */ let frozen;\n    let freezeIndex = -1;\n    // Data management.\n    // @ts-expect-error: overloads are handled.\n    processor.data = data;\n    processor.Parser = undefined;\n    processor.Compiler = undefined;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    // @ts-expect-error: overloads are handled.\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    // @ts-expect-error: overloads are handled.\n    processor.run = run;\n    processor.runSync = runSync;\n    // @ts-expect-error: overloads are handled.\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    /** @type {Processor} */ function processor() {\n        const destination = base();\n        let index = -1;\n        while(++index < attachers.length){\n            destination.use(...attachers[index]);\n        }\n        destination.data(extend__WEBPACK_IMPORTED_MODULE_1__(true, {}, namespace));\n        return destination;\n    }\n    /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */ function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    /** @type {Processor['freeze']} */ function freeze() {\n        if (frozen) {\n            return processor;\n        }\n        while(++freezeIndex < attachers.length){\n            const [attacher, ...options] = attachers[freezeIndex];\n            if (options[0] === false) {\n                continue;\n            }\n            if (options[0] === true) {\n                options[0] = undefined;\n            }\n            /** @type {Transformer|void} */ const transformer = attacher.call(processor, ...options);\n            if (typeof transformer === \"function\") {\n                transformers.use(transformer);\n            }\n        }\n        frozen = true;\n        freezeIndex = Number.POSITIVE_INFINITY;\n        return processor;\n    }\n    /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */ function use(value, ...options) {\n        /** @type {Record<string, unknown>|undefined} */ let settings;\n        assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin(value, ...options);\n        } else if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n        }\n        if (settings) {\n            namespace.settings = Object.assign(namespace.settings || {}, settings);\n        }\n        return processor;\n        /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */ function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value);\n            } else if (typeof value === \"object\") {\n                if (Array.isArray(value)) {\n                    const [plugin, ...options] = value;\n                    addPlugin(plugin, ...options);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new TypeError(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        /**\n     * @param {Preset} result\n     * @returns {void}\n     */ function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) {\n                settings = Object.assign(settings || {}, result.settings);\n            }\n        }\n        /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */ function addList(plugins) {\n            let index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (Array.isArray(plugins)) {\n                while(++index < plugins.length){\n                    const thing = plugins[index];\n                    add(thing);\n                }\n            } else {\n                throw new TypeError(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */ function addPlugin(plugin, value) {\n            let index = -1;\n            /** @type {Processor['attachers'][number]|undefined} */ let entry;\n            while(++index < attachers.length){\n                if (attachers[index][0] === plugin) {\n                    entry = attachers[index];\n                    break;\n                }\n            }\n            if (entry) {\n                if ((0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(entry[1]) && (0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(value)) {\n                    value = extend__WEBPACK_IMPORTED_MODULE_1__(true, entry[1], value);\n                }\n                entry[1] = value;\n            } else {\n                // @ts-expect-error: fine.\n                attachers.push([\n                    ...arguments\n                ]);\n            }\n        }\n    }\n    /** @type {Processor['parse']} */ function parse(doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Parser = processor.Parser;\n        assertParser(\"parse\", Parser);\n        if (newable(Parser, \"parse\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Parser(String(file), file).parse();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    /** @type {Processor['stringify']} */ function stringify(node, doc) {\n        processor.freeze();\n        const file = vfile(doc);\n        const Compiler = processor.Compiler;\n        assertCompiler(\"stringify\", Compiler);\n        assertNode(node);\n        if (newable(Compiler, \"compile\")) {\n            // @ts-expect-error: `newable` checks this.\n            return new Compiler(node, file).compile();\n        }\n        // @ts-expect-error: `newable` checks this.\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */ function run(node, doc, callback) {\n        assertNode(node);\n        processor.freeze();\n        if (!callback && typeof doc === \"function\") {\n            callback = doc;\n            doc = undefined;\n        }\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n            transformers.run(node, vfile(doc), done);\n            /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */ function done(error, tree, file) {\n                tree = tree || node;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(tree);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, tree, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['runSync']} */ function runSync(node, file) {\n        /** @type {Node|undefined} */ let result;\n        /** @type {boolean|undefined} */ let complete;\n        processor.run(node, file, done);\n        assertDone(\"runSync\", \"run\", complete);\n        // @ts-expect-error: we either bailed on an error or have a tree.\n        return result;\n        /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */ function done(error, tree) {\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n            result = tree;\n            complete = true;\n        }\n    }\n    /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */ function process(doc, callback) {\n        processor.freeze();\n        assertParser(\"process\", processor.Parser);\n        assertCompiler(\"process\", processor.Compiler);\n        if (!callback) {\n            return new Promise(executor);\n        }\n        executor(null, callback);\n        /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */ function executor(resolve, reject) {\n            const file = vfile(doc);\n            processor.run(processor.parse(file), file, (error, tree, file)=>{\n                if (error || !tree || !file) {\n                    done(error);\n                } else {\n                    /** @type {unknown} */ const result = processor.stringify(tree, file);\n                    if (result === undefined || result === null) {\n                    // Empty.\n                    } else if (looksLikeAVFileValue(result)) {\n                        file.value = result;\n                    } else {\n                        file.result = result;\n                    }\n                    done(error, file);\n                }\n            });\n            /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */ function done(error, file) {\n                if (error || !file) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    // @ts-expect-error: `callback` is defined if `resolve` is not.\n                    callback(null, file);\n                }\n            }\n        }\n    }\n    /** @type {Processor['processSync']} */ function processSync(doc) {\n        /** @type {boolean|undefined} */ let complete;\n        processor.freeze();\n        assertParser(\"processSync\", processor.Parser);\n        assertCompiler(\"processSync\", processor.Compiler);\n        const file = vfile(doc);\n        processor.process(file, done);\n        assertDone(\"processSync\", \"process\", complete);\n        return file;\n        /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */ function done(error) {\n            complete = true;\n            (0,bail__WEBPACK_IMPORTED_MODULE_4__.bail)(error);\n        }\n    }\n}\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */ function newable(value, name) {\n    return typeof value === \"function\" && // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype);\n}\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */ function keys(value) {\n    /** @type {string} */ let key;\n    for(key in value){\n        if (own.call(value, key)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */ function assertParser(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Parser`\");\n    }\n}\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */ function assertCompiler(name, value) {\n    if (typeof value !== \"function\") {\n        throw new TypeError(\"Cannot `\" + name + \"` without `Compiler`\");\n    }\n}\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */ function assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot call `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\");\n    }\n}\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */ function assertNode(node) {\n    // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n    // type-coverage:ignore-next-line\n    if (!(0,is_plain_obj__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node) || typeof node.type !== \"string\") {\n        throw new TypeError(\"Expected node, got `\" + node + \"`\");\n    // Fine.\n    }\n}\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */ function assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */ function vfile(value) {\n    return looksLikeAVFile(value) ? value : new vfile__WEBPACK_IMPORTED_MODULE_5__.VFile(value);\n}\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */ function looksLikeAVFile(value) {\n    return Boolean(value && typeof value === \"object\" && \"message\" in value && \"messages\" in value);\n}\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */ function looksLikeAVFileValue(value) {\n    return typeof value === \"string\" || is_buffer__WEBPACK_IMPORTED_MODULE_0__(value);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FFd0I7QUFDTztBQUNMO0FBQ1U7QUFDUjtBQUNGO0FBRTNCLDZCQUE2QjtBQUN0QixNQUFNTSxVQUFVQyxPQUFPQyxNQUFNLEdBQUU7QUFFdEMsTUFBTUMsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0IsMENBQTBDO0FBQzFDOztDQUVDLEdBQ0QsU0FBU0g7SUFDUCxNQUFNSSxlQUFlUCw4Q0FBTUE7SUFDM0IsbUNBQW1DLEdBQ25DLE1BQU1RLFlBQVksRUFBRTtJQUNwQixvQ0FBb0MsR0FDcEMsSUFBSUMsWUFBWSxDQUFDO0lBQ2pCLDhCQUE4QixHQUM5QixJQUFJQztJQUNKLElBQUlDLGNBQWMsQ0FBQztJQUVuQixtQkFBbUI7SUFDbkIsMkNBQTJDO0lBQzNDQyxVQUFVQyxJQUFJLEdBQUdBO0lBQ2pCRCxVQUFVRSxNQUFNLEdBQUdDO0lBQ25CSCxVQUFVSSxRQUFRLEdBQUdEO0lBRXJCLFFBQVE7SUFDUkgsVUFBVVIsTUFBTSxHQUFHQTtJQUVuQixXQUFXO0lBQ1hRLFVBQVVKLFNBQVMsR0FBR0E7SUFDdEIsMkNBQTJDO0lBQzNDSSxVQUFVSyxHQUFHLEdBQUdBO0lBRWhCLE9BQU87SUFDUEwsVUFBVU0sS0FBSyxHQUFHQTtJQUNsQk4sVUFBVU8sU0FBUyxHQUFHQTtJQUN0QiwyQ0FBMkM7SUFDM0NQLFVBQVVRLEdBQUcsR0FBR0E7SUFDaEJSLFVBQVVTLE9BQU8sR0FBR0E7SUFDcEIsMkNBQTJDO0lBQzNDVCxVQUFVVSxPQUFPLEdBQUdBO0lBQ3BCVixVQUFVVyxXQUFXLEdBQUdBO0lBRXhCLFVBQVU7SUFDVixPQUFPWDtJQUVQLHNFQUFzRTtJQUN0RSxzQkFBc0IsR0FDdEIsU0FBU0E7UUFDUCxNQUFNWSxjQUFjckI7UUFDcEIsSUFBSXNCLFFBQVEsQ0FBQztRQUViLE1BQU8sRUFBRUEs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QUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU3hCLE1BQU0zQixLQUFLO0lBQ2xCLE9BQU9vRCxnQkFBZ0JwRCxTQUFTQSxRQUFRLElBQUkzQix3Q0FBS0EsQ0FBQzJCO0FBQ3BEO0FBRUE7OztDQUdDLEdBQ0QsU0FBU29ELGdCQUFnQnBELEtBQUs7SUFDNUIsT0FBT3FELFFBQ0xyRCxTQUNFLE9BQU9BLFVBQVUsWUFDakIsYUFBYUEsU0FDYixjQUFjQTtBQUVwQjtBQUVBOzs7Q0FHQyxHQUNELFNBQVM2QyxxQkFBcUI3QyxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZL0Isc0NBQVFBLENBQUMrQjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0tub3dsZWRnZUdyYXBoUVMvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanM/MzkzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuTm9kZX0gTm9kZVxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WRmlsZUNvbXBhdGlibGV9IFZGaWxlQ29tcGF0aWJsZVxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WRmlsZVZhbHVlfSBWRmlsZVZhbHVlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByb2Nlc3Nvcn0gUHJvY2Vzc29yXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdpbn0gUGx1Z2luXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlByZXNldH0gUHJlc2V0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZX0gUGx1Z2dhYmxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZUxpc3R9IFBsdWdnYWJsZUxpc3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuVHJhbnNmb3JtZXJ9IFRyYW5zZm9ybWVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLlBhcnNlcn0gUGFyc2VyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLicpLkNvbXBpbGVyfSBDb21waWxlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4nKS5SdW5DYWxsYmFja30gUnVuQ2FsbGJhY2tcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuUHJvY2Vzc0NhbGxiYWNrfSBQcm9jZXNzQ2FsbGJhY2tcbiAqXG4gKiBAdHlwZWRlZiBDb250ZXh0XG4gKiBAcHJvcGVydHkge05vZGV9IHRyZWVcbiAqIEBwcm9wZXJ0eSB7VkZpbGV9IGZpbGVcbiAqL1xuXG5pbXBvcnQge2JhaWx9IGZyb20gJ2JhaWwnXG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnaXMtYnVmZmVyJ1xuaW1wb3J0IGV4dGVuZCBmcm9tICdleHRlbmQnXG5pbXBvcnQgaXNQbGFpbk9iaiBmcm9tICdpcy1wbGFpbi1vYmonXG5pbXBvcnQge3Ryb3VnaH0gZnJvbSAndHJvdWdoJ1xuaW1wb3J0IHtWRmlsZX0gZnJvbSAndmZpbGUnXG5cbi8vIEV4cG9zZSBhIGZyb3plbiBwcm9jZXNzb3IuXG5leHBvcnQgY29uc3QgdW5pZmllZCA9IGJhc2UoKS5mcmVlemUoKVxuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpcnN0IHByb2Nlc3Nvci5cbi8qKlxuICogQHJldHVybnMge1Byb2Nlc3Nvcn1cbiAqL1xuZnVuY3Rpb24gYmFzZSgpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gdHJvdWdoKClcbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ2F0dGFjaGVycyddfSAqL1xuICBjb25zdCBhdHRhY2hlcnMgPSBbXVxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuICBsZXQgbmFtZXNwYWNlID0ge31cbiAgLyoqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH0gKi9cbiAgbGV0IGZyb3plblxuICBsZXQgZnJlZXplSW5kZXggPSAtMVxuXG4gIC8vIERhdGEgbWFuYWdlbWVudC5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IuZGF0YSA9IGRhdGFcbiAgcHJvY2Vzc29yLlBhcnNlciA9IHVuZGVmaW5lZFxuICBwcm9jZXNzb3IuQ29tcGlsZXIgPSB1bmRlZmluZWRcblxuICAvLyBMb2NrLlxuICBwcm9jZXNzb3IuZnJlZXplID0gZnJlZXplXG5cbiAgLy8gUGx1Z2lucy5cbiAgcHJvY2Vzc29yLmF0dGFjaGVycyA9IGF0dGFjaGVyc1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBvdmVybG9hZHMgYXJlIGhhbmRsZWQuXG4gIHByb2Nlc3Nvci51c2UgPSB1c2VcblxuICAvLyBBUEkuXG4gIHByb2Nlc3Nvci5wYXJzZSA9IHBhcnNlXG4gIHByb2Nlc3Nvci5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogb3ZlcmxvYWRzIGFyZSBoYW5kbGVkLlxuICBwcm9jZXNzb3IucnVuID0gcnVuXG4gIHByb2Nlc3Nvci5ydW5TeW5jID0gcnVuU3luY1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBvdmVybG9hZHMgYXJlIGhhbmRsZWQuXG4gIHByb2Nlc3Nvci5wcm9jZXNzID0gcHJvY2Vzc1xuICBwcm9jZXNzb3IucHJvY2Vzc1N5bmMgPSBwcm9jZXNzU3luY1xuXG4gIC8vIEV4cG9zZS5cbiAgcmV0dXJuIHByb2Nlc3NvclxuXG4gIC8vIENyZWF0ZSBhIG5ldyBwcm9jZXNzb3IgYmFzZWQgb24gdGhlIHByb2Nlc3NvciBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3J9ICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NvcigpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IGJhc2UoKVxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGF0dGFjaGVycy5sZW5ndGgpIHtcbiAgICAgIGRlc3RpbmF0aW9uLnVzZSguLi5hdHRhY2hlcnNbaW5kZXhdKVxuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uLmRhdGEoZXh0ZW5kKHRydWUsIHt9LCBuYW1lc3BhY2UpKVxuXG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFtrZXldXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3ZhbHVlXVxuICAgKiBAcmV0dXJucyB7dW5rbm93bn1cbiAgICovXG4gIGZ1bmN0aW9uIGRhdGEoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gU2V0IGBrZXlgLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYXNzZXJ0VW5mcm96ZW4oJ2RhdGEnLCBmcm96ZW4pXG4gICAgICAgIG5hbWVzcGFjZVtrZXldID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYGtleWAuXG4gICAgICByZXR1cm4gKG93bi5jYWxsKG5hbWVzcGFjZSwga2V5KSAmJiBuYW1lc3BhY2Vba2V5XSkgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzcGFjZS5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBhc3NlcnRVbmZyb3plbignZGF0YScsIGZyb3plbilcbiAgICAgIG5hbWVzcGFjZSA9IGtleVxuICAgICAgcmV0dXJuIHByb2Nlc3NvclxuICAgIH1cblxuICAgIC8vIEdldCBzcGFjZS5cbiAgICByZXR1cm4gbmFtZXNwYWNlXG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsnZnJlZXplJ119ICovXG4gIGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICBpZiAoZnJvemVuKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc29yXG4gICAgfVxuXG4gICAgd2hpbGUgKCsrZnJlZXplSW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBbYXR0YWNoZXIsIC4uLm9wdGlvbnNdID0gYXR0YWNoZXJzW2ZyZWV6ZUluZGV4XVxuXG4gICAgICBpZiAob3B0aW9uc1swXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnNbMF0gPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9uc1swXSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUge1RyYW5zZm9ybWVyfHZvaWR9ICovXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGF0dGFjaGVyLmNhbGwocHJvY2Vzc29yLCAuLi5vcHRpb25zKVxuXG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyYW5zZm9ybWVycy51c2UodHJhbnNmb3JtZXIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnJvemVuID0gdHJ1ZVxuICAgIGZyZWV6ZUluZGV4ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG5cbiAgICByZXR1cm4gcHJvY2Vzc29yXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtQbHVnZ2FibGV8bnVsbHx1bmRlZmluZWR9IFt2YWx1ZV1cbiAgICogQHBhcmFtIHsuLi51bmtub3dufSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9jZXNzb3J9XG4gICAqL1xuICBmdW5jdGlvbiB1c2UodmFsdWUsIC4uLm9wdGlvbnMpIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgc2V0dGluZ3NcblxuICAgIGFzc2VydFVuZnJvemVuKCd1c2UnLCBmcm96ZW4pXG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRW1wdHkuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZFBsdWdpbih2YWx1ZSwgLi4ub3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhZGRMaXN0KHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgJyArIHZhbHVlICsgJ2AnKVxuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgbmFtZXNwYWNlLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihuYW1lc3BhY2Uuc2V0dGluZ3MgfHwge30sIHNldHRpbmdzKVxuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzb3JcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLicpLlBsdWdnYWJsZTx1bmtub3duW10+fSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhZGRQbHVnaW4odmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgW3BsdWdpbiwgLi4ub3B0aW9uc10gPSB2YWx1ZVxuICAgICAgICAgIGFkZFBsdWdpbihwbHVnaW4sIC4uLm9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgJyArIHZhbHVlICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UHJlc2V0fSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQcmVzZXQocmVzdWx0KSB7XG4gICAgICBhZGRMaXN0KHJlc3VsdC5wbHVnaW5zKVxuXG4gICAgICBpZiAocmVzdWx0LnNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihzZXR0aW5ncyB8fCB7fSwgcmVzdWx0LnNldHRpbmdzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGx1Z2dhYmxlTGlzdHxudWxsfHVuZGVmaW5lZH0gW3BsdWdpbnNdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGlzdChwbHVnaW5zKSB7XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICBpZiAocGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRoaW5nID0gcGx1Z2luc1tpbmRleF1cbiAgICAgICAgICBhZGQodGhpbmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbGlzdCBvZiBwbHVnaW5zLCBub3QgYCcgKyBwbHVnaW5zICsgJ2AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UGx1Z2lufSBwbHVnaW5cbiAgICAgKiBAcGFyYW0gey4uLnVua25vd259IFt2YWx1ZV1cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luLCB2YWx1ZSkge1xuICAgICAgbGV0IGluZGV4ID0gLTFcbiAgICAgIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydhdHRhY2hlcnMnXVtudW1iZXJdfHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBlbnRyeVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGF0dGFjaGVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF0dGFjaGVyc1tpbmRleF1bMF0gPT09IHBsdWdpbikge1xuICAgICAgICAgIGVudHJ5ID0gYXR0YWNoZXJzW2luZGV4XVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqKGVudHJ5WzFdKSAmJiBpc1BsYWluT2JqKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gZXh0ZW5kKHRydWUsIGVudHJ5WzFdLCB2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5WzFdID0gdmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGZpbmUuXG4gICAgICAgIGF0dGFjaGVycy5wdXNoKFsuLi5hcmd1bWVudHNdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydwYXJzZSddfSAqL1xuICBmdW5jdGlvbiBwYXJzZShkb2MpIHtcbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuICAgIGNvbnN0IFBhcnNlciA9IHByb2Nlc3Nvci5QYXJzZXJcbiAgICBhc3NlcnRQYXJzZXIoJ3BhcnNlJywgUGFyc2VyKVxuXG4gICAgaWYgKG5ld2FibGUoUGFyc2VyLCAncGFyc2UnKSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoU3RyaW5nKGZpbGUpLCBmaWxlKS5wYXJzZSgpXG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgIHJldHVybiBQYXJzZXIoU3RyaW5nKGZpbGUpLCBmaWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIC8qKiBAdHlwZSB7UHJvY2Vzc29yWydzdHJpbmdpZnknXX0gKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIGRvYykge1xuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuICAgIGNvbnN0IGZpbGUgPSB2ZmlsZShkb2MpXG4gICAgY29uc3QgQ29tcGlsZXIgPSBwcm9jZXNzb3IuQ29tcGlsZXJcbiAgICBhc3NlcnRDb21waWxlcignc3RyaW5naWZ5JywgQ29tcGlsZXIpXG4gICAgYXNzZXJ0Tm9kZShub2RlKVxuXG4gICAgaWYgKG5ld2FibGUoQ29tcGlsZXIsICdjb21waWxlJykpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBuZXdhYmxlYCBjaGVja3MgdGhpcy5cbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZXIobm9kZSwgZmlsZSkuY29tcGlsZSgpXG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG5ld2FibGVgIGNoZWNrcyB0aGlzLlxuICAgIHJldHVybiBDb21waWxlcihub2RlLCBmaWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV8UnVuQ2FsbGJhY2t9IFtkb2NdXG4gICAqIEBwYXJhbSB7UnVuQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9kZT58dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bihub2RlLCBkb2MsIGNhbGxiYWNrKSB7XG4gICAgYXNzZXJ0Tm9kZShub2RlKVxuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuXG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgZG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGRvY1xuICAgICAgZG9jID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKVxuICAgIH1cblxuICAgIGV4ZWN1dG9yKG51bGwsIGNhbGxiYWNrKVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudWxsfCgobm9kZTogTm9kZSkgPT4gdm9pZCl9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcjogRXJyb3IpID0+IHZvaWR9IHJlamVjdFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGRvY2AgY2Fu4oCZdCBiZSBhIGNhbGxiYWNrIGFueW1vcmUsIHdlIGNoZWNrZWQuXG4gICAgICB0cmFuc2Zvcm1lcnMucnVuKG5vZGUsIHZmaWxlKGRvYyksIGRvbmUpXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvclxuICAgICAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAgICAgKiBAcGFyYW0ge1ZGaWxlfSBmaWxlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9uZShlcnJvciwgdHJlZSwgZmlsZSkge1xuICAgICAgICB0cmVlID0gdHJlZSB8fCBub2RlXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cmVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBjYWxsYmFja2AgaXMgZGVmaW5lZCBpZiBgcmVzb2x2ZWAgaXMgbm90LlxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRyZWUsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge1Byb2Nlc3NvclsncnVuU3luYyddfSAqL1xuICBmdW5jdGlvbiBydW5TeW5jKG5vZGUsIGZpbGUpIHtcbiAgICAvKiogQHR5cGUge05vZGV8dW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXN1bHRcbiAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb21wbGV0ZVxuXG4gICAgcHJvY2Vzc29yLnJ1bihub2RlLCBmaWxlLCBkb25lKVxuXG4gICAgYXNzZXJ0RG9uZSgncnVuU3luYycsICdydW4nLCBjb21wbGV0ZSlcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGVpdGhlciBiYWlsZWQgb24gYW4gZXJyb3Igb3IgaGF2ZSBhIHRyZWUuXG4gICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBbZXJyb3JdXG4gICAgICogQHBhcmFtIHtOb2RlfSBbdHJlZV1cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb25lKGVycm9yLCB0cmVlKSB7XG4gICAgICBiYWlsKGVycm9yKVxuICAgICAgcmVzdWx0ID0gdHJlZVxuICAgICAgY29tcGxldGUgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VkZpbGVDb21wYXRpYmxlfSBkb2NcbiAgICogQHBhcmFtIHtQcm9jZXNzQ2FsbGJhY2t9IFtjYWxsYmFja11cbiAgICogQHJldHVybnMge1Byb21pc2U8VkZpbGU+fHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3MoZG9jLCBjYWxsYmFjaykge1xuICAgIHByb2Nlc3Nvci5mcmVlemUoKVxuICAgIGFzc2VydFBhcnNlcigncHJvY2VzcycsIHByb2Nlc3Nvci5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3MnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuXG4gICAgZXhlY3V0b3IobnVsbCwgY2FsbGJhY2spXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bGx8KChmaWxlOiBWRmlsZSkgPT4gdm9pZCl9IHJlc29sdmVcbiAgICAgKiBAcGFyYW0geyhlcnJvcj86IEVycm9yfG51bGx8dW5kZWZpbmVkKSA9PiB2b2lkfSByZWplY3RcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB2ZmlsZShkb2MpXG5cbiAgICAgIHByb2Nlc3Nvci5ydW4ocHJvY2Vzc29yLnBhcnNlKGZpbGUpLCBmaWxlLCAoZXJyb3IsIHRyZWUsIGZpbGUpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIHx8ICF0cmVlIHx8ICFmaWxlKSB7XG4gICAgICAgICAgZG9uZShlcnJvcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiogQHR5cGUge3Vua25vd259ICovXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc29yLnN0cmluZ2lmeSh0cmVlLCBmaWxlKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRW1wdHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChsb29rc0xpa2VBVkZpbGVWYWx1ZShyZXN1bHQpKSB7XG4gICAgICAgICAgICBmaWxlLnZhbHVlID0gcmVzdWx0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGUucmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9uZShlcnJvciwgZmlsZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0Vycm9yfG51bGx8dW5kZWZpbmVkfSBbZXJyb3JdXG4gICAgICAgKiBAcGFyYW0ge1ZGaWxlfHVuZGVmaW5lZH0gW2ZpbGVdXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZG9uZShlcnJvciwgZmlsZSkge1xuICAgICAgICBpZiAoZXJyb3IgfHwgIWZpbGUpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoZmlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgY2FsbGJhY2tgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdC5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtQcm9jZXNzb3JbJ3Byb2Nlc3NTeW5jJ119ICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NTeW5jKGRvYykge1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvbXBsZXRlXG5cbiAgICBwcm9jZXNzb3IuZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3NTeW5jJywgcHJvY2Vzc29yLlBhcnNlcilcbiAgICBhc3NlcnRDb21waWxlcigncHJvY2Vzc1N5bmMnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG5cbiAgICBjb25zdCBmaWxlID0gdmZpbGUoZG9jKVxuXG4gICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3Byb2Nlc3NTeW5jJywgJ3Byb2Nlc3MnLCBjb21wbGV0ZSlcblxuICAgIHJldHVybiBmaWxlXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfG51bGx8dW5kZWZpbmVkfSBbZXJyb3JdXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9uZShlcnJvcikge1xuICAgICAgY29tcGxldGUgPSB0cnVlXG4gICAgICBiYWlsKGVycm9yKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGB2YWx1ZWAgaXMgYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG5ld2FibGUodmFsdWUsIG5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBQcm90b3R5cGVzIGRvIGV4aXN0LlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIHZhbHVlLnByb3RvdHlwZSAmJlxuICAgIC8vIEEgZnVuY3Rpb24gd2l0aCBrZXlzIGluIGl0cyBwcm90b3R5cGUgaXMgcHJvYmFibHkgYSBjb25zdHJ1Y3Rvci5cbiAgICAvLyBDbGFzc2Vz4oCZIHByb3RvdHlwZSBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZSwgc28gd2UgY2hlY2sgaWYgc29tZSB2YWx1ZVxuICAgIC8vIGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlLlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIChrZXlzKHZhbHVlLnByb3RvdHlwZSkgfHwgbmFtZSBpbiB2YWx1ZS5wcm90b3R5cGUpXG4gIClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCB3aXRoIGtleXMuXG4gKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBrZXlzKHZhbHVlKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQga2V5XG5cbiAgZm9yIChrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAob3duLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQXNzZXJ0IGEgcGFyc2VyIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgUGFyc2VyfVxuICovXG5mdW5jdGlvbiBhc3NlcnRQYXJzZXIobmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBgJyArIG5hbWUgKyAnYCB3aXRob3V0IGBQYXJzZXJgJylcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCBhIGNvbXBpbGVyIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgQ29tcGlsZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydENvbXBpbGVyKG5hbWUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgQ29tcGlsZXJgJylcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGUgcHJvY2Vzc29yIGlzIG5vdCBmcm96ZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7dW5rbm93bn0gZnJvemVuXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyBmcm96ZW4gaXMgZmFsc2V9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVuZnJvemVuKG5hbWUsIGZyb3plbikge1xuICBpZiAoZnJvemVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjYWxsIGAnICtcbiAgICAgICAgbmFtZSArXG4gICAgICAgICdgIG9uIGEgZnJvemVuIHByb2Nlc3Nvci5cXG5DcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGZpcnN0LCBieSBjYWxsaW5nIGl0OiB1c2UgYHByb2Nlc3NvcigpYCBpbnN0ZWFkIG9mIGBwcm9jZXNzb3JgLidcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgYG5vZGVgIGlzIGEgdW5pc3Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVcbiAqIEByZXR1cm5zIHthc3NlcnRzIG5vZGUgaXMgTm9kZX1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlKSB7XG4gIC8vIGBpc1BsYWluT2JqYCB1bmZvcnR1bmF0ZWx5IHVzZXMgYGFueWAgaW5zdGVhZCBvZiBgdW5rbm93bmAuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBpZiAoIWlzUGxhaW5PYmoobm9kZSkgfHwgdHlwZW9mIG5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBub2RlLCBnb3QgYCcgKyBub2RlICsgJ2AnKVxuICAgIC8vIEZpbmUuXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCBgY29tcGxldGVgIGlzIGB0cnVlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFzeW5jTmFtZVxuICogQHBhcmFtIHt1bmtub3dufSBjb21wbGV0ZVxuICogQHJldHVybnMge2Fzc2VydHMgY29tcGxldGUgaXMgdHJ1ZX1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RG9uZShuYW1lLCBhc3luY05hbWUsIGNvbXBsZXRlKSB7XG4gIGlmICghY29tcGxldGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYCcgKyBuYW1lICsgJ2AgZmluaXNoZWQgYXN5bmMuIFVzZSBgJyArIGFzeW5jTmFtZSArICdgIGluc3RlYWQnXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtWRmlsZUNvbXBhdGlibGV9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtWRmlsZX1cbiAqL1xuZnVuY3Rpb24gdmZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIGxvb2tzTGlrZUFWRmlsZSh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBWRmlsZSh2YWx1ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZGaWxlQ29tcGF0aWJsZX0gW3ZhbHVlXVxuICogQHJldHVybnMge3ZhbHVlIGlzIFZGaWxlfVxuICovXG5mdW5jdGlvbiBsb29rc0xpa2VBVkZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgJ21lc3NhZ2VzJyBpbiB2YWx1ZVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgVkZpbGVWYWx1ZX1cbiAqL1xuZnVuY3Rpb24gbG9va3NMaWtlQVZGaWxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgaXNCdWZmZXIodmFsdWUpXG59XG4iXSwibmFtZXMiOlsiYmFpbCIsImlzQnVmZmVyIiwiZXh0ZW5kIiwiaXNQbGFpbk9iaiIsInRyb3VnaCIsIlZGaWxlIiwidW5pZmllZCIsImJhc2UiLCJmcmVlemUiLCJvd24iLCJoYXNPd25Qcm9wZXJ0eSIsInRyYW5zZm9ybWVycyIsImF0dGFjaGVycyIsIm5hbWVzcGFjZSIsImZyb3plbiIsImZyZWV6ZUluZGV4IiwicHJvY2Vzc29yIiwiZGF0YSIsIlBhcnNlciIsInVuZGVmaW5lZCIsIkNvbXBpbGVyIiwidXNlIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJydW4iLCJydW5TeW5jIiwicHJvY2VzcyIsInByb2Nlc3NTeW5jIiwiZGVzdGluYXRpb24iLCJpbmRleCIsImxlbmd0aCIsImtleSIsInZhbHVlIiwiYXJndW1lbnRzIiwiYXNzZXJ0VW5mcm96ZW4iLCJjYWxsIiwiYXR0YWNoZXIiLCJvcHRpb25zIiwidHJhbnNmb3JtZXIiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInNldHRpbmdzIiwiYWRkUGx1Z2luIiwiQXJyYXkiLCJpc0FycmF5IiwiYWRkTGlzdCIsImFkZFByZXNldCIsIlR5cGVFcnJvciIsIk9iamVjdCIsImFzc2lnbiIsImFkZCIsInBsdWdpbiIsInJlc3VsdCIsInBsdWdpbnMiLCJ0aGluZyIsImVudHJ5IiwicHVzaCIsImRvYyIsImZpbGUiLCJ2ZmlsZSIsImFzc2VydFBhcnNlciIsIm5ld2FibGUiLCJTdHJpbmciLCJub2RlIiwiYXNzZXJ0Q29tcGlsZXIiLCJhc3NlcnROb2RlIiwiY29tcGlsZSIsImNhbGxiYWNrIiwiUHJvbWlzZSIsImV4ZWN1dG9yIiwicmVzb2x2ZSIsInJlamVjdCIsImRvbmUiLCJlcnJvciIsInRyZWUiLCJjb21wbGV0ZSIsImFzc2VydERvbmUiLCJsb29rc0xpa2VBVkZpbGVWYWx1ZSIsIm5hbWUiLCJwcm90b3R5cGUiLCJrZXlzIiwiRXJyb3IiLCJ0eXBlIiwiYXN5bmNOYW1lIiwibG9va3NMaWtlQVZGaWxlIiwiQm9vbGVhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/lib/index.js\n");

/***/ })

};
;