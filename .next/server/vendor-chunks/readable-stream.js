/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readable-stream";
exports.ids = ["vendor-chunks/readable-stream"];
exports.modules = {

/***/ "(ssr)/./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\nmodule.exports = Duplex;\n/*<replacement>*/ var objectKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var key in obj)keys.push(key);\n    return keys;\n};\n/*</replacement>*/ /*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Readable = __webpack_require__(/*! ./_stream_readable */ \"(ssr)/./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(ssr)/./node_modules/readable-stream/lib/_stream_writable.js\");\nutil.inherits(Duplex, Readable);\nforEach(objectKeys(Writable.prototype), function(method) {\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n});\nfunction Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once(\"end\", onend);\n}\n// the no-half-open enforcer\nfunction onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended) return;\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    process.nextTick(this.end.bind(this));\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBRXpDLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEUsbUVBQW1FO0FBQ25FLFlBQVk7QUFFWkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixlQUFlLEdBQ2YsSUFBSUMsYUFBYUMsT0FBT0MsSUFBSSxJQUFJLFNBQVVDLEdBQUc7SUFDM0MsSUFBSUQsT0FBTyxFQUFFO0lBQ2IsSUFBSyxJQUFJRSxPQUFPRCxJQUFLRCxLQUFLRyxJQUFJLENBQUNEO0lBQy9CLE9BQU9GO0FBQ1Q7QUFDQSxnQkFBZ0IsR0FHaEIsZUFBZSxHQUNmLElBQUlJLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CRCxLQUFLRSxRQUFRLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQixJQUFJRSxXQUFXRixtQkFBT0EsQ0FBQztBQUN2QixJQUFJRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUV2QkQsS0FBS0UsUUFBUSxDQUFDVCxRQUFRVTtBQUV0QkUsUUFBUVgsV0FBV1UsU0FBU0UsU0FBUyxHQUFHLFNBQVNDLE1BQU07SUFDckQsSUFBSSxDQUFDZCxPQUFPYSxTQUFTLENBQUNDLE9BQU8sRUFDM0JkLE9BQU9hLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHSCxTQUFTRSxTQUFTLENBQUNDLE9BQU87QUFDekQ7QUFFQSxTQUFTZCxPQUFPZSxPQUFPO0lBQ3JCLElBQUksQ0FBRSxLQUFJLFlBQVlmLE1BQUssR0FDekIsT0FBTyxJQUFJQSxPQUFPZTtJQUVwQkwsU0FBU00sSUFBSSxDQUFDLElBQUksRUFBRUQ7SUFDcEJKLFNBQVNLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBRXBCLElBQUlBLFdBQVdBLFFBQVFFLFFBQVEsS0FBSyxPQUNsQyxJQUFJLENBQUNBLFFBQVEsR0FBRztJQUVsQixJQUFJRixXQUFXQSxRQUFRRyxRQUFRLEtBQUssT0FDbEMsSUFBSSxDQUFDQSxRQUFRLEdBQUc7SUFFbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSUosV0FBV0EsUUFBUUksYUFBYSxLQUFLLE9BQ3ZDLElBQUksQ0FBQ0EsYUFBYSxHQUFHO0lBRXZCLElBQUksQ0FBQ0MsSUFBSSxDQUFDLE9BQU9DO0FBQ25CO0FBRUEsNEJBQTRCO0FBQzVCLFNBQVNBO0lBQ1AsOERBQThEO0lBQzlELGlCQUFpQjtJQUNqQixJQUFJLElBQUksQ0FBQ0YsYUFBYSxJQUFJLElBQUksQ0FBQ0csY0FBYyxDQUFDQyxLQUFLLEVBQ2pEO0lBRUYsK0JBQStCO0lBQy9CLGdEQUFnRDtJQUNoREMsUUFBUUMsUUFBUSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDQyxJQUFJLENBQUMsSUFBSTtBQUNyQztBQUVBLFNBQVNmLFFBQVNnQixFQUFFLEVBQUVDLENBQUM7SUFDckIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlILEdBQUdJLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBSztRQUN6Q0QsRUFBRUQsRUFBRSxDQUFDRSxFQUFFLEVBQUVBO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0tub3dsZWRnZUdyYXBoUVMvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcz81MDYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiRHVwbGV4Iiwib2JqZWN0S2V5cyIsIk9iamVjdCIsImtleXMiLCJvYmoiLCJrZXkiLCJwdXNoIiwidXRpbCIsInJlcXVpcmUiLCJpbmhlcml0cyIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJmb3JFYWNoIiwicHJvdG90eXBlIiwibWV0aG9kIiwib3B0aW9ucyIsImNhbGwiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiYWxsb3dIYWxmT3BlbiIsIm9uY2UiLCJvbmVuZCIsIl93cml0YWJsZVN0YXRlIiwiZW5kZWQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbmQiLCJiaW5kIiwieHMiLCJmIiwiaSIsImwiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(ssr)/./node_modules/readable-stream/lib/_stream_transform.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(PassThrough, Transform);\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsd0JBQXdCO0FBQ3hCLDREQUE0RDtBQUM1RCx5Q0FBeUM7QUFFekNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUM7QUFFeEIsZUFBZSxHQUNmLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CQyxLQUFLQyxRQUFRLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQkMsS0FBS0MsUUFBUSxDQUFDSixhQUFhQztBQUUzQixTQUFTRCxZQUFZSyxPQUFPO0lBQzFCLElBQUksQ0FBRSxLQUFJLFlBQVlMLFdBQVUsR0FDOUIsT0FBTyxJQUFJQSxZQUFZSztJQUV6QkosVUFBVUssSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDdkI7QUFFQUwsWUFBWU8sU0FBUyxDQUFDQyxVQUFVLEdBQUcsU0FBU0MsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDN0RBLEdBQUcsTUFBTUY7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL0tub3dsZWRnZUdyYXBoUVMvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzPzgwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiUGFzc1Rocm91Z2giLCJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwidXRpbCIsImluaGVyaXRzIiwib3B0aW9ucyIsImNhbGwiLCJwcm90b3R5cGUiLCJfdHJhbnNmb3JtIiwiY2h1bmsiLCJlbmNvZGluZyIsImNiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nmodule.exports = Readable;\n/*<replacement>*/ var isArray = __webpack_require__(/*! isarray */ \"(ssr)/./node_modules/isarray/index.js\");\n/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Readable.ReadableState = ReadableState;\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n/*<replacement>*/ if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n    return emitter.listeners(type).length;\n};\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var StringDecoder;\nutil.inherits(Readable, Stream);\nfunction ReadableState(options, stream) {\n    options = options || {};\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    var hwm = options.highWaterMark;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.buffer = [];\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = false;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    // In streams that never have any data, and do push(null) right away,\n    // the consumer can miss the 'end' event if they do some I/O before\n    // consuming the stream.  So, we don't emit('end') until some reading\n    // happens.\n    this.calledRead = false;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, becuase any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // when piping, we only care about 'readable' events that happen\n    // after read()ing all the bytes and not getting any pushback.\n    this.ranOut = false;\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/string_decoder/index.js\").StringDecoder);\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\nfunction Readable(options) {\n    if (!(this instanceof Readable)) return new Readable(options);\n    this._readableState = new ReadableState(options, this);\n    // legacy\n    this.readable = true;\n    Stream.call(this);\n}\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    var state = this._readableState;\n    if (typeof chunk === \"string\" && !state.objectMode) {\n        encoding = encoding || state.defaultEncoding;\n        if (encoding !== state.encoding) {\n            chunk = new Buffer(chunk, encoding);\n            encoding = \"\";\n        }\n    }\n    return readableAddChunk(this, state, chunk, encoding, false);\n};\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n    var state = this._readableState;\n    return readableAddChunk(this, state, chunk, \"\", true);\n};\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n    var er = chunkInvalid(state, chunk);\n    if (er) {\n        stream.emit(\"error\", er);\n    } else if (chunk === null || chunk === undefined) {\n        state.reading = false;\n        if (!state.ended) onEofChunk(stream, state);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n        if (state.ended && !addToFront) {\n            var e = new Error(\"stream.push() after EOF\");\n            stream.emit(\"error\", e);\n        } else if (state.endEmitted && addToFront) {\n            var e = new Error(\"stream.unshift() after end event\");\n            stream.emit(\"error\", e);\n        } else {\n            if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) {\n                state.buffer.unshift(chunk);\n            } else {\n                state.reading = false;\n                state.buffer.push(chunk);\n            }\n            if (state.needReadable) emitReadable(stream);\n            maybeReadMore(stream, state);\n        }\n    } else if (!addToFront) {\n        state.reading = false;\n    }\n    return needMoreData(state);\n}\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(ssr)/./node_modules/string_decoder/index.js\").StringDecoder);\n    this._readableState.decoder = new StringDecoder(enc);\n    this._readableState.encoding = enc;\n};\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n    if (n >= MAX_HWM) {\n        n = MAX_HWM;\n    } else {\n        // Get the next highest power of 2\n        n--;\n        for(var p = 1; p < 32; p <<= 1)n |= n >> p;\n        n++;\n    }\n    return n;\n}\nfunction howMuchToRead(n, state) {\n    if (state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return n === 0 ? 0 : 1;\n    if (n === null || isNaN(n)) {\n        // only flow one buffer at a time\n        if (state.flowing && state.buffer.length) return state.buffer[0].length;\n        else return state.length;\n    }\n    if (n <= 0) return 0;\n    // If we're asking for more than the target buffer level,\n    // then raise the water mark.  Bump up to the next highest\n    // power of 2, to prevent increasing it excessively in tiny\n    // amounts.\n    if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);\n    // don't have that much.  return null, unless we've ended.\n    if (n > state.length) {\n        if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n        } else return state.length;\n    }\n    return n;\n}\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    var state = this._readableState;\n    state.calledRead = true;\n    var nOrig = n;\n    var ret;\n    if (typeof n !== \"number\" || n > 0) state.emittedReadable = false;\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n        emitReadable(this);\n        return null;\n    }\n    n = howMuchToRead(n, state);\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        ret = null;\n        // In cases where the decoder did not receive enough data\n        // to produce a full chunk, then immediately received an\n        // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n        // howMuchToRead will see this and coerce the amount to\n        // read to zero (because it's looking at the length of the\n        // first <Buffer > in state.buffer), and we'll end up here.\n        //\n        // This can only happen via state.decoder -- no other venue\n        // exists for pushing a zero-length chunk into state.buffer\n        // and triggering this behavior. In this case, we return our\n        // remaining data and end the stream, if appropriate.\n        if (state.length > 0 && state.decoder) {\n            ret = fromList(n, state);\n            state.length -= ret.length;\n        }\n        if (state.length === 0) endReadable(this);\n        return ret;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length - n <= state.highWaterMark) doRead = true;\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) doRead = false;\n    if (doRead) {\n        state.reading = true;\n        state.sync = true;\n        // if the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n        // call internal read method\n        this._read(state.highWaterMark);\n        state.sync = false;\n    }\n    // If _read called its callback synchronously, then `reading`\n    // will be false, and we need to re-evaluate how much data we\n    // can return to the user.\n    if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n    if (n > 0) ret = fromList(n, state);\n    else ret = null;\n    if (ret === null) {\n        state.needReadable = true;\n        n = 0;\n    }\n    state.length -= n;\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (state.length === 0 && !state.ended) state.needReadable = true;\n    // If we happened to read() exactly the remaining amount in the\n    // buffer, and the EOF has been seen at this point, then make sure\n    // that we emit 'end' on the very next tick.\n    if (state.ended && !state.endEmitted && state.length === 0) endReadable(this);\n    return ret;\n};\nfunction chunkInvalid(state, chunk) {\n    var er = null;\n    if (!Buffer.isBuffer(chunk) && \"string\" !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {\n        er = new TypeError(\"Invalid non-string/buffer chunk\");\n    }\n    return er;\n}\nfunction onEofChunk(stream, state) {\n    if (state.decoder && !state.ended) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    // if we've ended and we have some data left, then emit\n    // 'readable' now to make sure it gets picked up.\n    if (state.length > 0) emitReadable(stream);\n    else endReadable(stream);\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    var state = stream._readableState;\n    state.needReadable = false;\n    if (state.emittedReadable) return;\n    state.emittedReadable = true;\n    if (state.sync) process.nextTick(function() {\n        emitReadable_(stream);\n    });\n    else emitReadable_(stream);\n}\nfunction emitReadable_(stream) {\n    stream.emit(\"readable\");\n}\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        state.readingMore = true;\n        process.nextTick(function() {\n            maybeReadMore_(stream, state);\n        });\n    }\n}\nfunction maybeReadMore_(stream, state) {\n    var len = state.length;\n    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){\n        stream.read(0);\n        if (len === state.length) break;\n        else len = state.length;\n    }\n    state.readingMore = false;\n}\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    this.emit(\"error\", new Error(\"not implemented\"));\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n    switch(state.pipesCount){\n        case 0:\n            state.pipes = dest;\n            break;\n        case 1:\n            state.pipes = [\n                state.pipes,\n                dest\n            ];\n            break;\n        default:\n            state.pipes.push(dest);\n            break;\n    }\n    state.pipesCount += 1;\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n    var endFn = doEnd ? onend : cleanup;\n    if (state.endEmitted) process.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable) {\n        if (readable !== src) return;\n        cleanup();\n    }\n    function onend() {\n        dest.end();\n    }\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on(\"drain\", ondrain);\n    function cleanup() {\n        // cleanup event handlers once the pipe is broken\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        dest.removeListener(\"drain\", ondrain);\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", cleanup);\n        // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (!dest._writableState || dest._writableState.needDrain) ondrain();\n    }\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (EE.listenerCount(dest, \"error\") === 0) dest.emit(\"error\", er);\n    }\n    // This is a brutally ugly hack to make sure that our error handler\n    // is attached before any userland ones.  NEVER DO THIS.\n    if (!dest._events || !dest._events.error) dest.on(\"error\", onerror);\n    else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);\n    else dest._events.error = [\n        onerror,\n        dest._events.error\n    ];\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n        src.unpipe(dest);\n    }\n    // tell the dest that it's being piped to\n    dest.emit(\"pipe\", src);\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n        // the handler that waits for readable events after all\n        // the data gets sucked out in flow.\n        // This would be easier to follow with a .once() handler\n        // in flow(), but that is too slow.\n        this.on(\"readable\", pipeOnReadable);\n        state.flowing = true;\n        process.nextTick(function() {\n            flow(src);\n        });\n    }\n    return dest;\n};\nfunction pipeOnDrain(src) {\n    return function() {\n        var dest = this;\n        var state = src._readableState;\n        state.awaitDrain--;\n        if (state.awaitDrain === 0) flow(src);\n    };\n}\nfunction flow(src) {\n    var state = src._readableState;\n    var chunk;\n    state.awaitDrain = 0;\n    function write(dest, i, list) {\n        var written = dest.write(chunk);\n        if (false === written) {\n            state.awaitDrain++;\n        }\n    }\n    while(state.pipesCount && null !== (chunk = src.read())){\n        if (state.pipesCount === 1) write(state.pipes, 0, null);\n        else forEach(state.pipes, write);\n        src.emit(\"data\", chunk);\n        // if anyone needs a drain, then we have to wait for that.\n        if (state.awaitDrain > 0) return;\n    }\n    // if every destination was unpiped, either before entering this\n    // function, or in the while loop, then stop flowing.\n    //\n    // NB: This is a pretty rare edge case.\n    if (state.pipesCount === 0) {\n        state.flowing = false;\n        // if there were data event listeners added, then switch to old mode.\n        if (EE.listenerCount(src, \"data\") > 0) emitDataEvents(src);\n        return;\n    }\n    // at this point, no one needed a drain, so we just ran out of data\n    // on the next readable event, start it over again.\n    state.ranOut = true;\n}\nfunction pipeOnReadable() {\n    if (this._readableState.ranOut) {\n        this._readableState.ranOut = false;\n        flow(this);\n    }\n}\nReadable.prototype.unpipe = function(dest) {\n    var state = this._readableState;\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0) return this;\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes) return this;\n        if (!dest) dest = state.pipes;\n        // got a match.\n        state.pipes = null;\n        state.pipesCount = 0;\n        this.removeListener(\"readable\", pipeOnReadable);\n        state.flowing = false;\n        if (dest) dest.emit(\"unpipe\", this);\n        return this;\n    }\n    // slow case. multiple pipe destinations.\n    if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        this.removeListener(\"readable\", pipeOnReadable);\n        state.flowing = false;\n        for(var i = 0; i < len; i++)dests[i].emit(\"unpipe\", this);\n        return this;\n    }\n    // try to find the right one.\n    var i = indexOf(state.pipes, dest);\n    if (i === -1) return this;\n    state.pipes.splice(i, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1) state.pipes = state.pipes[0];\n    dest.emit(\"unpipe\", this);\n    return this;\n};\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n    if (ev === \"data\" && !this._readableState.flowing) emitDataEvents(this);\n    if (ev === \"readable\" && this.readable) {\n        var state = this._readableState;\n        if (!state.readableListening) {\n            state.readableListening = true;\n            state.emittedReadable = false;\n            state.needReadable = true;\n            if (!state.reading) {\n                this.read(0);\n            } else if (state.length) {\n                emitReadable(this, state);\n            }\n        }\n    }\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    emitDataEvents(this);\n    this.read(0);\n    this.emit(\"resume\");\n};\nReadable.prototype.pause = function() {\n    emitDataEvents(this, true);\n    this.emit(\"pause\");\n};\nfunction emitDataEvents(stream, startPaused) {\n    var state = stream._readableState;\n    if (state.flowing) {\n        // https://github.com/isaacs/readable-stream/issues/16\n        throw new Error(\"Cannot switch to old mode now.\");\n    }\n    var paused = startPaused || false;\n    var readable = false;\n    // convert to an old-style stream.\n    stream.readable = true;\n    stream.pipe = Stream.prototype.pipe;\n    stream.on = stream.addListener = Stream.prototype.on;\n    stream.on(\"readable\", function() {\n        readable = true;\n        var c;\n        while(!paused && null !== (c = stream.read()))stream.emit(\"data\", c);\n        if (c === null) {\n            readable = false;\n            stream._readableState.needReadable = true;\n        }\n    });\n    stream.pause = function() {\n        paused = true;\n        this.emit(\"pause\");\n    };\n    stream.resume = function() {\n        paused = false;\n        if (readable) process.nextTick(function() {\n            stream.emit(\"readable\");\n        });\n        else this.read(0);\n        this.emit(\"resume\");\n    };\n    // now make it start, just in case it hadn't already.\n    stream.emit(\"readable\");\n}\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    var state = this._readableState;\n    var paused = false;\n    var self = this;\n    stream.on(\"end\", function() {\n        if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) self.push(chunk);\n        }\n        self.push(null);\n    });\n    stream.on(\"data\", function(chunk) {\n        if (state.decoder) chunk = state.decoder.write(chunk);\n        // don't skip over falsy values in objectMode\n        //if (state.objectMode && util.isNullOrUndefined(chunk))\n        if (state.objectMode && (chunk === null || chunk === undefined)) return;\n        else if (!state.objectMode && (!chunk || !chunk.length)) return;\n        var ret = self.push(chunk);\n        if (!ret) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for(var i in stream){\n        if (typeof stream[i] === \"function\" && typeof this[i] === \"undefined\") {\n            this[i] = function(method) {\n                return function() {\n                    return stream[method].apply(stream, arguments);\n                };\n            }(i);\n        }\n    }\n    // proxy certain important events.\n    var events = [\n        \"error\",\n        \"close\",\n        \"destroy\",\n        \"pause\",\n        \"resume\"\n    ];\n    forEach(events, function(ev) {\n        stream.on(ev, self.emit.bind(self, ev));\n    });\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    self._read = function(n) {\n        if (paused) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    return self;\n};\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n    var list = state.buffer;\n    var length = state.length;\n    var stringMode = !!state.decoder;\n    var objectMode = !!state.objectMode;\n    var ret;\n    // nothing in the list, definitely empty.\n    if (list.length === 0) return null;\n    if (length === 0) ret = null;\n    else if (objectMode) ret = list.shift();\n    else if (!n || n >= length) {\n        // read it all, truncate the array.\n        if (stringMode) ret = list.join(\"\");\n        else ret = Buffer.concat(list, length);\n        list.length = 0;\n    } else {\n        // read just some of it.\n        if (n < list[0].length) {\n            // just take a part of the first list item.\n            // slice is the same for buffers and strings.\n            var buf = list[0];\n            ret = buf.slice(0, n);\n            list[0] = buf.slice(n);\n        } else if (n === list[0].length) {\n            // first list is a perfect match\n            ret = list.shift();\n        } else {\n            // complex case.\n            // we have enough to cover it, but it spans past the first buffer.\n            if (stringMode) ret = \"\";\n            else ret = new Buffer(n);\n            var c = 0;\n            for(var i = 0, l = list.length; i < l && c < n; i++){\n                var buf = list[0];\n                var cpy = Math.min(n - c, buf.length);\n                if (stringMode) ret += buf.slice(0, cpy);\n                else buf.copy(ret, c, 0, cpy);\n                if (cpy < buf.length) list[0] = buf.slice(cpy);\n                else list.shift();\n                c += cpy;\n            }\n        }\n    }\n    return ret;\n}\nfunction endReadable(stream) {\n    var state = stream._readableState;\n    // If we get here before consuming all the bytes, then that is a\n    // bug in node.  Should never happen.\n    if (state.length > 0) throw new Error(\"endReadable called on non-empty stream\");\n    if (!state.endEmitted && state.calledRead) {\n        state.ended = true;\n        process.nextTick(function() {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n                state.endEmitted = true;\n                stream.readable = false;\n                stream.emit(\"end\");\n            }\n        });\n    }\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\nfunction indexOf(xs, x) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZUFBZSxHQUNmLElBQUlDLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3RCLGdCQUFnQixHQUdoQixlQUFlLEdBQ2YsSUFBSUMsU0FBU0Qsb0RBQXdCO0FBQ3JDLGdCQUFnQixHQUVoQkYsU0FBU0ksYUFBYSxHQUFHQTtBQUV6QixJQUFJQyxLQUFLSCwwREFBOEI7QUFFdkMsZUFBZSxHQUNmLElBQUksQ0FBQ0csR0FBR0UsYUFBYSxFQUFFRixHQUFHRSxhQUFhLEdBQUcsU0FBU0MsT0FBTyxFQUFFQyxJQUFJO0lBQzlELE9BQU9ELFFBQVFFLFNBQVMsQ0FBQ0QsTUFBTUUsTUFBTTtBQUN2QztBQUNBLGdCQUFnQixHQUVoQixJQUFJQyxTQUFTVixtQkFBT0EsQ0FBQztBQUVyQixlQUFlLEdBQ2YsSUFBSVcsT0FBT1gsbUJBQU9BLENBQUM7QUFDbkJXLEtBQUtDLFFBQVEsR0FBR1osbUJBQU9BLENBQUM7QUFDeEIsZ0JBQWdCLEdBRWhCLElBQUlhO0FBRUpGLEtBQUtDLFFBQVEsQ0FBQ2QsVUFBVVk7QUFFeEIsU0FBU1IsY0FBY1ksT0FBTyxFQUFFQyxNQUFNO0lBQ3BDRCxVQUFVQSxXQUFXLENBQUM7SUFFdEIsaUVBQWlFO0lBQ2pFLHVFQUF1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RVpWLEtBQUtnQjtZQUNQO1FBQ0Y7SUFDRjtJQUVBLE9BQU92RTtBQUNUO0FBRUEsU0FBU0UsWUFBWXZELE1BQU07SUFDekIsSUFBSTRCLFFBQVE1QixPQUFPc0IsY0FBYztJQUVqQyxnRUFBZ0U7SUFDaEUscUNBQXFDO0lBQ3JDLElBQUlNLE1BQU1sQyxNQUFNLEdBQUcsR0FDakIsTUFBTSxJQUFJNEMsTUFBTTtJQUVsQixJQUFJLENBQUNWLE1BQU1wQixVQUFVLElBQUlvQixNQUFNbEIsVUFBVSxFQUFFO1FBQ3pDa0IsTUFBTXJCLEtBQUssR0FBRztRQUNkc0QsUUFBUUMsUUFBUSxDQUFDO1lBQ2YsNkNBQTZDO1lBQzdDLElBQUksQ0FBQ2xDLE1BQU1wQixVQUFVLElBQUlvQixNQUFNbEMsTUFBTSxLQUFLLEdBQUc7Z0JBQzNDa0MsTUFBTXBCLFVBQVUsR0FBRztnQkFDbkJSLE9BQU91QixRQUFRLEdBQUc7Z0JBQ2xCdkIsT0FBT2tDLElBQUksQ0FBQztZQUNkO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBUzZELFFBQVNpQyxFQUFFLEVBQUVDLENBQUM7SUFDckIsSUFBSyxJQUFJckMsSUFBSSxHQUFHK0IsSUFBSUssR0FBR3RJLE1BQU0sRUFBRWtHLElBQUkrQixHQUFHL0IsSUFBSztRQUN6Q3FDLEVBQUVELEVBQUUsQ0FBQ3BDLEVBQUUsRUFBRUE7SUFDWDtBQUNGO0FBRUEsU0FBU00sUUFBUzhCLEVBQUUsRUFBRUUsQ0FBQztJQUNyQixJQUFLLElBQUl0QyxJQUFJLEdBQUcrQixJQUFJSyxHQUFHdEksTUFBTSxFQUFFa0csSUFBSStCLEdBQUcvQixJQUFLO1FBQ3pDLElBQUlvQyxFQUFFLENBQUNwQyxFQUFFLEtBQUtzQyxHQUFHLE9BQU90QztJQUMxQjtJQUNBLE9BQU8sQ0FBQztBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vS25vd2xlZGdlR3JhcGhRUy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanM/MjIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUuY2FsbGVkUmVhZCA9IHRydWU7XG4gIHZhciBuT3JpZyA9IG47XG4gIHZhciByZXQ7XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIHJldCA9IG51bGw7XG5cbiAgICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgZGVjb2RlciBkaWQgbm90IHJlY2VpdmUgZW5vdWdoIGRhdGFcbiAgICAvLyB0byBwcm9kdWNlIGEgZnVsbCBjaHVuaywgdGhlbiBpbW1lZGlhdGVseSByZWNlaXZlZCBhblxuICAgIC8vIEVPRiwgc3RhdGUuYnVmZmVyIHdpbGwgY29udGFpbiBbPEJ1ZmZlciA+LCA8QnVmZmVyIDAwIC4uLj5dLlxuICAgIC8vIGhvd011Y2hUb1JlYWQgd2lsbCBzZWUgdGhpcyBhbmQgY29lcmNlIHRoZSBhbW91bnQgdG9cbiAgICAvLyByZWFkIHRvIHplcm8gKGJlY2F1c2UgaXQncyBsb29raW5nIGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgLy8gZmlyc3QgPEJ1ZmZlciA+IGluIHN0YXRlLmJ1ZmZlciksIGFuZCB3ZSdsbCBlbmQgdXAgaGVyZS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHZpYSBzdGF0ZS5kZWNvZGVyIC0tIG5vIG90aGVyIHZlbnVlXG4gICAgLy8gZXhpc3RzIGZvciBwdXNoaW5nIGEgemVyby1sZW5ndGggY2h1bmsgaW50byBzdGF0ZS5idWZmZXJcbiAgICAvLyBhbmQgdHJpZ2dlcmluZyB0aGlzIGJlaGF2aW9yLiBJbiB0aGlzIGNhc2UsIHdlIHJldHVybiBvdXJcbiAgICAvLyByZW1haW5pbmcgZGF0YSBhbmQgZW5kIHRoZSBzdHJlYW0sIGlmIGFwcHJvcHJpYXRlLlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPiAwICYmIHN0YXRlLmRlY29kZXIpIHtcbiAgICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSByZXQubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIC8vIHRoZSBoYW5kbGVyIHRoYXQgd2FpdHMgZm9yIHJlYWRhYmxlIGV2ZW50cyBhZnRlciBhbGxcbiAgICAvLyB0aGUgZGF0YSBnZXRzIHN1Y2tlZCBvdXQgaW4gZmxvdy5cbiAgICAvLyBUaGlzIHdvdWxkIGJlIGVhc2llciB0byBmb2xsb3cgd2l0aCBhIC5vbmNlKCkgaGFuZGxlclxuICAgIC8vIGluIGZsb3coKSwgYnV0IHRoYXQgaXMgdG9vIHNsb3cuXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICAvL2lmIChzdGF0ZS5vYmplY3RNb2RlICYmIHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUuY2FsbGVkUmVhZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiUmVhZGFibGUiLCJpc0FycmF5IiwicmVxdWlyZSIsIkJ1ZmZlciIsIlJlYWRhYmxlU3RhdGUiLCJFRSIsIkV2ZW50RW1pdHRlciIsImxpc3RlbmVyQ291bnQiLCJlbWl0dGVyIiwidHlwZSIsImxpc3RlbmVycyIsImxlbmd0aCIsIlN0cmVhbSIsInV0aWwiLCJpbmhlcml0cyIsIlN0cmluZ0RlY29kZXIiLCJvcHRpb25zIiwic3RyZWFtIiwiaHdtIiwiaGlnaFdhdGVyTWFyayIsImJ1ZmZlciIsInBpcGVzIiwicGlwZXNDb3VudCIsImZsb3dpbmciLCJlbmRlZCIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwiY2FsbGVkUmVhZCIsInN5bmMiLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsIm9iamVjdE1vZGUiLCJkZWZhdWx0RW5jb2RpbmciLCJyYW5PdXQiLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiZW5jb2RpbmciLCJfcmVhZGFibGVTdGF0ZSIsInJlYWRhYmxlIiwiY2FsbCIsInByb3RvdHlwZSIsInB1c2giLCJjaHVuayIsInN0YXRlIiwicmVhZGFibGVBZGRDaHVuayIsInVuc2hpZnQiLCJhZGRUb0Zyb250IiwiZXIiLCJjaHVua0ludmFsaWQiLCJlbWl0IiwidW5kZWZpbmVkIiwib25Fb2ZDaHVuayIsImUiLCJFcnJvciIsIndyaXRlIiwiZW1pdFJlYWRhYmxlIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsInNldEVuY29kaW5nIiwiZW5jIiwiTUFYX0hXTSIsInJvdW5kVXBUb05leHRQb3dlck9mMiIsIm4iLCJwIiwiaG93TXVjaFRvUmVhZCIsImlzTmFOIiwicmVhZCIsIm5PcmlnIiwicmV0IiwiZnJvbUxpc3QiLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsIl9yZWFkIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJlbmQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0UmVhZGFibGVfIiwibWF5YmVSZWFkTW9yZV8iLCJsZW4iLCJwaXBlIiwiZGVzdCIsInBpcGVPcHRzIiwic3JjIiwiZG9FbmQiLCJzdGRvdXQiLCJzdGRlcnIiLCJlbmRGbiIsIm9uZW5kIiwiY2xlYW51cCIsIm9uY2UiLCJvbiIsIm9udW5waXBlIiwib25kcmFpbiIsInBpcGVPbkRyYWluIiwicmVtb3ZlTGlzdGVuZXIiLCJvbmNsb3NlIiwib25maW5pc2giLCJvbmVycm9yIiwiX3dyaXRhYmxlU3RhdGUiLCJuZWVkRHJhaW4iLCJ1bnBpcGUiLCJfZXZlbnRzIiwiZXJyb3IiLCJwaXBlT25SZWFkYWJsZSIsImZsb3ciLCJpIiwibGlzdCIsIndyaXR0ZW4iLCJmb3JFYWNoIiwiZW1pdERhdGFFdmVudHMiLCJkZXN0cyIsImluZGV4T2YiLCJzcGxpY2UiLCJldiIsImZuIiwicmVzIiwiYWRkTGlzdGVuZXIiLCJyZXN1bWUiLCJwYXVzZSIsInN0YXJ0UGF1c2VkIiwicGF1c2VkIiwiYyIsIndyYXAiLCJzZWxmIiwibWV0aG9kIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJldmVudHMiLCJiaW5kIiwiX2Zyb21MaXN0Iiwic3RyaW5nTW9kZSIsInNoaWZ0Iiwiam9pbiIsImNvbmNhdCIsImJ1ZiIsInNsaWNlIiwibCIsImNweSIsIk1hdGgiLCJtaW4iLCJjb3B5IiwieHMiLCJmIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\nmodule.exports = Transform;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(Transform, Duplex);\nfunction TransformState(options, stream) {\n    this.afterTransform = function(er, data) {\n        return afterTransform(stream, er, data);\n    };\n    this.needTransform = false;\n    this.transforming = false;\n    this.writecb = null;\n    this.writechunk = null;\n}\nfunction afterTransform(stream, er, data) {\n    var ts = stream._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (!cb) return stream.emit(\"error\", new Error(\"no writecb in Transform class\"));\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data !== null && data !== undefined) stream.push(data);\n    if (cb) cb(er);\n    var rs = stream._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        stream._read(rs.highWaterMark);\n    }\n}\nfunction Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    var ts = this._transformState = new TransformState(options, this);\n    // when the writable side finishes, then flush out anything remaining.\n    var stream = this;\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    this.once(\"finish\", function() {\n        if (\"function\" === typeof this._flush) this._flush(function(er) {\n            done(stream, er);\n        });\n        else done(stream);\n    });\n}\nTransform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n};\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n    throw new Error(\"not implemented\");\n};\nTransform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n};\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n    var ts = this._transformState;\n    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n        ts.transforming = true;\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n    }\n};\nfunction done(stream, er) {\n    if (er) return stream.emit(\"error\", er);\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    var ws = stream._writableState;\n    var rs = stream._readableState;\n    var ts = stream._transformState;\n    if (ws.length) throw new Error(\"calling transform done when ws.length != 0\");\n    if (ts.transforming) throw new Error(\"calling transform done when still transforming\");\n    return stream.push(null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBR3pDLGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQsdUVBQXVFO0FBQ3ZFLHNFQUFzRTtBQUN0RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxxRUFBcUU7QUFDckUsa0VBQWtFO0FBQ2xFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUsc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSxnRUFBZ0U7QUFDaEUsb0RBQW9EO0FBQ3BELEVBQUU7QUFDRix1RUFBdUU7QUFDdkUsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSx1RUFBdUU7QUFDdkUscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RSxxRUFBcUU7QUFDckUsb0VBQW9FO0FBQ3BFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLHlFQUF5RTtBQUN6RSwrREFBK0Q7QUFFL0RBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsU0FB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SixHQUFHSCxZQUFZLEVBQ2pCLE1BQU0sSUFBSU8sTUFBTTtJQUVsQixPQUFPWixPQUFPYyxJQUFJLENBQUM7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanM/MjQyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJUcmFuc2Zvcm0iLCJEdXBsZXgiLCJyZXF1aXJlIiwidXRpbCIsImluaGVyaXRzIiwiVHJhbnNmb3JtU3RhdGUiLCJvcHRpb25zIiwic3RyZWFtIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJlciIsImRhdGEiLCJuZWVkVHJhbnNmb3JtIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjYiIsIndyaXRlY2h1bmsiLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsImNiIiwiZW1pdCIsIkVycm9yIiwidW5kZWZpbmVkIiwicHVzaCIsInJzIiwiX3JlYWRhYmxlU3RhdGUiLCJyZWFkaW5nIiwibmVlZFJlYWRhYmxlIiwibGVuZ3RoIiwiaGlnaFdhdGVyTWFyayIsIl9yZWFkIiwiY2FsbCIsInN5bmMiLCJvbmNlIiwiX2ZsdXNoIiwiZG9uZSIsInByb3RvdHlwZSIsImNodW5rIiwiZW5jb2RpbmciLCJfdHJhbnNmb3JtIiwiX3dyaXRlIiwid3JpdGVlbmNvZGluZyIsIm4iLCJ3cyIsIl93cml0YWJsZVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\nmodule.exports = Writable;\n/*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Writable.WritableState = WritableState;\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(ssr)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\nutil.inherits(Writable, Stream);\nfunction WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n}\nfunction WritableState(options, stream) {\n    options = options || {};\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    var hwm = options.highWaterMark;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, becuase any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n    this.buffer = [];\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n}\nfunction Writable(options) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(ssr)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n    // Writable ctor is applied to Duplexes, though they're not\n    // instanceof Writable, they're instanceof Readable.\n    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n    this._writableState = new WritableState(options, this);\n    // legacy.\n    this.writable = true;\n    Stream.call(this);\n}\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    this.emit(\"error\", new Error(\"Cannot pipe. Not readable.\"));\n};\nfunction writeAfterEnd(stream, state, cb) {\n    var er = new Error(\"write after end\");\n    // TODO: defer error events consistently everywhere, not just the cb\n    stream.emit(\"error\", er);\n    process.nextTick(function() {\n        cb(er);\n    });\n}\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    if (!Buffer.isBuffer(chunk) && \"string\" !== typeof chunk && chunk !== null && chunk !== undefined && !state.objectMode) {\n        var er = new TypeError(\"Invalid non-string/buffer chunk\");\n        stream.emit(\"error\", er);\n        process.nextTick(function() {\n            cb(er);\n        });\n        valid = false;\n    }\n    return valid;\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n    if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (Buffer.isBuffer(chunk)) encoding = \"buffer\";\n    else if (!encoding) encoding = state.defaultEncoding;\n    if (typeof cb !== \"function\") cb = function() {};\n    if (state.ended) writeAfterEnd(this, state, cb);\n    else if (validChunk(this, state, chunk, cb)) ret = writeOrBuffer(this, state, chunk, encoding, cb);\n    return ret;\n};\nfunction decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === \"string\") {\n        chunk = new Buffer(chunk, encoding);\n    }\n    return chunk;\n}\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (Buffer.isBuffer(chunk)) encoding = \"buffer\";\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing) state.buffer.push(new WriteReq(chunk, encoding, cb));\n    else doWrite(stream, state, len, chunk, encoding, cb);\n    return ret;\n}\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n    if (sync) process.nextTick(function() {\n        cb(er);\n    });\n    else cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit(\"error\", er);\n}\nfunction onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb);\n    else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(stream, state);\n        if (!finished && !state.bufferProcessing && state.buffer.length) clearBuffer(stream, state);\n        if (sync) {\n            process.nextTick(function() {\n                afterWrite(stream, state, finished, cb);\n            });\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}\nfunction afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    cb();\n    if (finished) finishMaybe(stream, state);\n}\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n    }\n}\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    for(var c = 0; c < state.buffer.length; c++){\n        var entry = state.buffer[c];\n        var chunk = entry.chunk;\n        var encoding = entry.encoding;\n        var cb = entry.callback;\n        var len = state.objectMode ? 1 : chunk.length;\n        doWrite(stream, state, len, chunk, encoding, cb);\n        // if we didn't call the onwrite immediately, then\n        // it means that we need to wait until it does.\n        // also, that means that the chunk and cb are currently\n        // being processed, so move the buffer counter past them.\n        if (state.writing) {\n            c++;\n            break;\n        }\n    }\n    state.bufferProcessing = false;\n    if (c < state.buffer.length) state.buffer = state.buffer.slice(c);\n    else state.buffer.length = 0;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n    cb(new Error(\"not implemented\"));\n};\nWritable.prototype.end = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n    }\n    if (typeof chunk !== \"undefined\" && chunk !== null) this.write(chunk, encoding);\n    // ignore unnecessary end() calls.\n    if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\nfunction needFinish(stream, state) {\n    return state.ending && state.length === 0 && !state.finished && !state.writing;\n}\nfunction finishMaybe(stream, state) {\n    var need = needFinish(stream, state);\n    if (need) {\n        state.finished = true;\n        stream.emit(\"finish\");\n    }\n    return need;\n}\nfunction endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) process.nextTick(cb);\n        else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsdUNBQXVDO0FBQ3ZDLDhEQUE4RDtBQUM5RCwwQ0FBMEM7QUFFMUNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZUFBZSxHQUNmLElBQUlDLFNBQVNDLG9EQUF3QjtBQUNyQyxnQkFBZ0IsR0FFaEJGLFNBQVNHLGFBQWEsR0FBR0E7QUFHekIsZUFBZSxHQUNmLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CRSxLQUFLQyxRQUFRLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQixJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQztBQUVyQkUsS0FBS0MsUUFBUSxDQUFDTCxVQUFVTTtBQUV4QixTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsRUFBRTtJQUNuQyxJQUFJLENBQUNGLEtBQUssR0FBR0E7SUFDYixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDRSxRQUFRLEdBQUdEO0FBQ2xCO0FBRUEsU0FBU1AsY0FBY1MsT0FBTyxFQUFFQyxNQUFNO0lBQ3BDRCxVQUFVQSxXQUFXLENBQUM7SUFFdEIsb0RBQW9EO0lBQ3BELGlFQUFpRTtJQUNqRSwwREFBMEQ7SUFDMUQsSUFBSUUsTUFBTUYsUUFBUUcsYUFBYTtJQUMvQixJQUFJLENB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L0JFLEtBQUtGO1FBQ0xBLFFBQVE7UUFDUkMsV0FBVztJQUNiLE9BQU8sSUFBSSxPQUFPQSxhQUFhLFlBQVk7UUFDekNDLEtBQUtEO1FBQ0xBLFdBQVc7SUFDYjtJQUVBLElBQUksT0FBT0QsVUFBVSxlQUFlQSxVQUFVLE1BQzVDLElBQUksQ0FBQzJDLEtBQUssQ0FBQzNDLE9BQU9DO0lBRXBCLGtDQUFrQztJQUNsQyxJQUFJLENBQUNrQyxNQUFNekIsTUFBTSxJQUFJLENBQUN5QixNQUFNdkIsUUFBUSxFQUNsQ2tELFlBQVksSUFBSSxFQUFFM0IsT0FBT2pDO0FBQzdCO0FBR0EsU0FBU21ELFdBQVdoRCxNQUFNLEVBQUU4QixLQUFLO0lBQy9CLE9BQVFBLE1BQU16QixNQUFNLElBQ1p5QixNQUFNbkIsTUFBTSxLQUFLLEtBQ2pCLENBQUNtQixNQUFNdkIsUUFBUSxJQUNmLENBQUN1QixNQUFNbEIsT0FBTztBQUN4QjtBQUVBLFNBQVN3QyxZQUFZcEQsTUFBTSxFQUFFOEIsS0FBSztJQUNoQyxJQUFJNEIsT0FBT1YsV0FBV2hELFFBQVE4QjtJQUM5QixJQUFJNEIsTUFBTTtRQUNSNUIsTUFBTXZCLFFBQVEsR0FBRztRQUNqQlAsT0FBTzJCLElBQUksQ0FBQztJQUNkO0lBQ0EsT0FBTytCO0FBQ1Q7QUFFQSxTQUFTRCxZQUFZekQsTUFBTSxFQUFFOEIsS0FBSyxFQUFFakMsRUFBRTtJQUNwQ2lDLE1BQU16QixNQUFNLEdBQUc7SUFDZitDLFlBQVlwRCxRQUFROEI7SUFDcEIsSUFBSWpDLElBQUk7UUFDTixJQUFJaUMsTUFBTXZCLFFBQVEsRUFDaEJ3QixRQUFRQyxRQUFRLENBQUNuQzthQUVqQkcsT0FBTzJELElBQUksQ0FBQyxVQUFVOUQ7SUFDMUI7SUFDQWlDLE1BQU14QixLQUFLLEdBQUc7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz9jZjFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJXcml0YWJsZSIsIkJ1ZmZlciIsInJlcXVpcmUiLCJXcml0YWJsZVN0YXRlIiwidXRpbCIsImluaGVyaXRzIiwiU3RyZWFtIiwiV3JpdGVSZXEiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJzdHJlYW0iLCJod20iLCJoaWdoV2F0ZXJNYXJrIiwib2JqZWN0TW9kZSIsIm5lZWREcmFpbiIsImVuZGluZyIsImVuZGVkIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJsZW5ndGgiLCJ3cml0aW5nIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwiZXIiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJidWZmZXIiLCJlcnJvckVtaXR0ZWQiLCJEdXBsZXgiLCJfd3JpdGFibGVTdGF0ZSIsIndyaXRhYmxlIiwiY2FsbCIsInByb3RvdHlwZSIsInBpcGUiLCJlbWl0IiwiRXJyb3IiLCJ3cml0ZUFmdGVyRW5kIiwic3RhdGUiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZmZlciIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsIndyaXRlIiwicmV0Iiwid3JpdGVPckJ1ZmZlciIsImRlY29kZUNodW5rIiwibGVuIiwicHVzaCIsImRvV3JpdGUiLCJfd3JpdGUiLCJvbndyaXRlRXJyb3IiLCJvbndyaXRlU3RhdGVVcGRhdGUiLCJuZWVkRmluaXNoIiwiY2xlYXJCdWZmZXIiLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiZmluaXNoTWF5YmUiLCJjIiwiZW50cnkiLCJzbGljZSIsImVuZCIsImVuZFdyaXRhYmxlIiwibmVlZCIsIm9uY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/readable-stream/readable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\"); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(ssr)/./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(ssr)/./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(ssr)/./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(ssr)/./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(ssr)/./node_modules/readable-stream/lib/_stream_passthrough.js\");\nif ( true && process.env.READABLE_STREAM === \"disable\") {\n    module.exports = __webpack_require__(/*! stream */ \"stream\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDLHlCQUFXLG9FQUFvRTtBQUNwR0MsVUFBVUMscUlBQXlCO0FBQ25DRCxjQUFjLEdBQUdGO0FBQ2pCRSxnQkFBZ0IsR0FBR0E7QUFDbkJBLHVJQUEyQjtBQUMzQkEsaUlBQXlCO0FBQ3pCQSwwSUFBNEI7QUFDNUJBLGdKQUE4QjtBQUM5QixJQUFJLEtBQWdCLElBQUlPLFFBQVFFLEdBQUcsQ0FBQ0MsZUFBZSxLQUFLLFdBQVc7SUFDakVULDREQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL0tub3dsZWRnZUdyYXBoUVMvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzP2E3YTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdzdHJlYW0nKTtcbn1cbiJdLCJuYW1lcyI6WyJTdHJlYW0iLCJyZXF1aXJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJEdXBsZXgiLCJUcmFuc2Zvcm0iLCJQYXNzVGhyb3VnaCIsInByb2Nlc3MiLCJicm93c2VyIiwiZW52IiwiUkVBREFCTEVfU1RSRUFNIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/readable-stream/readable.js\n");

/***/ })

};
;