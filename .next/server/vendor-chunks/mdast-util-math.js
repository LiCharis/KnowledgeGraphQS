"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-math";
exports.ids = ["vendor-chunks/mdast-util-math"];
exports.modules = {

/***/ "(ssr)/./node_modules/mdast-util-math/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mdast-util-math/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mathFromMarkdown: () => (/* binding */ mathFromMarkdown),\n/* harmony export */   mathToMarkdown: () => (/* binding */ mathToMarkdown)\n/* harmony export */ });\n/* harmony import */ var longest_streak__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! longest-streak */ \"(ssr)/./node_modules/longest-streak/index.js\");\n/* harmony import */ var mdast_util_to_markdown_lib_util_safe_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-to-markdown/lib/util/safe.js */ \"(ssr)/./node_modules/mdast-util-to-markdown/lib/util/safe.js\");\n/* harmony import */ var mdast_util_to_markdown_lib_util_track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-to-markdown/lib/util/track.js */ \"(ssr)/./node_modules/mdast-util-to-markdown/lib/util/track.js\");\n/* harmony import */ var mdast_util_to_markdown_lib_util_pattern_compile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mdast-util-to-markdown/lib/util/pattern-compile.js */ \"(ssr)/./node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js\");\n/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */ \n\n\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */ function mathFromMarkdown() {\n    return {\n        enter: {\n            mathFlow: enterMathFlow,\n            mathFlowFenceMeta: enterMathFlowMeta,\n            mathText: enterMathText\n        },\n        exit: {\n            mathFlow: exitMathFlow,\n            mathFlowFence: exitMathFlowFence,\n            mathFlowFenceMeta: exitMathFlowMeta,\n            mathFlowValue: exitMathData,\n            mathText: exitMathText,\n            mathTextData: exitMathData\n        }\n    };\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMathFlow(token) {\n        this.enter({\n            type: \"math\",\n            meta: null,\n            value: \"\",\n            data: {\n                hName: \"div\",\n                hProperties: {\n                    className: [\n                        \"math\",\n                        \"math-display\"\n                    ]\n                },\n                hChildren: [\n                    {\n                        type: \"text\",\n                        value: \"\"\n                    }\n                ]\n            }\n        }, token);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMathFlowMeta() {\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMathFlowMeta() {\n        const data = this.resume();\n        const node = /** @type {Math} */ this.stack[this.stack.length - 1];\n        node.meta = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMathFlowFence() {\n        // Exit if this is the closing fence.\n        if (this.getData(\"mathFlowInside\")) return;\n        this.buffer();\n        this.setData(\"mathFlowInside\", true);\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMathFlow(token) {\n        const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n        const node = /** @type {Math} */ this.exit(token);\n        node.value = data;\n        // @ts-expect-error: we defined it.\n        node.data.hChildren[0].value = data;\n        this.setData(\"mathFlowInside\");\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function enterMathText(token) {\n        this.enter({\n            type: \"inlineMath\",\n            value: \"\",\n            data: {\n                hName: \"span\",\n                hProperties: {\n                    className: [\n                        \"math\",\n                        \"math-inline\"\n                    ]\n                },\n                hChildren: [\n                    {\n                        type: \"text\",\n                        value: \"\"\n                    }\n                ]\n            }\n        }, token);\n        this.buffer();\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMathText(token) {\n        const data = this.resume();\n        const node = /** @type {Math} */ this.exit(token);\n        node.value = data;\n        // @ts-expect-error: we defined it.\n        node.data.hChildren[0].value = data;\n    }\n    /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */ function exitMathData(token) {\n        this.config.enter.data.call(this, token);\n        this.config.exit.data.call(this, token);\n    }\n}\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */ function mathToMarkdown(options) {\n    let single = (options || {}).singleDollarTextMath;\n    if (single === null || single === undefined) {\n        single = true;\n    }\n    inlineMath.peek = inlineMathPeek;\n    return {\n        unsafe: [\n            {\n                character: \"\\r\",\n                inConstruct: \"mathFlowMeta\"\n            },\n            {\n                character: \"\\n\",\n                inConstruct: \"mathFlowMeta\"\n            },\n            {\n                character: \"$\",\n                after: single ? undefined : \"\\\\$\",\n                inConstruct: \"phrasing\"\n            },\n            {\n                character: \"$\",\n                inConstruct: \"mathFlowMeta\"\n            },\n            {\n                atBreak: true,\n                character: \"$\",\n                after: \"\\\\$\"\n            }\n        ],\n        handlers: {\n            math,\n            inlineMath\n        }\n    };\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */ // To do: next major: rename `context` to state, `safeOptions` to info.\n    // Note: fixing this code? Please also fix the similar code for code:\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n    function math(node, _, context, safeOptions) {\n        const raw = node.value || \"\";\n        const tracker = (0,mdast_util_to_markdown_lib_util_track_js__WEBPACK_IMPORTED_MODULE_0__.track)(safeOptions);\n        const sequence = \"$\".repeat(Math.max((0,longest_streak__WEBPACK_IMPORTED_MODULE_1__.longestStreak)(raw, \"$\") + 1, 2));\n        const exit = context.enter(\"mathFlow\");\n        let value = tracker.move(sequence);\n        if (node.meta) {\n            const subexit = context.enter(\"mathFlowMeta\");\n            value += tracker.move((0,mdast_util_to_markdown_lib_util_safe_js__WEBPACK_IMPORTED_MODULE_2__.safe)(context, node.meta, {\n                before: value,\n                after: \"\\n\",\n                encode: [\n                    \"$\"\n                ],\n                ...tracker.current()\n            }));\n            subexit();\n        }\n        value += tracker.move(\"\\n\");\n        if (raw) {\n            value += tracker.move(raw + \"\\n\");\n        }\n        value += tracker.move(sequence);\n        exit();\n        return value;\n    }\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */ // Note: fixing this code? Please also fix the similar code for inline code:\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n    //\n    // To do: next major: rename `context` to state.\n    // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n    function inlineMath(node, _, context) {\n        let value = node.value || \"\";\n        let size = 1;\n        if (!single) size++;\n        // If there is a single dollar sign on its own in the math, use a fence of\n        // two.\n        // If there are two in a row, use one.\n        while(new RegExp(\"(^|[^$])\" + \"\\\\$\".repeat(size) + \"([^$]|$)\").test(value)){\n            size++;\n        }\n        const sequence = \"$\".repeat(size);\n        // If this is not just spaces or eols (tabs don’t count), and either the\n        // first and last character are a space or eol, or the first or last\n        // character are dollar signs, then pad with spaces.\n        if (// Contains non-space.\n        /[^ \\r\\n]/.test(value) && // Starts with space and ends with space.\n        (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))) {\n            value = \" \" + value + \" \";\n        }\n        let index = -1;\n        // We have a potential problem: certain characters after eols could result in\n        // blocks being seen.\n        // For example, if someone injected the string `'\\n# b'`, then that would\n        // result in an ATX heading.\n        // We can’t escape characters in `inlineMath`, but because eols are\n        // transformed to spaces when going from markdown to HTML anyway, we can swap\n        // them out.\n        while(++index < context.unsafe.length){\n            const pattern = context.unsafe[index];\n            const expression = (0,mdast_util_to_markdown_lib_util_pattern_compile_js__WEBPACK_IMPORTED_MODULE_3__.patternCompile)(pattern);\n            /** @type {RegExpExecArray | null} */ let match;\n            // Only look for `atBreak`s.\n            // Btw: note that `atBreak` patterns will always start the regex at LF or\n            // CR.\n            if (!pattern.atBreak) continue;\n            while(match = expression.exec(value)){\n                let position = match.index;\n                // Support CRLF (patterns only look for one of the characters).\n                if (value.codePointAt(position) === 10 /* `\\n` */  && value.codePointAt(position - 1) === 13 /* `\\r` */ ) {\n                    position--;\n                }\n                value = value.slice(0, position) + \" \" + value.slice(match.index + 1);\n            }\n        }\n        return sequence + value + sequence;\n    }\n    /**\n   * @returns {string}\n   */ function inlineMathPeek() {\n        return \"$\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1tYXRoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFMkM7QUFDZ0I7QUFDRTtBQUNtQjtBQUVqRjs7Ozs7Q0FLQyxHQUNNLFNBQVNJO0lBQ2QsT0FBTztRQUNMQyxPQUFPO1lBQ0xDLFVBQVVDO1lBQ1ZDLG1CQUFtQkM7WUFDbkJDLFVBQVVDO1FBQ1o7UUFDQUMsTUFBTTtZQUNKTixVQUFVTztZQUNWQyxlQUFlQztZQUNmUCxtQkFBbUJRO1lBQ25CQyxlQUFlQztZQUNmUixVQUFVUztZQUNWQyxjQUFjRjtRQUNoQjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsU0FBU1gsY0FBY2MsS0FBSztRQUMxQixJQUFJLENBQUNoQixLQUFLLENBQ1I7WUFDRWlCLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLE1BQU07Z0JBQ0pDLE9BQU87Z0JBQ1BDLGFBQWE7b0JBQUNDLFdBQVc7d0JBQUM7d0JBQVE7cUJBQWU7Z0JBQUE7Z0JBQ2pEQyxXQUFXO29CQUFDO3dCQUFDUCxNQUFNO3dCQUFRRSxPQUFPO29CQUFFO2lCQUFFO1lBQ3hDO1FBQ0YsR0FDQUg7SUFFSjtJQUVBOzs7R0FHQyxHQUNELFNBQVNaO1FBQ1AsSUFBSSxDQUFDcUIsTUFBTTtJQUNiO0lBRUE7OztHQUdDLEdBQ0QsU0FBU2Q7UUFDUCxNQUFNUyxPQUFPLElBQUksQ0FBQ00sTUFBTTtRQUN4QixNQUFNQyxPQUFPLGlCQUFpQixHQUFJLElBQUksQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDQyxNQUFNLEdBQUcsRUFBRTtRQUNuRUYsS0FBS1QsSUFBSSxHQUFHRTtJQUNkO0lBRUE7OztHQUdDLEdBQ0QsU0FBU1Y7UUFDUCxxQ0FBcUM7UUFDckMsSUFBSSxJQUFJLENBQUNvQixPQUFPLENBQUMsbUJBQW1CO1FBQ3BDLElBQUksQ0FBQ0wsTUFBTTtRQUNYLElB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RWIsNkVBQTZFO1FBQzdFLHFCQUFxQjtRQUNyQix5RUFBeUU7UUFDekUsNEJBQTRCO1FBQzVCLG1FQUFtRTtRQUNuRSw2RUFBNkU7UUFDN0UsWUFBWTtRQUNaLE1BQU8sRUFBRUEsUUFBUWhCLFFBQVFSLE1BQU0sQ0FBQ2QsTUFBTSxDQUFFO1lBQ3RDLE1BQU11QyxVQUFVakIsUUFBUVIsTUFBTSxDQUFDd0IsTUFBTTtZQUNyQyxNQUFNRSxhQUFhdkUsa0dBQWNBLENBQUNzRTtZQUNsQyxtQ0FBbUMsR0FDbkMsSUFBSUU7WUFFSiw0QkFBNEI7WUFDNUIseUVBQXlFO1lBQ3pFLE1BQU07WUFDTixJQUFJLENBQUNGLFFBQVFyQixPQUFPLEVBQUU7WUFFdEIsTUFBUXVCLFFBQVFELFdBQVdFLElBQUksQ0FBQ3BELE9BQVM7Z0JBQ3ZDLElBQUlxRCxXQUFXRixNQUFNSCxLQUFLO2dCQUUxQiwrREFBK0Q7Z0JBQy9ELElBQ0VoRCxNQUFNc0QsV0FBVyxDQUFDRCxjQUFjLEdBQUcsUUFBUSxPQUMzQ3JELE1BQU1zRCxXQUFXLENBQUNELFdBQVcsT0FBTyxHQUFHLFFBQVEsS0FDL0M7b0JBQ0FBO2dCQUNGO2dCQUVBckQsUUFBUUEsTUFBTXVELEtBQUssQ0FBQyxHQUFHRixZQUFZLE1BQU1yRCxNQUFNdUQsS0FBSyxDQUFDSixNQUFNSCxLQUFLLEdBQUc7WUFDckU7UUFDRjtRQUVBLE9BQU9aLFdBQVdwQyxRQUFRb0M7SUFDNUI7SUFFQTs7R0FFQyxHQUNELFNBQVNiO1FBQ1AsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Lbm93bGVkZ2VHcmFwaFFTLy4vbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtbWF0aC9saWIvaW5kZXguanM/MGZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkNvbXBpbGVDb250ZXh0fSBDb21waWxlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vaW5kZXguanMnKS5NYXRofSBNYXRoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9pbmRleC5qcycpLklubGluZU1hdGh9IElubGluZU1hdGhcbiAqXG4gKiBAdHlwZWRlZiBUb09wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtzaW5nbGVEb2xsYXJUZXh0TWF0aD10cnVlXVxuICogICBXaGV0aGVyIHRvIHN1cHBvcnQgbWF0aCAodGV4dCkgd2l0aCBhIHNpbmdsZSBkb2xsYXIuXG4gKlxuICogICBTaW5nbGUgZG9sbGFycyB3b3JrIGluIFBhbmRvYyBhbmQgbWFueSBvdGhlciBwbGFjZXMsIGJ1dCBvZnRlbiBpbnRlcmZlcmVcbiAqICAgd2l0aCDigJxub3JtYWzigJ0gZG9sbGFycyBpbiB0ZXh0LlxuICogICBJZiB5b3UgdHVybiB0aGlzIG9mZiwgeW91IGNhbiBzdGlsbCB1c2UgdHdvIG9yIG1vcmUgZG9sbGFycyBmb3IgdGV4dCBtYXRoLlxuICovXG5cbmltcG9ydCB7bG9uZ2VzdFN0cmVha30gZnJvbSAnbG9uZ2VzdC1zdHJlYWsnXG5pbXBvcnQge3NhZmV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvc2FmZS5qcydcbmltcG9ydCB7dHJhY2t9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvdHJhY2suanMnXG5pbXBvcnQge3BhdHRlcm5Db21waWxlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3BhdHRlcm4tY29tcGlsZS5qcydcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYC5cbiAqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0aEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlcjoge1xuICAgICAgbWF0aEZsb3c6IGVudGVyTWF0aEZsb3csXG4gICAgICBtYXRoRmxvd0ZlbmNlTWV0YTogZW50ZXJNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoVGV4dDogZW50ZXJNYXRoVGV4dFxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbWF0aEZsb3c6IGV4aXRNYXRoRmxvdyxcbiAgICAgIG1hdGhGbG93RmVuY2U6IGV4aXRNYXRoRmxvd0ZlbmNlLFxuICAgICAgbWF0aEZsb3dGZW5jZU1ldGE6IGV4aXRNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoRmxvd1ZhbHVlOiBleGl0TWF0aERhdGEsXG4gICAgICBtYXRoVGV4dDogZXhpdE1hdGhUZXh0LFxuICAgICAgbWF0aFRleHREYXRhOiBleGl0TWF0aERhdGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNYXRoRmxvdyh0b2tlbikge1xuICAgIHRoaXMuZW50ZXIoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdtYXRoJyxcbiAgICAgICAgbWV0YTogbnVsbCxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaE5hbWU6ICdkaXYnLFxuICAgICAgICAgIGhQcm9wZXJ0aWVzOiB7Y2xhc3NOYW1lOiBbJ21hdGgnLCAnbWF0aC1kaXNwbGF5J119LFxuICAgICAgICAgIGhDaGlsZHJlbjogW3t0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbnRlck1hdGhGbG93TWV0YSgpIHtcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93TWV0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXN1bWUoKVxuICAgIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge01hdGh9ICovICh0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0pXG4gICAgbm9kZS5tZXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGV4aXRNYXRoRmxvd0ZlbmNlKCkge1xuICAgIC8vIEV4aXQgaWYgdGhpcyBpcyB0aGUgY2xvc2luZyBmZW5jZS5cbiAgICBpZiAodGhpcy5nZXREYXRhKCdtYXRoRmxvd0luc2lkZScpKSByZXR1cm5cbiAgICB0aGlzLmJ1ZmZlcigpXG4gICAgdGhpcy5zZXREYXRhKCdtYXRoRmxvd0luc2lkZScsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKCkucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG4gICAgY29uc3Qgbm9kZSA9IC8qKiBAdHlwZSB7TWF0aH0gKi8gKHRoaXMuZXhpdCh0b2tlbikpXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBkZWZpbmVkIGl0LlxuICAgIG5vZGUuZGF0YS5oQ2hpbGRyZW5bMF0udmFsdWUgPSBkYXRhXG4gICAgdGhpcy5zZXREYXRhKCdtYXRoRmxvd0luc2lkZScpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNYXRoVGV4dCh0b2tlbikge1xuICAgIHRoaXMuZW50ZXIoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdpbmxpbmVNYXRoJyxcbiAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaE5hbWU6ICdzcGFuJyxcbiAgICAgICAgICBoUHJvcGVydGllczoge2NsYXNzTmFtZTogWydtYXRoJywgJ21hdGgtaW5saW5lJ119LFxuICAgICAgICAgIGhDaGlsZHJlbjogW3t0eXBlOiAndGV4dCcsIHZhbHVlOiAnJ31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblxuICAgIClcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhUZXh0KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtNYXRofSAqLyAodGhpcy5leGl0KHRva2VuKSlcbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdlIGRlZmluZWQgaXQuXG4gICAgbm9kZS5kYXRhLmhDaGlsZHJlblswXS52YWx1ZSA9IGRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWF0aERhdGEodG9rZW4pIHtcbiAgICB0aGlzLmNvbmZpZy5lbnRlci5kYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gICAgdGhpcy5jb25maWcuZXhpdC5kYXRhLmNhbGwodGhpcywgdG9rZW4pXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAuXG4gKlxuICogQHBhcmFtIHtUb09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGhUb01hcmtkb3duKG9wdGlvbnMpIHtcbiAgbGV0IHNpbmdsZSA9IChvcHRpb25zIHx8IHt9KS5zaW5nbGVEb2xsYXJUZXh0TWF0aFxuXG4gIGlmIChzaW5nbGUgPT09IG51bGwgfHwgc2luZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaW5nbGUgPSB0cnVlXG4gIH1cblxuICBpbmxpbmVNYXRoLnBlZWsgPSBpbmxpbmVNYXRoUGVla1xuXG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6ICdtYXRoRmxvd01ldGEnfSxcbiAgICAgIHtjaGFyYWN0ZXI6ICdcXG4nLCBpbkNvbnN0cnVjdDogJ21hdGhGbG93TWV0YSd9LFxuICAgICAge1xuICAgICAgICBjaGFyYWN0ZXI6ICckJyxcbiAgICAgICAgYWZ0ZXI6IHNpbmdsZSA/IHVuZGVmaW5lZCA6ICdcXFxcJCcsXG4gICAgICAgIGluQ29uc3RydWN0OiAncGhyYXNpbmcnXG4gICAgICB9LFxuICAgICAge2NoYXJhY3RlcjogJyQnLCBpbkNvbnN0cnVjdDogJ21hdGhGbG93TWV0YSd9LFxuICAgICAge2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJyQnLCBhZnRlcjogJ1xcXFwkJ31cbiAgICBdLFxuICAgIGhhbmRsZXJzOiB7bWF0aCwgaW5saW5lTWF0aH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtNYXRofSBub2RlXG4gICAqL1xuICAvLyBUbyBkbzogbmV4dCBtYWpvcjogcmVuYW1lIGBjb250ZXh0YCB0byBzdGF0ZSwgYHNhZmVPcHRpb25zYCB0byBpbmZvLlxuICAvLyBOb3RlOiBmaXhpbmcgdGhpcyBjb2RlPyBQbGVhc2UgYWxzbyBmaXggdGhlIHNpbWlsYXIgY29kZSBmb3IgY29kZTpcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvbWFpbi9saWIvaGFuZGxlL2NvZGUuanM+XG4gIGZ1bmN0aW9uIG1hdGgobm9kZSwgXywgY29udGV4dCwgc2FmZU9wdGlvbnMpIHtcbiAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlIHx8ICcnXG4gICAgY29uc3QgdHJhY2tlciA9IHRyYWNrKHNhZmVPcHRpb25zKVxuICAgIGNvbnN0IHNlcXVlbmNlID0gJyQnLnJlcGVhdChNYXRoLm1heChsb25nZXN0U3RyZWFrKHJhdywgJyQnKSArIDEsIDIpKVxuICAgIGNvbnN0IGV4aXQgPSBjb250ZXh0LmVudGVyKCdtYXRoRmxvdycpXG4gICAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKHNlcXVlbmNlKVxuXG4gICAgaWYgKG5vZGUubWV0YSkge1xuICAgICAgY29uc3Qgc3ViZXhpdCA9IGNvbnRleHQuZW50ZXIoJ21hdGhGbG93TWV0YScpXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAgIHNhZmUoY29udGV4dCwgbm9kZS5tZXRhLCB7XG4gICAgICAgICAgYmVmb3JlOiB2YWx1ZSxcbiAgICAgICAgICBhZnRlcjogJ1xcbicsXG4gICAgICAgICAgZW5jb2RlOiBbJyQnXSxcbiAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgc3ViZXhpdCgpXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuXG4gICAgaWYgKHJhdykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHJhdyArICdcXG4nKVxuICAgIH1cblxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShzZXF1ZW5jZSlcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtJbmxpbmVNYXRofSBub2RlXG4gICAqL1xuICAvLyBOb3RlOiBmaXhpbmcgdGhpcyBjb2RlPyBQbGVhc2UgYWxzbyBmaXggdGhlIHNpbWlsYXIgY29kZSBmb3IgaW5saW5lIGNvZGU6XG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iL21haW4vbGliL2hhbmRsZS9pbmxpbmUtY29kZS5qcz5cbiAgLy9cbiAgLy8gVG8gZG86IG5leHQgbWFqb3I6IHJlbmFtZSBgY29udGV4dGAgdG8gc3RhdGUuXG4gIC8vIFRvIGRvOiBuZXh0IG1ham9yOiB1c2UgYHN0YXRlYCAoYHNhZmVgLCBgdHJhY2tgLCBgcGF0dGVybkNvbXBpbGVgKS5cbiAgZnVuY3Rpb24gaW5saW5lTWF0aChub2RlLCBfLCBjb250ZXh0KSB7XG4gICAgbGV0IHZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJ1xuICAgIGxldCBzaXplID0gMVxuXG4gICAgaWYgKCFzaW5nbGUpIHNpemUrK1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBzaW5nbGUgZG9sbGFyIHNpZ24gb24gaXRzIG93biBpbiB0aGUgbWF0aCwgdXNlIGEgZmVuY2Ugb2ZcbiAgICAvLyB0d28uXG4gICAgLy8gSWYgdGhlcmUgYXJlIHR3byBpbiBhIHJvdywgdXNlIG9uZS5cbiAgICB3aGlsZSAoXG4gICAgICBuZXcgUmVnRXhwKCcoXnxbXiRdKScgKyAnXFxcXCQnLnJlcGVhdChzaXplKSArICcoW14kXXwkKScpLnRlc3QodmFsdWUpXG4gICAgKSB7XG4gICAgICBzaXplKytcbiAgICB9XG5cbiAgICBjb25zdCBzZXF1ZW5jZSA9ICckJy5yZXBlYXQoc2l6ZSlcblxuICAgIC8vIElmIHRoaXMgaXMgbm90IGp1c3Qgc3BhY2VzIG9yIGVvbHMgKHRhYnMgZG9u4oCZdCBjb3VudCksIGFuZCBlaXRoZXIgdGhlXG4gICAgLy8gZmlyc3QgYW5kIGxhc3QgY2hhcmFjdGVyIGFyZSBhIHNwYWNlIG9yIGVvbCwgb3IgdGhlIGZpcnN0IG9yIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgYXJlIGRvbGxhciBzaWducywgdGhlbiBwYWQgd2l0aCBzcGFjZXMuXG4gICAgaWYgKFxuICAgICAgLy8gQ29udGFpbnMgbm9uLXNwYWNlLlxuICAgICAgL1teIFxcclxcbl0vLnRlc3QodmFsdWUpICYmXG4gICAgICAvLyBTdGFydHMgd2l0aCBzcGFjZSBhbmQgZW5kcyB3aXRoIHNwYWNlLlxuICAgICAgKCgvXlsgXFxyXFxuXS8udGVzdCh2YWx1ZSkgJiYgL1sgXFxyXFxuXSQvLnRlc3QodmFsdWUpKSB8fFxuICAgICAgICAvLyBTdGFydHMgb3IgZW5kcyB3aXRoIGRvbGxhci5cbiAgICAgICAgL15cXCR8XFwkJC8udGVzdCh2YWx1ZSkpXG4gICAgKSB7XG4gICAgICB2YWx1ZSA9ICcgJyArIHZhbHVlICsgJyAnXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIC8vIFdlIGhhdmUgYSBwb3RlbnRpYWwgcHJvYmxlbTogY2VydGFpbiBjaGFyYWN0ZXJzIGFmdGVyIGVvbHMgY291bGQgcmVzdWx0IGluXG4gICAgLy8gYmxvY2tzIGJlaW5nIHNlZW4uXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHNvbWVvbmUgaW5qZWN0ZWQgdGhlIHN0cmluZyBgJ1xcbiMgYidgLCB0aGVuIHRoYXQgd291bGRcbiAgICAvLyByZXN1bHQgaW4gYW4gQVRYIGhlYWRpbmcuXG4gICAgLy8gV2UgY2Fu4oCZdCBlc2NhcGUgY2hhcmFjdGVycyBpbiBgaW5saW5lTWF0aGAsIGJ1dCBiZWNhdXNlIGVvbHMgYXJlXG4gICAgLy8gdHJhbnNmb3JtZWQgdG8gc3BhY2VzIHdoZW4gZ29pbmcgZnJvbSBtYXJrZG93biB0byBIVE1MIGFueXdheSwgd2UgY2FuIHN3YXBcbiAgICAvLyB0aGVtIG91dC5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNvbnRleHQudW5zYWZlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGF0dGVybiA9IGNvbnRleHQudW5zYWZlW2luZGV4XVxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhdHRlcm5Db21waWxlKHBhdHRlcm4pXG4gICAgICAvKiogQHR5cGUge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9ICovXG4gICAgICBsZXQgbWF0Y2hcblxuICAgICAgLy8gT25seSBsb29rIGZvciBgYXRCcmVha2BzLlxuICAgICAgLy8gQnR3OiBub3RlIHRoYXQgYGF0QnJlYWtgIHBhdHRlcm5zIHdpbGwgYWx3YXlzIHN0YXJ0IHRoZSByZWdleCBhdCBMRiBvclxuICAgICAgLy8gQ1IuXG4gICAgICBpZiAoIXBhdHRlcm4uYXRCcmVhaykgY29udGludWVcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IGV4cHJlc3Npb24uZXhlYyh2YWx1ZSkpKSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IG1hdGNoLmluZGV4XG5cbiAgICAgICAgLy8gU3VwcG9ydCBDUkxGIChwYXR0ZXJucyBvbmx5IGxvb2sgZm9yIG9uZSBvZiB0aGUgY2hhcmFjdGVycykuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS5jb2RlUG9pbnRBdChwb3NpdGlvbikgPT09IDEwIC8qIGBcXG5gICovICYmXG4gICAgICAgICAgdmFsdWUuY29kZVBvaW50QXQocG9zaXRpb24gLSAxKSA9PT0gMTMgLyogYFxccmAgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgcG9zaXRpb24tLVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwb3NpdGlvbikgKyAnICcgKyB2YWx1ZS5zbGljZShtYXRjaC5pbmRleCArIDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcXVlbmNlICsgdmFsdWUgKyBzZXF1ZW5jZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBpbmxpbmVNYXRoUGVlaygpIHtcbiAgICByZXR1cm4gJyQnXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJsb25nZXN0U3RyZWFrIiwic2FmZSIsInRyYWNrIiwicGF0dGVybkNvbXBpbGUiLCJtYXRoRnJvbU1hcmtkb3duIiwiZW50ZXIiLCJtYXRoRmxvdyIsImVudGVyTWF0aEZsb3ciLCJtYXRoRmxvd0ZlbmNlTWV0YSIsImVudGVyTWF0aEZsb3dNZXRhIiwibWF0aFRleHQiLCJlbnRlck1hdGhUZXh0IiwiZXhpdCIsImV4aXRNYXRoRmxvdyIsIm1hdGhGbG93RmVuY2UiLCJleGl0TWF0aEZsb3dGZW5jZSIsImV4aXRNYXRoRmxvd01ldGEiLCJtYXRoRmxvd1ZhbHVlIiwiZXhpdE1hdGhEYXRhIiwiZXhpdE1hdGhUZXh0IiwibWF0aFRleHREYXRhIiwidG9rZW4iLCJ0eXBlIiwibWV0YSIsInZhbHVlIiwiZGF0YSIsImhOYW1lIiwiaFByb3BlcnRpZXMiLCJjbGFzc05hbWUiLCJoQ2hpbGRyZW4iLCJidWZmZXIiLCJyZXN1bWUiLCJub2RlIiwic3RhY2siLCJsZW5ndGgiLCJnZXREYXRhIiwic2V0RGF0YSIsInJlcGxhY2UiLCJjb25maWciLCJjYWxsIiwibWF0aFRvTWFya2Rvd24iLCJvcHRpb25zIiwic2luZ2xlIiwic2luZ2xlRG9sbGFyVGV4dE1hdGgiLCJ1bmRlZmluZWQiLCJpbmxpbmVNYXRoIiwicGVlayIsImlubGluZU1hdGhQZWVrIiwidW5zYWZlIiwiY2hhcmFjdGVyIiwiaW5Db25zdHJ1Y3QiLCJhZnRlciIsImF0QnJlYWsiLCJoYW5kbGVycyIsIm1hdGgiLCJfIiwiY29udGV4dCIsInNhZmVPcHRpb25zIiwicmF3IiwidHJhY2tlciIsInNlcXVlbmNlIiwicmVwZWF0IiwiTWF0aCIsIm1heCIsIm1vdmUiLCJzdWJleGl0IiwiYmVmb3JlIiwiZW5jb2RlIiwiY3VycmVudCIsInNpemUiLCJSZWdFeHAiLCJ0ZXN0IiwiaW5kZXgiLCJwYXR0ZXJuIiwiZXhwcmVzc2lvbiIsIm1hdGNoIiwiZXhlYyIsInBvc2l0aW9uIiwiY29kZVBvaW50QXQiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mdast-util-math/lib/index.js\n");

/***/ })

};
;